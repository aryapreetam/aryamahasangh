scalar Boolean

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean

  _gt: Boolean

  _gte: Boolean

  _in: [Boolean!]

  _is_null: Boolean

  _lt: Boolean

  _lte: Boolean

  _neq: Boolean

  _nin: [Boolean!]
}

scalar Float

scalar Int

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int

  _gt: Int

  _gte: Int

  _in: [Int!]

  _is_null: Boolean

  _lt: Int

  _lte: Int

  _neq: Int

  _nin: [Int!]
}

scalar String

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_array_comparison_exp {
  """
  is the array contained in the given array value
  """
  _contained_in: [String!]

  """
  does the array contain the given value
  """
  _contains: [String!]

  _eq: [String!]

  _gt: [String!]

  _gte: [String!]

  _in: [[String!]!]

  _is_null: Boolean

  _lt: [String!]

  _lte: [String!]

  _neq: [String!]

  _nin: [[String!]!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String

  _gt: String

  _gte: String

  """
  does the column match the given case-insensitive pattern
  """
  _ilike: String

  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String

  _is_null: Boolean

  """
  does the column match the given pattern
  """
  _like: String

  _lt: String

  _lte: String

  _neq: String

  """
  does the column NOT match the given case-insensitive pattern
  """
  _nilike: String

  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """
  does the column NOT match the given pattern
  """
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """
  does the column NOT match the given SQL regular expression
  """
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """
  does the column match the given SQL regular expression
  """
  _similar: String
}

type __Directive {
  args: __InputValue

  description: String!

  isRepeatable: Boolean!

  locations: String!

  name: String!
}

type __EnumValue {
  deprecationReason: String!

  description: String!

  isDeprecated: String!

  name: String!
}

type __Field {
  args: __InputValue

  deprecationReason: String!

  description: String!

  isDeprecated: String!

  name: String!

  type: __Type
}

type __InputValue {
  defaultValue: String!

  description: String!

  name: String!

  type: __Type
}

type __Schema {
  description: String!

  directives: __Directive

  mutationType: __Type

  queryType: __Type

  subscriptionType: __Type

  types: __Type
}

type __Type {
  description: String!

  enumValues(includeDeprecated: Boolean = false): __EnumValue

  fields(includeDeprecated: Boolean = false): __Field

  inputFields: __InputValue

  interfaces: __Type

  kind: __TypeKind!

  name: String!

  ofType: __Type

  possibleTypes: __Type
}

enum __TypeKind {
  ENUM

  INPUT_OBJECT

  INTERFACE

  LIST

  NON_NULL

  OBJECT

  SCALAR

  UNION
}

"""
columns and relationships of "activities"
"""
type activities {
  """
  An array relationship
  """
  activity_members("distinct select on columns" distinct_on: [activity_member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [activity_member_order_by!], "filter the rows returned" where: activity_member_bool_exp): [activity_member!]!

  """
  An aggregate relationship
  """
  activity_members_aggregate("distinct select on columns" distinct_on: [activity_member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [activity_member_order_by!], "filter the rows returned" where: activity_member_bool_exp): activity_member_aggregate!

  """
  An object relationship
  """
  activity_type: activity_type

  additional_instructions: String

  """
  An object relationship
  """
  address: address

  address_id: String

  allowed_gender: String

  capacity: Int

  """
  An array relationship
  """
  course_registrations("distinct select on columns" distinct_on: [course_registrations_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [course_registrations_order_by!], "filter the rows returned" where: course_registrations_bool_exp): [course_registrations!]!

  """
  An aggregate relationship
  """
  course_registrations_aggregate("distinct select on columns" distinct_on: [course_registrations_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [course_registrations_order_by!], "filter the rows returned" where: course_registrations_bool_exp): course_registrations_aggregate!

  end_datetime: timestamptz!

  """
  An object relationship
  """
  gender_filter: gender_filter

  id: String!

  long_description: String!

  media_files: [String!]!

  name: String!

  """
  An array relationship
  """
  organisational_activities("distinct select on columns" distinct_on: [organisational_activity_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [organisational_activity_order_by!], "filter the rows returned" where: organisational_activity_bool_exp): [organisational_activity!]!

  """
  An aggregate relationship
  """
  organisational_activities_aggregate("distinct select on columns" distinct_on: [organisational_activity_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [organisational_activity_order_by!], "filter the rows returned" where: organisational_activity_bool_exp): organisational_activity_aggregate!

  overview_description: String

  overview_media_urls: [String!]!

  """
  An array relationship
  """
  satr_registrations("distinct select on columns" distinct_on: [satr_registration_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [satr_registration_order_by!], "filter the rows returned" where: satr_registration_bool_exp): [satr_registration!]!

  """
  An aggregate relationship
  """
  satr_registrations_aggregate("distinct select on columns" distinct_on: [satr_registration_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [satr_registration_order_by!], "filter the rows returned" where: satr_registration_bool_exp): satr_registration_aggregate!

  short_description: String!

  start_datetime: timestamptz!

  type: String
}

"""
aggregated selection of "activities"
"""
type activities_aggregate {
  aggregate: activities_aggregate_fields

  nodes: [activities!]!
}

input activities_aggregate_bool_exp {
  count: activities_aggregate_bool_exp_count
}

input activities_aggregate_bool_exp_count {
  arguments: [activities_select_column!]

  distinct: Boolean

  filter: activities_bool_exp

  predicate: Int_comparison_exp!
}

"""
aggregate fields of "activities"
"""
type activities_aggregate_fields {
  avg: activities_avg_fields

  count(columns: [activities_select_column!], distinct: Boolean): Int!

  max: activities_max_fields

  min: activities_min_fields

  stddev: activities_stddev_fields

  stddev_pop: activities_stddev_pop_fields

  stddev_samp: activities_stddev_samp_fields

  sum: activities_sum_fields

  var_pop: activities_var_pop_fields

  var_samp: activities_var_samp_fields

  variance: activities_variance_fields
}

"""
order by aggregate values of table "activities"
"""
input activities_aggregate_order_by {
  avg: activities_avg_order_by

  count: order_by

  max: activities_max_order_by

  min: activities_min_order_by

  stddev: activities_stddev_order_by

  stddev_pop: activities_stddev_pop_order_by

  stddev_samp: activities_stddev_samp_order_by

  sum: activities_sum_order_by

  var_pop: activities_var_pop_order_by

  var_samp: activities_var_samp_order_by

  variance: activities_variance_order_by
}

"""
input type for inserting array relation for remote table "activities"
"""
input activities_arr_rel_insert_input {
  data: [activities_insert_input!]!

  """
  upsert condition
  """
  on_conflict: activities_on_conflict
}

"""
aggregate avg on columns
"""
type activities_avg_fields {
  capacity: Float
}

"""
order by avg() on columns of table "activities"
"""
input activities_avg_order_by {
  capacity: order_by
}

"""
Boolean expression to filter rows from the table "activities". All fields are combined with a logical 'AND'.
"""
input activities_bool_exp {
  _and: [activities_bool_exp!]

  _not: activities_bool_exp

  _or: [activities_bool_exp!]

  activity_members: activity_member_bool_exp

  activity_members_aggregate: activity_member_aggregate_bool_exp

  activity_type: activity_type_bool_exp

  additional_instructions: String_comparison_exp

  address: address_bool_exp

  address_id: String_comparison_exp

  allowed_gender: String_comparison_exp

  capacity: Int_comparison_exp

  course_registrations: course_registrations_bool_exp

  course_registrations_aggregate: course_registrations_aggregate_bool_exp

  end_datetime: timestamptz_comparison_exp

  gender_filter: gender_filter_bool_exp

  id: String_comparison_exp

  long_description: String_comparison_exp

  media_files: String_array_comparison_exp

  name: String_comparison_exp

  organisational_activities: organisational_activity_bool_exp

  organisational_activities_aggregate: organisational_activity_aggregate_bool_exp

  overview_description: String_comparison_exp

  overview_media_urls: String_array_comparison_exp

  satr_registrations: satr_registration_bool_exp

  satr_registrations_aggregate: satr_registration_aggregate_bool_exp

  short_description: String_comparison_exp

  start_datetime: timestamptz_comparison_exp

  type: String_comparison_exp
}

"""
unique or primary key constraints on table "activities"
"""
enum activities_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  activities_pkey
}

"""
input type for incrementing numeric columns in table "activities"
"""
input activities_inc_input {
  capacity: Int
}

"""
input type for inserting data into table "activities"
"""
input activities_insert_input {
  activity_members: activity_member_arr_rel_insert_input

  activity_type: activity_type_obj_rel_insert_input

  additional_instructions: String

  address: address_obj_rel_insert_input

  address_id: String

  allowed_gender: String

  capacity: Int

  course_registrations: course_registrations_arr_rel_insert_input

  end_datetime: timestamptz

  gender_filter: gender_filter_obj_rel_insert_input

  id: String

  long_description: String

  media_files: [String!]

  name: String

  organisational_activities: organisational_activity_arr_rel_insert_input

  overview_description: String

  overview_media_urls: [String!]

  satr_registrations: satr_registration_arr_rel_insert_input

  short_description: String

  start_datetime: timestamptz

  type: String
}

"""
aggregate max on columns
"""
type activities_max_fields {
  additional_instructions: String

  address_id: String

  allowed_gender: String

  capacity: Int

  end_datetime: timestamptz

  id: String

  long_description: String

  media_files: [String!]

  name: String

  overview_description: String

  overview_media_urls: [String!]

  short_description: String

  start_datetime: timestamptz

  type: String
}

"""
order by max() on columns of table "activities"
"""
input activities_max_order_by {
  additional_instructions: order_by

  address_id: order_by

  allowed_gender: order_by

  capacity: order_by

  end_datetime: order_by

  id: order_by

  long_description: order_by

  media_files: order_by

  name: order_by

  overview_description: order_by

  overview_media_urls: order_by

  short_description: order_by

  start_datetime: order_by

  type: order_by
}

"""
aggregate min on columns
"""
type activities_min_fields {
  additional_instructions: String

  address_id: String

  allowed_gender: String

  capacity: Int

  end_datetime: timestamptz

  id: String

  long_description: String

  media_files: [String!]

  name: String

  overview_description: String

  overview_media_urls: [String!]

  short_description: String

  start_datetime: timestamptz

  type: String
}

"""
order by min() on columns of table "activities"
"""
input activities_min_order_by {
  additional_instructions: order_by

  address_id: order_by

  allowed_gender: order_by

  capacity: order_by

  end_datetime: order_by

  id: order_by

  long_description: order_by

  media_files: order_by

  name: order_by

  overview_description: order_by

  overview_media_urls: order_by

  short_description: order_by

  start_datetime: order_by

  type: order_by
}

"""
response of any mutation on the table "activities"
"""
type activities_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [activities!]!
}

"""
input type for inserting object relation for remote table "activities"
"""
input activities_obj_rel_insert_input {
  data: activities_insert_input!

  """
  upsert condition
  """
  on_conflict: activities_on_conflict
}

"""
on_conflict condition type for table "activities"
"""
input activities_on_conflict {
  constraint: activities_constraint!

  update_columns: [activities_update_column!]! = []

  where: activities_bool_exp
}

"""
Ordering options when selecting data from "activities".
"""
input activities_order_by {
  activity_members_aggregate: activity_member_aggregate_order_by

  activity_type: activity_type_order_by

  additional_instructions: order_by

  address: address_order_by

  address_id: order_by

  allowed_gender: order_by

  capacity: order_by

  course_registrations_aggregate: course_registrations_aggregate_order_by

  end_datetime: order_by

  gender_filter: gender_filter_order_by

  id: order_by

  long_description: order_by

  media_files: order_by

  name: order_by

  organisational_activities_aggregate: organisational_activity_aggregate_order_by

  overview_description: order_by

  overview_media_urls: order_by

  satr_registrations_aggregate: satr_registration_aggregate_order_by

  short_description: order_by

  start_datetime: order_by

  type: order_by
}

"""
primary key columns input for table: activities
"""
input activities_pk_columns_input {
  id: String!
}

"""
select columns of table "activities"
"""
enum activities_select_column {
  """
  column name
  """
  additional_instructions

  """
  column name
  """
  address_id

  """
  column name
  """
  allowed_gender

  """
  column name
  """
  capacity

  """
  column name
  """
  end_datetime

  """
  column name
  """
  id

  """
  column name
  """
  long_description

  """
  column name
  """
  media_files

  """
  column name
  """
  name

  """
  column name
  """
  overview_description

  """
  column name
  """
  overview_media_urls

  """
  column name
  """
  short_description

  """
  column name
  """
  start_datetime

  """
  column name
  """
  type
}

"""
input type for updating data in table "activities"
"""
input activities_set_input {
  additional_instructions: String

  address_id: String

  allowed_gender: String

  capacity: Int

  end_datetime: timestamptz

  id: String

  long_description: String

  media_files: [String!]

  name: String

  overview_description: String

  overview_media_urls: [String!]

  short_description: String

  start_datetime: timestamptz

  type: String
}

"""
aggregate stddev on columns
"""
type activities_stddev_fields {
  capacity: Float
}

"""
order by stddev() on columns of table "activities"
"""
input activities_stddev_order_by {
  capacity: order_by
}

"""
aggregate stddev_pop on columns
"""
type activities_stddev_pop_fields {
  capacity: Float
}

"""
order by stddev_pop() on columns of table "activities"
"""
input activities_stddev_pop_order_by {
  capacity: order_by
}

"""
aggregate stddev_samp on columns
"""
type activities_stddev_samp_fields {
  capacity: Float
}

"""
order by stddev_samp() on columns of table "activities"
"""
input activities_stddev_samp_order_by {
  capacity: order_by
}

"""
Streaming cursor of the table "activities"
"""
input activities_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: activities_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input activities_stream_cursor_value_input {
  additional_instructions: String

  address_id: String

  allowed_gender: String

  capacity: Int

  end_datetime: timestamptz

  id: String

  long_description: String

  media_files: [String!]

  name: String

  overview_description: String

  overview_media_urls: [String!]

  short_description: String

  start_datetime: timestamptz

  type: String
}

"""
aggregate sum on columns
"""
type activities_sum_fields {
  capacity: Int
}

"""
order by sum() on columns of table "activities"
"""
input activities_sum_order_by {
  capacity: order_by
}

"""
update columns of table "activities"
"""
enum activities_update_column {
  """
  column name
  """
  additional_instructions

  """
  column name
  """
  address_id

  """
  column name
  """
  allowed_gender

  """
  column name
  """
  capacity

  """
  column name
  """
  end_datetime

  """
  column name
  """
  id

  """
  column name
  """
  long_description

  """
  column name
  """
  media_files

  """
  column name
  """
  name

  """
  column name
  """
  overview_description

  """
  column name
  """
  overview_media_urls

  """
  column name
  """
  short_description

  """
  column name
  """
  start_datetime

  """
  column name
  """
  type
}

input activities_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: activities_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: activities_set_input

  """
  filter the rows which have to be updated
  """
  where: activities_bool_exp!
}

"""
aggregate var_pop on columns
"""
type activities_var_pop_fields {
  capacity: Float
}

"""
order by var_pop() on columns of table "activities"
"""
input activities_var_pop_order_by {
  capacity: order_by
}

"""
aggregate var_samp on columns
"""
type activities_var_samp_fields {
  capacity: Float
}

"""
order by var_samp() on columns of table "activities"
"""
input activities_var_samp_order_by {
  capacity: order_by
}

"""
aggregate variance on columns
"""
type activities_variance_fields {
  capacity: Float
}

"""
order by variance() on columns of table "activities"
"""
input activities_variance_order_by {
  capacity: order_by
}

"""
columns and relationships of "activity_member"
"""
type activity_member {
  """
  An object relationship
  """
  activity: activities!

  activity_id: String!

  id: uuid!

  """
  An object relationship
  """
  member: member!

  member_id: String!

  post: String

  priority: smallint!
}

"""
aggregated selection of "activity_member"
"""
type activity_member_aggregate {
  aggregate: activity_member_aggregate_fields

  nodes: [activity_member!]!
}

input activity_member_aggregate_bool_exp {
  count: activity_member_aggregate_bool_exp_count
}

input activity_member_aggregate_bool_exp_count {
  arguments: [activity_member_select_column!]

  distinct: Boolean

  filter: activity_member_bool_exp

  predicate: Int_comparison_exp!
}

"""
aggregate fields of "activity_member"
"""
type activity_member_aggregate_fields {
  avg: activity_member_avg_fields

  count(columns: [activity_member_select_column!], distinct: Boolean): Int!

  max: activity_member_max_fields

  min: activity_member_min_fields

  stddev: activity_member_stddev_fields

  stddev_pop: activity_member_stddev_pop_fields

  stddev_samp: activity_member_stddev_samp_fields

  sum: activity_member_sum_fields

  var_pop: activity_member_var_pop_fields

  var_samp: activity_member_var_samp_fields

  variance: activity_member_variance_fields
}

"""
order by aggregate values of table "activity_member"
"""
input activity_member_aggregate_order_by {
  avg: activity_member_avg_order_by

  count: order_by

  max: activity_member_max_order_by

  min: activity_member_min_order_by

  stddev: activity_member_stddev_order_by

  stddev_pop: activity_member_stddev_pop_order_by

  stddev_samp: activity_member_stddev_samp_order_by

  sum: activity_member_sum_order_by

  var_pop: activity_member_var_pop_order_by

  var_samp: activity_member_var_samp_order_by

  variance: activity_member_variance_order_by
}

"""
input type for inserting array relation for remote table "activity_member"
"""
input activity_member_arr_rel_insert_input {
  data: [activity_member_insert_input!]!

  """
  upsert condition
  """
  on_conflict: activity_member_on_conflict
}

"""
aggregate avg on columns
"""
type activity_member_avg_fields {
  priority: Float
}

"""
order by avg() on columns of table "activity_member"
"""
input activity_member_avg_order_by {
  priority: order_by
}

"""
Boolean expression to filter rows from the table "activity_member". All fields are combined with a logical 'AND'.
"""
input activity_member_bool_exp {
  _and: [activity_member_bool_exp!]

  _not: activity_member_bool_exp

  _or: [activity_member_bool_exp!]

  activity: activities_bool_exp

  activity_id: String_comparison_exp

  id: uuid_comparison_exp

  member: member_bool_exp

  member_id: String_comparison_exp

  post: String_comparison_exp

  priority: smallint_comparison_exp
}

"""
unique or primary key constraints on table "activity_member"
"""
enum activity_member_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  activity_member_pkey
}

"""
input type for incrementing numeric columns in table "activity_member"
"""
input activity_member_inc_input {
  priority: smallint
}

"""
input type for inserting data into table "activity_member"
"""
input activity_member_insert_input {
  activity: activities_obj_rel_insert_input

  activity_id: String

  id: uuid

  member: member_obj_rel_insert_input

  member_id: String

  post: String

  priority: smallint
}

"""
aggregate max on columns
"""
type activity_member_max_fields {
  activity_id: String

  id: uuid

  member_id: String

  post: String

  priority: smallint
}

"""
order by max() on columns of table "activity_member"
"""
input activity_member_max_order_by {
  activity_id: order_by

  id: order_by

  member_id: order_by

  post: order_by

  priority: order_by
}

"""
aggregate min on columns
"""
type activity_member_min_fields {
  activity_id: String

  id: uuid

  member_id: String

  post: String

  priority: smallint
}

"""
order by min() on columns of table "activity_member"
"""
input activity_member_min_order_by {
  activity_id: order_by

  id: order_by

  member_id: order_by

  post: order_by

  priority: order_by
}

"""
response of any mutation on the table "activity_member"
"""
type activity_member_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [activity_member!]!
}

"""
on_conflict condition type for table "activity_member"
"""
input activity_member_on_conflict {
  constraint: activity_member_constraint!

  update_columns: [activity_member_update_column!]! = []

  where: activity_member_bool_exp
}

"""
Ordering options when selecting data from "activity_member".
"""
input activity_member_order_by {
  activity: activities_order_by

  activity_id: order_by

  id: order_by

  member: member_order_by

  member_id: order_by

  post: order_by

  priority: order_by
}

"""
primary key columns input for table: activity_member
"""
input activity_member_pk_columns_input {
  id: uuid!
}

"""
select columns of table "activity_member"
"""
enum activity_member_select_column {
  """
  column name
  """
  activity_id

  """
  column name
  """
  id

  """
  column name
  """
  member_id

  """
  column name
  """
  post

  """
  column name
  """
  priority
}

"""
input type for updating data in table "activity_member"
"""
input activity_member_set_input {
  activity_id: String

  id: uuid

  member_id: String

  post: String

  priority: smallint
}

"""
aggregate stddev on columns
"""
type activity_member_stddev_fields {
  priority: Float
}

"""
order by stddev() on columns of table "activity_member"
"""
input activity_member_stddev_order_by {
  priority: order_by
}

"""
aggregate stddev_pop on columns
"""
type activity_member_stddev_pop_fields {
  priority: Float
}

"""
order by stddev_pop() on columns of table "activity_member"
"""
input activity_member_stddev_pop_order_by {
  priority: order_by
}

"""
aggregate stddev_samp on columns
"""
type activity_member_stddev_samp_fields {
  priority: Float
}

"""
order by stddev_samp() on columns of table "activity_member"
"""
input activity_member_stddev_samp_order_by {
  priority: order_by
}

"""
Streaming cursor of the table "activity_member"
"""
input activity_member_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: activity_member_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input activity_member_stream_cursor_value_input {
  activity_id: String

  id: uuid

  member_id: String

  post: String

  priority: smallint
}

"""
aggregate sum on columns
"""
type activity_member_sum_fields {
  priority: smallint
}

"""
order by sum() on columns of table "activity_member"
"""
input activity_member_sum_order_by {
  priority: order_by
}

"""
update columns of table "activity_member"
"""
enum activity_member_update_column {
  """
  column name
  """
  activity_id

  """
  column name
  """
  id

  """
  column name
  """
  member_id

  """
  column name
  """
  post

  """
  column name
  """
  priority
}

input activity_member_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: activity_member_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: activity_member_set_input

  """
  filter the rows which have to be updated
  """
  where: activity_member_bool_exp!
}

"""
aggregate var_pop on columns
"""
type activity_member_var_pop_fields {
  priority: Float
}

"""
order by var_pop() on columns of table "activity_member"
"""
input activity_member_var_pop_order_by {
  priority: order_by
}

"""
aggregate var_samp on columns
"""
type activity_member_var_samp_fields {
  priority: Float
}

"""
order by var_samp() on columns of table "activity_member"
"""
input activity_member_var_samp_order_by {
  priority: order_by
}

"""
aggregate variance on columns
"""
type activity_member_variance_fields {
  priority: Float
}

"""
order by variance() on columns of table "activity_member"
"""
input activity_member_variance_order_by {
  priority: order_by
}

"""
columns and relationships of "activity_type"
"""
type activity_type {
  """
  An array relationship
  """
  activities("distinct select on columns" distinct_on: [activities_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [activities_order_by!], "filter the rows returned" where: activities_bool_exp): [activities!]!

  """
  An aggregate relationship
  """
  activities_aggregate("distinct select on columns" distinct_on: [activities_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [activities_order_by!], "filter the rows returned" where: activities_bool_exp): activities_aggregate!

  comment: String

  value: String!
}

"""
aggregated selection of "activity_type"
"""
type activity_type_aggregate {
  aggregate: activity_type_aggregate_fields

  nodes: [activity_type!]!
}

"""
aggregate fields of "activity_type"
"""
type activity_type_aggregate_fields {
  count(columns: [activity_type_select_column!], distinct: Boolean): Int!

  max: activity_type_max_fields

  min: activity_type_min_fields
}

"""
Boolean expression to filter rows from the table "activity_type". All fields are combined with a logical 'AND'.
"""
input activity_type_bool_exp {
  _and: [activity_type_bool_exp!]

  _not: activity_type_bool_exp

  _or: [activity_type_bool_exp!]

  activities: activities_bool_exp

  activities_aggregate: activities_aggregate_bool_exp

  comment: String_comparison_exp

  value: String_comparison_exp
}

"""
unique or primary key constraints on table "activity_type"
"""
enum activity_type_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  activity_type_table_pkey
}

"""
input type for inserting data into table "activity_type"
"""
input activity_type_insert_input {
  activities: activities_arr_rel_insert_input

  comment: String

  value: String
}

"""
aggregate max on columns
"""
type activity_type_max_fields {
  comment: String

  value: String
}

"""
aggregate min on columns
"""
type activity_type_min_fields {
  comment: String

  value: String
}

"""
response of any mutation on the table "activity_type"
"""
type activity_type_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [activity_type!]!
}

"""
input type for inserting object relation for remote table "activity_type"
"""
input activity_type_obj_rel_insert_input {
  data: activity_type_insert_input!

  """
  upsert condition
  """
  on_conflict: activity_type_on_conflict
}

"""
on_conflict condition type for table "activity_type"
"""
input activity_type_on_conflict {
  constraint: activity_type_constraint!

  update_columns: [activity_type_update_column!]! = []

  where: activity_type_bool_exp
}

"""
Ordering options when selecting data from "activity_type".
"""
input activity_type_order_by {
  activities_aggregate: activities_aggregate_order_by

  comment: order_by

  value: order_by
}

"""
primary key columns input for table: activity_type
"""
input activity_type_pk_columns_input {
  value: String!
}

"""
select columns of table "activity_type"
"""
enum activity_type_select_column {
  """
  column name
  """
  comment

  """
  column name
  """
  value
}

"""
input type for updating data in table "activity_type"
"""
input activity_type_set_input {
  comment: String

  value: String
}

"""
Streaming cursor of the table "activity_type"
"""
input activity_type_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: activity_type_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input activity_type_stream_cursor_value_input {
  comment: String

  value: String
}

"""
update columns of table "activity_type"
"""
enum activity_type_update_column {
  """
  column name
  """
  comment

  """
  column name
  """
  value
}

input activity_type_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: activity_type_set_input

  """
  filter the rows which have to be updated
  """
  where: activity_type_bool_exp!
}

"""
columns and relationships of "address"
"""
type address {
  """
  An array relationship
  """
  activities("distinct select on columns" distinct_on: [activities_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [activities_order_by!], "filter the rows returned" where: activities_bool_exp): [activities!]!

  """
  An aggregate relationship
  """
  activities_aggregate("distinct select on columns" distinct_on: [activities_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [activities_order_by!], "filter the rows returned" where: activities_bool_exp): activities_aggregate!

  """
  An array relationship
  """
  arya_samajs("distinct select on columns" distinct_on: [arya_samaj_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [arya_samaj_order_by!], "filter the rows returned" where: arya_samaj_bool_exp): [arya_samaj!]!

  """
  An aggregate relationship
  """
  arya_samajs_aggregate("distinct select on columns" distinct_on: [arya_samaj_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [arya_samaj_order_by!], "filter the rows returned" where: arya_samaj_bool_exp): arya_samaj_aggregate!

  basic_address: String

  created_at: timestamptz!

  district: String

  """
  An array relationship
  """
  families("distinct select on columns" distinct_on: [family_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [family_order_by!], "filter the rows returned" where: family_bool_exp): [family!]!

  """
  An aggregate relationship
  """
  families_aggregate("distinct select on columns" distinct_on: [family_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [family_order_by!], "filter the rows returned" where: family_bool_exp): family_aggregate!

  id: String!

  latitude: float8

  longitude: float8

  """
  An array relationship
  """
  members("distinct select on columns" distinct_on: [member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [member_order_by!], "filter the rows returned" where: member_bool_exp): [member!]!

  """
  An array relationship
  """
  membersByTempAddressId("distinct select on columns" distinct_on: [member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [member_order_by!], "filter the rows returned" where: member_bool_exp): [member!]!

  """
  An aggregate relationship
  """
  membersByTempAddressId_aggregate("distinct select on columns" distinct_on: [member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [member_order_by!], "filter the rows returned" where: member_bool_exp): member_aggregate!

  """
  An aggregate relationship
  """
  members_aggregate("distinct select on columns" distinct_on: [member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [member_order_by!], "filter the rows returned" where: member_bool_exp): member_aggregate!

  pincode: String

  state: String

  vidhansabha: String
}

"""
aggregated selection of "address"
"""
type address_aggregate {
  aggregate: address_aggregate_fields

  nodes: [address!]!
}

"""
aggregate fields of "address"
"""
type address_aggregate_fields {
  avg: address_avg_fields

  count(columns: [address_select_column!], distinct: Boolean): Int!

  max: address_max_fields

  min: address_min_fields

  stddev: address_stddev_fields

  stddev_pop: address_stddev_pop_fields

  stddev_samp: address_stddev_samp_fields

  sum: address_sum_fields

  var_pop: address_var_pop_fields

  var_samp: address_var_samp_fields

  variance: address_variance_fields
}

"""
aggregate avg on columns
"""
type address_avg_fields {
  latitude: Float

  longitude: Float
}

"""
Boolean expression to filter rows from the table "address". All fields are combined with a logical 'AND'.
"""
input address_bool_exp {
  _and: [address_bool_exp!]

  _not: address_bool_exp

  _or: [address_bool_exp!]

  activities: activities_bool_exp

  activities_aggregate: activities_aggregate_bool_exp

  arya_samajs: arya_samaj_bool_exp

  arya_samajs_aggregate: arya_samaj_aggregate_bool_exp

  basic_address: String_comparison_exp

  created_at: timestamptz_comparison_exp

  district: String_comparison_exp

  families: family_bool_exp

  families_aggregate: family_aggregate_bool_exp

  id: String_comparison_exp

  latitude: float8_comparison_exp

  longitude: float8_comparison_exp

  members: member_bool_exp

  membersByTempAddressId: member_bool_exp

  membersByTempAddressId_aggregate: member_aggregate_bool_exp

  members_aggregate: member_aggregate_bool_exp

  pincode: String_comparison_exp

  state: String_comparison_exp

  vidhansabha: String_comparison_exp
}

"""
unique or primary key constraints on table "address"
"""
enum address_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  address_pkey
}

"""
input type for incrementing numeric columns in table "address"
"""
input address_inc_input {
  latitude: float8

  longitude: float8
}

"""
input type for inserting data into table "address"
"""
input address_insert_input {
  activities: activities_arr_rel_insert_input

  arya_samajs: arya_samaj_arr_rel_insert_input

  basic_address: String

  created_at: timestamptz

  district: String

  families: family_arr_rel_insert_input

  id: String

  latitude: float8

  longitude: float8

  members: member_arr_rel_insert_input

  membersByTempAddressId: member_arr_rel_insert_input

  pincode: String

  state: String

  vidhansabha: String
}

"""
aggregate max on columns
"""
type address_max_fields {
  basic_address: String

  created_at: timestamptz

  district: String

  id: String

  latitude: float8

  longitude: float8

  pincode: String

  state: String

  vidhansabha: String
}

"""
aggregate min on columns
"""
type address_min_fields {
  basic_address: String

  created_at: timestamptz

  district: String

  id: String

  latitude: float8

  longitude: float8

  pincode: String

  state: String

  vidhansabha: String
}

"""
response of any mutation on the table "address"
"""
type address_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [address!]!
}

"""
input type for inserting object relation for remote table "address"
"""
input address_obj_rel_insert_input {
  data: address_insert_input!

  """
  upsert condition
  """
  on_conflict: address_on_conflict
}

"""
on_conflict condition type for table "address"
"""
input address_on_conflict {
  constraint: address_constraint!

  update_columns: [address_update_column!]! = []

  where: address_bool_exp
}

"""
Ordering options when selecting data from "address".
"""
input address_order_by {
  activities_aggregate: activities_aggregate_order_by

  arya_samajs_aggregate: arya_samaj_aggregate_order_by

  basic_address: order_by

  created_at: order_by

  district: order_by

  families_aggregate: family_aggregate_order_by

  id: order_by

  latitude: order_by

  longitude: order_by

  membersByTempAddressId_aggregate: member_aggregate_order_by

  members_aggregate: member_aggregate_order_by

  pincode: order_by

  state: order_by

  vidhansabha: order_by
}

"""
primary key columns input for table: address
"""
input address_pk_columns_input {
  id: String!
}

"""
select columns of table "address"
"""
enum address_select_column {
  """
  column name
  """
  basic_address

  """
  column name
  """
  created_at

  """
  column name
  """
  district

  """
  column name
  """
  id

  """
  column name
  """
  latitude

  """
  column name
  """
  longitude

  """
  column name
  """
  pincode

  """
  column name
  """
  state

  """
  column name
  """
  vidhansabha
}

"""
input type for updating data in table "address"
"""
input address_set_input {
  basic_address: String

  created_at: timestamptz

  district: String

  id: String

  latitude: float8

  longitude: float8

  pincode: String

  state: String

  vidhansabha: String
}

"""
aggregate stddev on columns
"""
type address_stddev_fields {
  latitude: Float

  longitude: Float
}

"""
aggregate stddev_pop on columns
"""
type address_stddev_pop_fields {
  latitude: Float

  longitude: Float
}

"""
aggregate stddev_samp on columns
"""
type address_stddev_samp_fields {
  latitude: Float

  longitude: Float
}

"""
Streaming cursor of the table "address"
"""
input address_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: address_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input address_stream_cursor_value_input {
  basic_address: String

  created_at: timestamptz

  district: String

  id: String

  latitude: float8

  longitude: float8

  pincode: String

  state: String

  vidhansabha: String
}

"""
aggregate sum on columns
"""
type address_sum_fields {
  latitude: float8

  longitude: float8
}

"""
update columns of table "address"
"""
enum address_update_column {
  """
  column name
  """
  basic_address

  """
  column name
  """
  created_at

  """
  column name
  """
  district

  """
  column name
  """
  id

  """
  column name
  """
  latitude

  """
  column name
  """
  longitude

  """
  column name
  """
  pincode

  """
  column name
  """
  state

  """
  column name
  """
  vidhansabha
}

input address_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: address_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: address_set_input

  """
  filter the rows which have to be updated
  """
  where: address_bool_exp!
}

"""
aggregate var_pop on columns
"""
type address_var_pop_fields {
  latitude: Float

  longitude: Float
}

"""
aggregate var_samp on columns
"""
type address_var_samp_fields {
  latitude: Float

  longitude: Float
}

"""
aggregate variance on columns
"""
type address_variance_fields {
  latitude: Float

  longitude: Float
}

"""
columns and relationships of "admission"
"""
type admission {
  aadharno: String

  alternatemobileno: String

  attacheddocuments: [String!]

  bloodgroup: String

  dob: String

  fathername: String

  fatheroccupation: String

  fatherqualification: String

  fulladdress: String

  id: String!

  marksobtained: String

  mobileno: String

  mothername: String

  motheroccupation: String

  motherqualification: String

  parentsignature: String

  previousclass: String

  schoolname: String

  studentname: String

  studentphoto: String

  studentsignature: String
}

"""
aggregated selection of "admission"
"""
type admission_aggregate {
  aggregate: admission_aggregate_fields

  nodes: [admission!]!
}

"""
aggregate fields of "admission"
"""
type admission_aggregate_fields {
  count(columns: [admission_select_column!], distinct: Boolean): Int!

  max: admission_max_fields

  min: admission_min_fields
}

"""
Boolean expression to filter rows from the table "admission". All fields are combined with a logical 'AND'.
"""
input admission_bool_exp {
  _and: [admission_bool_exp!]

  _not: admission_bool_exp

  _or: [admission_bool_exp!]

  aadharno: String_comparison_exp

  alternatemobileno: String_comparison_exp

  attacheddocuments: String_array_comparison_exp

  bloodgroup: String_comparison_exp

  dob: String_comparison_exp

  fathername: String_comparison_exp

  fatheroccupation: String_comparison_exp

  fatherqualification: String_comparison_exp

  fulladdress: String_comparison_exp

  id: String_comparison_exp

  marksobtained: String_comparison_exp

  mobileno: String_comparison_exp

  mothername: String_comparison_exp

  motheroccupation: String_comparison_exp

  motherqualification: String_comparison_exp

  parentsignature: String_comparison_exp

  previousclass: String_comparison_exp

  schoolname: String_comparison_exp

  studentname: String_comparison_exp

  studentphoto: String_comparison_exp

  studentsignature: String_comparison_exp
}

"""
unique or primary key constraints on table "admission"
"""
enum admission_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  admission_pkey
}

"""
input type for inserting data into table "admission"
"""
input admission_insert_input {
  aadharno: String

  alternatemobileno: String

  attacheddocuments: [String!]

  bloodgroup: String

  dob: String

  fathername: String

  fatheroccupation: String

  fatherqualification: String

  fulladdress: String

  id: String

  marksobtained: String

  mobileno: String

  mothername: String

  motheroccupation: String

  motherqualification: String

  parentsignature: String

  previousclass: String

  schoolname: String

  studentname: String

  studentphoto: String

  studentsignature: String
}

"""
aggregate max on columns
"""
type admission_max_fields {
  aadharno: String

  alternatemobileno: String

  attacheddocuments: [String!]

  bloodgroup: String

  dob: String

  fathername: String

  fatheroccupation: String

  fatherqualification: String

  fulladdress: String

  id: String

  marksobtained: String

  mobileno: String

  mothername: String

  motheroccupation: String

  motherqualification: String

  parentsignature: String

  previousclass: String

  schoolname: String

  studentname: String

  studentphoto: String

  studentsignature: String
}

"""
aggregate min on columns
"""
type admission_min_fields {
  aadharno: String

  alternatemobileno: String

  attacheddocuments: [String!]

  bloodgroup: String

  dob: String

  fathername: String

  fatheroccupation: String

  fatherqualification: String

  fulladdress: String

  id: String

  marksobtained: String

  mobileno: String

  mothername: String

  motheroccupation: String

  motherqualification: String

  parentsignature: String

  previousclass: String

  schoolname: String

  studentname: String

  studentphoto: String

  studentsignature: String
}

"""
response of any mutation on the table "admission"
"""
type admission_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [admission!]!
}

"""
on_conflict condition type for table "admission"
"""
input admission_on_conflict {
  constraint: admission_constraint!

  update_columns: [admission_update_column!]! = []

  where: admission_bool_exp
}

"""
Ordering options when selecting data from "admission".
"""
input admission_order_by {
  aadharno: order_by

  alternatemobileno: order_by

  attacheddocuments: order_by

  bloodgroup: order_by

  dob: order_by

  fathername: order_by

  fatheroccupation: order_by

  fatherqualification: order_by

  fulladdress: order_by

  id: order_by

  marksobtained: order_by

  mobileno: order_by

  mothername: order_by

  motheroccupation: order_by

  motherqualification: order_by

  parentsignature: order_by

  previousclass: order_by

  schoolname: order_by

  studentname: order_by

  studentphoto: order_by

  studentsignature: order_by
}

"""
primary key columns input for table: admission
"""
input admission_pk_columns_input {
  id: String!
}

"""
select columns of table "admission"
"""
enum admission_select_column {
  """
  column name
  """
  aadharno

  """
  column name
  """
  alternatemobileno

  """
  column name
  """
  attacheddocuments

  """
  column name
  """
  bloodgroup

  """
  column name
  """
  dob

  """
  column name
  """
  fathername

  """
  column name
  """
  fatheroccupation

  """
  column name
  """
  fatherqualification

  """
  column name
  """
  fulladdress

  """
  column name
  """
  id

  """
  column name
  """
  marksobtained

  """
  column name
  """
  mobileno

  """
  column name
  """
  mothername

  """
  column name
  """
  motheroccupation

  """
  column name
  """
  motherqualification

  """
  column name
  """
  parentsignature

  """
  column name
  """
  previousclass

  """
  column name
  """
  schoolname

  """
  column name
  """
  studentname

  """
  column name
  """
  studentphoto

  """
  column name
  """
  studentsignature
}

"""
input type for updating data in table "admission"
"""
input admission_set_input {
  aadharno: String

  alternatemobileno: String

  attacheddocuments: [String!]

  bloodgroup: String

  dob: String

  fathername: String

  fatheroccupation: String

  fatherqualification: String

  fulladdress: String

  id: String

  marksobtained: String

  mobileno: String

  mothername: String

  motheroccupation: String

  motherqualification: String

  parentsignature: String

  previousclass: String

  schoolname: String

  studentname: String

  studentphoto: String

  studentsignature: String
}

"""
Streaming cursor of the table "admission"
"""
input admission_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: admission_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input admission_stream_cursor_value_input {
  aadharno: String

  alternatemobileno: String

  attacheddocuments: [String!]

  bloodgroup: String

  dob: String

  fathername: String

  fatheroccupation: String

  fatherqualification: String

  fulladdress: String

  id: String

  marksobtained: String

  mobileno: String

  mothername: String

  motheroccupation: String

  motherqualification: String

  parentsignature: String

  previousclass: String

  schoolname: String

  studentname: String

  studentphoto: String

  studentsignature: String
}

"""
update columns of table "admission"
"""
enum admission_update_column {
  """
  column name
  """
  aadharno

  """
  column name
  """
  alternatemobileno

  """
  column name
  """
  attacheddocuments

  """
  column name
  """
  bloodgroup

  """
  column name
  """
  dob

  """
  column name
  """
  fathername

  """
  column name
  """
  fatheroccupation

  """
  column name
  """
  fatherqualification

  """
  column name
  """
  fulladdress

  """
  column name
  """
  id

  """
  column name
  """
  marksobtained

  """
  column name
  """
  mobileno

  """
  column name
  """
  mothername

  """
  column name
  """
  motheroccupation

  """
  column name
  """
  motherqualification

  """
  column name
  """
  parentsignature

  """
  column name
  """
  previousclass

  """
  column name
  """
  schoolname

  """
  column name
  """
  studentname

  """
  column name
  """
  studentphoto

  """
  column name
  """
  studentsignature
}

input admission_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: admission_set_input

  """
  filter the rows which have to be updated
  """
  where: admission_bool_exp!
}

"""
columns and relationships of "app_labels"
"""
type app_labels {
  created_at: timestamptz!

  id: uuid!

  label_key: String

  label_value: String
}

"""
aggregated selection of "app_labels"
"""
type app_labels_aggregate {
  aggregate: app_labels_aggregate_fields

  nodes: [app_labels!]!
}

"""
aggregate fields of "app_labels"
"""
type app_labels_aggregate_fields {
  count(columns: [app_labels_select_column!], distinct: Boolean): Int!

  max: app_labels_max_fields

  min: app_labels_min_fields
}

"""
Boolean expression to filter rows from the table "app_labels". All fields are combined with a logical 'AND'.
"""
input app_labels_bool_exp {
  _and: [app_labels_bool_exp!]

  _not: app_labels_bool_exp

  _or: [app_labels_bool_exp!]

  created_at: timestamptz_comparison_exp

  id: uuid_comparison_exp

  label_key: String_comparison_exp

  label_value: String_comparison_exp
}

"""
unique or primary key constraints on table "app_labels"
"""
enum app_labels_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  app_labels_pkey
}

"""
input type for inserting data into table "app_labels"
"""
input app_labels_insert_input {
  created_at: timestamptz

  id: uuid

  label_key: String

  label_value: String
}

"""
aggregate max on columns
"""
type app_labels_max_fields {
  created_at: timestamptz

  id: uuid

  label_key: String

  label_value: String
}

"""
aggregate min on columns
"""
type app_labels_min_fields {
  created_at: timestamptz

  id: uuid

  label_key: String

  label_value: String
}

"""
response of any mutation on the table "app_labels"
"""
type app_labels_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [app_labels!]!
}

"""
on_conflict condition type for table "app_labels"
"""
input app_labels_on_conflict {
  constraint: app_labels_constraint!

  update_columns: [app_labels_update_column!]! = []

  where: app_labels_bool_exp
}

"""
Ordering options when selecting data from "app_labels".
"""
input app_labels_order_by {
  created_at: order_by

  id: order_by

  label_key: order_by

  label_value: order_by
}

"""
primary key columns input for table: app_labels
"""
input app_labels_pk_columns_input {
  id: uuid!
}

"""
select columns of table "app_labels"
"""
enum app_labels_select_column {
  """
  column name
  """
  created_at

  """
  column name
  """
  id

  """
  column name
  """
  label_key

  """
  column name
  """
  label_value
}

"""
input type for updating data in table "app_labels"
"""
input app_labels_set_input {
  created_at: timestamptz

  id: uuid

  label_key: String

  label_value: String
}

"""
Streaming cursor of the table "app_labels"
"""
input app_labels_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: app_labels_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input app_labels_stream_cursor_value_input {
  created_at: timestamptz

  id: uuid

  label_key: String

  label_value: String
}

"""
update columns of table "app_labels"
"""
enum app_labels_update_column {
  """
  column name
  """
  created_at

  """
  column name
  """
  id

  """
  column name
  """
  label_key

  """
  column name
  """
  label_value
}

input app_labels_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: app_labels_set_input

  """
  filter the rows which have to be updated
  """
  where: app_labels_bool_exp!
}

"""
columns and relationships of "arya_samaj"
"""
type arya_samaj {
  """
  An object relationship
  """
  address: address

  address_id: String

  created_at: timestamptz!

  description: String!

  """
  An array relationship
  """
  families("distinct select on columns" distinct_on: [family_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [family_order_by!], "filter the rows returned" where: family_bool_exp): [family!]!

  """
  An aggregate relationship
  """
  families_aggregate("distinct select on columns" distinct_on: [family_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [family_order_by!], "filter the rows returned" where: family_bool_exp): family_aggregate!

  id: String!

  media_urls: [String!]!

  """
  An array relationship
  """
  members("distinct select on columns" distinct_on: [member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [member_order_by!], "filter the rows returned" where: member_bool_exp): [member!]!

  """
  An aggregate relationship
  """
  members_aggregate("distinct select on columns" distinct_on: [member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [member_order_by!], "filter the rows returned" where: member_bool_exp): member_aggregate!

  name: String!

  """
  An array relationship
  """
  samaj_members("distinct select on columns" distinct_on: [samaj_member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [samaj_member_order_by!], "filter the rows returned" where: samaj_member_bool_exp): [samaj_member!]!

  """
  An aggregate relationship
  """
  samaj_members_aggregate("distinct select on columns" distinct_on: [samaj_member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [samaj_member_order_by!], "filter the rows returned" where: samaj_member_bool_exp): samaj_member_aggregate!
}

"""
aggregated selection of "arya_samaj"
"""
type arya_samaj_aggregate {
  aggregate: arya_samaj_aggregate_fields

  nodes: [arya_samaj!]!
}

input arya_samaj_aggregate_bool_exp {
  count: arya_samaj_aggregate_bool_exp_count
}

input arya_samaj_aggregate_bool_exp_count {
  arguments: [arya_samaj_select_column!]

  distinct: Boolean

  filter: arya_samaj_bool_exp

  predicate: Int_comparison_exp!
}

"""
aggregate fields of "arya_samaj"
"""
type arya_samaj_aggregate_fields {
  count(columns: [arya_samaj_select_column!], distinct: Boolean): Int!

  max: arya_samaj_max_fields

  min: arya_samaj_min_fields
}

"""
order by aggregate values of table "arya_samaj"
"""
input arya_samaj_aggregate_order_by {
  count: order_by

  max: arya_samaj_max_order_by

  min: arya_samaj_min_order_by
}

"""
input type for inserting array relation for remote table "arya_samaj"
"""
input arya_samaj_arr_rel_insert_input {
  data: [arya_samaj_insert_input!]!

  """
  upsert condition
  """
  on_conflict: arya_samaj_on_conflict
}

"""
Boolean expression to filter rows from the table "arya_samaj". All fields are combined with a logical 'AND'.
"""
input arya_samaj_bool_exp {
  _and: [arya_samaj_bool_exp!]

  _not: arya_samaj_bool_exp

  _or: [arya_samaj_bool_exp!]

  address: address_bool_exp

  address_id: String_comparison_exp

  created_at: timestamptz_comparison_exp

  description: String_comparison_exp

  families: family_bool_exp

  families_aggregate: family_aggregate_bool_exp

  id: String_comparison_exp

  media_urls: String_array_comparison_exp

  members: member_bool_exp

  members_aggregate: member_aggregate_bool_exp

  name: String_comparison_exp

  samaj_members: samaj_member_bool_exp

  samaj_members_aggregate: samaj_member_aggregate_bool_exp
}

"""
unique or primary key constraints on table "arya_samaj"
"""
enum arya_samaj_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  arya_samaj_pkey
}

"""
input type for inserting data into table "arya_samaj"
"""
input arya_samaj_insert_input {
  address: address_obj_rel_insert_input

  address_id: String

  created_at: timestamptz

  description: String

  families: family_arr_rel_insert_input

  id: String

  media_urls: [String!]

  members: member_arr_rel_insert_input

  name: String

  samaj_members: samaj_member_arr_rel_insert_input
}

"""
aggregate max on columns
"""
type arya_samaj_max_fields {
  address_id: String

  created_at: timestamptz

  description: String

  id: String

  media_urls: [String!]

  name: String
}

"""
order by max() on columns of table "arya_samaj"
"""
input arya_samaj_max_order_by {
  address_id: order_by

  created_at: order_by

  description: order_by

  id: order_by

  media_urls: order_by

  name: order_by
}

"""
aggregate min on columns
"""
type arya_samaj_min_fields {
  address_id: String

  created_at: timestamptz

  description: String

  id: String

  media_urls: [String!]

  name: String
}

"""
order by min() on columns of table "arya_samaj"
"""
input arya_samaj_min_order_by {
  address_id: order_by

  created_at: order_by

  description: order_by

  id: order_by

  media_urls: order_by

  name: order_by
}

"""
response of any mutation on the table "arya_samaj"
"""
type arya_samaj_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [arya_samaj!]!
}

"""
input type for inserting object relation for remote table "arya_samaj"
"""
input arya_samaj_obj_rel_insert_input {
  data: arya_samaj_insert_input!

  """
  upsert condition
  """
  on_conflict: arya_samaj_on_conflict
}

"""
on_conflict condition type for table "arya_samaj"
"""
input arya_samaj_on_conflict {
  constraint: arya_samaj_constraint!

  update_columns: [arya_samaj_update_column!]! = []

  where: arya_samaj_bool_exp
}

"""
Ordering options when selecting data from "arya_samaj".
"""
input arya_samaj_order_by {
  address: address_order_by

  address_id: order_by

  created_at: order_by

  description: order_by

  families_aggregate: family_aggregate_order_by

  id: order_by

  media_urls: order_by

  members_aggregate: member_aggregate_order_by

  name: order_by

  samaj_members_aggregate: samaj_member_aggregate_order_by
}

"""
primary key columns input for table: arya_samaj
"""
input arya_samaj_pk_columns_input {
  id: String!
}

"""
select columns of table "arya_samaj"
"""
enum arya_samaj_select_column {
  """
  column name
  """
  address_id

  """
  column name
  """
  created_at

  """
  column name
  """
  description

  """
  column name
  """
  id

  """
  column name
  """
  media_urls

  """
  column name
  """
  name
}

"""
input type for updating data in table "arya_samaj"
"""
input arya_samaj_set_input {
  address_id: String

  created_at: timestamptz

  description: String

  id: String

  media_urls: [String!]

  name: String
}

"""
Streaming cursor of the table "arya_samaj"
"""
input arya_samaj_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: arya_samaj_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input arya_samaj_stream_cursor_value_input {
  address_id: String

  created_at: timestamptz

  description: String

  id: String

  media_urls: [String!]

  name: String
}

"""
update columns of table "arya_samaj"
"""
enum arya_samaj_update_column {
  """
  column name
  """
  address_id

  """
  column name
  """
  created_at

  """
  column name
  """
  description

  """
  column name
  """
  id

  """
  column name
  """
  media_urls

  """
  column name
  """
  name
}

input arya_samaj_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: arya_samaj_set_input

  """
  filter the rows which have to be updated
  """
  where: arya_samaj_bool_exp!
}

"""
columns and relationships of "arya_samaj_with_address"
"""
type arya_samaj_with_address {
  basic_address: String

  created_at: timestamptz

  description: String

  district: String

  id: String

  latitude: float8

  longitude: float8

  media_urls: [String!]

  name: String

  pincode: String

  state: String

  vidhansabha: String
}

"""
aggregated selection of "arya_samaj_with_address"
"""
type arya_samaj_with_address_aggregate {
  aggregate: arya_samaj_with_address_aggregate_fields

  nodes: [arya_samaj_with_address!]!
}

"""
aggregate fields of "arya_samaj_with_address"
"""
type arya_samaj_with_address_aggregate_fields {
  avg: arya_samaj_with_address_avg_fields

  count(columns: [arya_samaj_with_address_select_column!], distinct: Boolean): Int!

  max: arya_samaj_with_address_max_fields

  min: arya_samaj_with_address_min_fields

  stddev: arya_samaj_with_address_stddev_fields

  stddev_pop: arya_samaj_with_address_stddev_pop_fields

  stddev_samp: arya_samaj_with_address_stddev_samp_fields

  sum: arya_samaj_with_address_sum_fields

  var_pop: arya_samaj_with_address_var_pop_fields

  var_samp: arya_samaj_with_address_var_samp_fields

  variance: arya_samaj_with_address_variance_fields
}

"""
aggregate avg on columns
"""
type arya_samaj_with_address_avg_fields {
  latitude: Float

  longitude: Float
}

"""
Boolean expression to filter rows from the table "arya_samaj_with_address". All fields are combined with a logical 'AND'.
"""
input arya_samaj_with_address_bool_exp {
  _and: [arya_samaj_with_address_bool_exp!]

  _not: arya_samaj_with_address_bool_exp

  _or: [arya_samaj_with_address_bool_exp!]

  basic_address: String_comparison_exp

  created_at: timestamptz_comparison_exp

  description: String_comparison_exp

  district: String_comparison_exp

  id: String_comparison_exp

  latitude: float8_comparison_exp

  longitude: float8_comparison_exp

  media_urls: String_array_comparison_exp

  name: String_comparison_exp

  pincode: String_comparison_exp

  state: String_comparison_exp

  vidhansabha: String_comparison_exp
}

"""
aggregate max on columns
"""
type arya_samaj_with_address_max_fields {
  basic_address: String

  created_at: timestamptz

  description: String

  district: String

  id: String

  latitude: float8

  longitude: float8

  media_urls: [String!]

  name: String

  pincode: String

  state: String

  vidhansabha: String
}

"""
aggregate min on columns
"""
type arya_samaj_with_address_min_fields {
  basic_address: String

  created_at: timestamptz

  description: String

  district: String

  id: String

  latitude: float8

  longitude: float8

  media_urls: [String!]

  name: String

  pincode: String

  state: String

  vidhansabha: String
}

"""
Ordering options when selecting data from "arya_samaj_with_address".
"""
input arya_samaj_with_address_order_by {
  basic_address: order_by

  created_at: order_by

  description: order_by

  district: order_by

  id: order_by

  latitude: order_by

  longitude: order_by

  media_urls: order_by

  name: order_by

  pincode: order_by

  state: order_by

  vidhansabha: order_by
}

"""
select columns of table "arya_samaj_with_address"
"""
enum arya_samaj_with_address_select_column {
  """
  column name
  """
  basic_address

  """
  column name
  """
  created_at

  """
  column name
  """
  description

  """
  column name
  """
  district

  """
  column name
  """
  id

  """
  column name
  """
  latitude

  """
  column name
  """
  longitude

  """
  column name
  """
  media_urls

  """
  column name
  """
  name

  """
  column name
  """
  pincode

  """
  column name
  """
  state

  """
  column name
  """
  vidhansabha
}

"""
aggregate stddev on columns
"""
type arya_samaj_with_address_stddev_fields {
  latitude: Float

  longitude: Float
}

"""
aggregate stddev_pop on columns
"""
type arya_samaj_with_address_stddev_pop_fields {
  latitude: Float

  longitude: Float
}

"""
aggregate stddev_samp on columns
"""
type arya_samaj_with_address_stddev_samp_fields {
  latitude: Float

  longitude: Float
}

"""
Streaming cursor of the table "arya_samaj_with_address"
"""
input arya_samaj_with_address_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: arya_samaj_with_address_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input arya_samaj_with_address_stream_cursor_value_input {
  basic_address: String

  created_at: timestamptz

  description: String

  district: String

  id: String

  latitude: float8

  longitude: float8

  media_urls: [String!]

  name: String

  pincode: String

  state: String

  vidhansabha: String
}

"""
aggregate sum on columns
"""
type arya_samaj_with_address_sum_fields {
  latitude: float8

  longitude: float8
}

"""
aggregate var_pop on columns
"""
type arya_samaj_with_address_var_pop_fields {
  latitude: Float

  longitude: Float
}

"""
aggregate var_samp on columns
"""
type arya_samaj_with_address_var_samp_fields {
  latitude: Float

  longitude: Float
}

"""
aggregate variance on columns
"""
type arya_samaj_with_address_variance_fields {
  latitude: Float

  longitude: Float
}

"""
columns and relationships of "book_orders"
"""
type book_orders {
  address: String

  city: String

  country: String

  created_at: timestamptz

  district: String

  district_officer_name: String

  district_officer_number: String

  fullname: String!

  id: uuid!

  is_fulfilled: Boolean

  mobile: String

  payment_receipt_url: String

  pincode: String

  state: String
}

"""
aggregated selection of "book_orders"
"""
type book_orders_aggregate {
  aggregate: book_orders_aggregate_fields

  nodes: [book_orders!]!
}

"""
aggregate fields of "book_orders"
"""
type book_orders_aggregate_fields {
  count(columns: [book_orders_select_column!], distinct: Boolean): Int!

  max: book_orders_max_fields

  min: book_orders_min_fields
}

"""
Boolean expression to filter rows from the table "book_orders". All fields are combined with a logical 'AND'.
"""
input book_orders_bool_exp {
  _and: [book_orders_bool_exp!]

  _not: book_orders_bool_exp

  _or: [book_orders_bool_exp!]

  address: String_comparison_exp

  city: String_comparison_exp

  country: String_comparison_exp

  created_at: timestamptz_comparison_exp

  district: String_comparison_exp

  district_officer_name: String_comparison_exp

  district_officer_number: String_comparison_exp

  fullname: String_comparison_exp

  id: uuid_comparison_exp

  is_fulfilled: Boolean_comparison_exp

  mobile: String_comparison_exp

  payment_receipt_url: String_comparison_exp

  pincode: String_comparison_exp

  state: String_comparison_exp
}

"""
unique or primary key constraints on table "book_orders"
"""
enum book_orders_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  book_orders_pkey
}

"""
input type for inserting data into table "book_orders"
"""
input book_orders_insert_input {
  address: String

  city: String

  country: String

  created_at: timestamptz

  district: String

  district_officer_name: String

  district_officer_number: String

  fullname: String

  id: uuid

  is_fulfilled: Boolean

  mobile: String

  payment_receipt_url: String

  pincode: String

  state: String
}

"""
aggregate max on columns
"""
type book_orders_max_fields {
  address: String

  city: String

  country: String

  created_at: timestamptz

  district: String

  district_officer_name: String

  district_officer_number: String

  fullname: String

  id: uuid

  mobile: String

  payment_receipt_url: String

  pincode: String

  state: String
}

"""
aggregate min on columns
"""
type book_orders_min_fields {
  address: String

  city: String

  country: String

  created_at: timestamptz

  district: String

  district_officer_name: String

  district_officer_number: String

  fullname: String

  id: uuid

  mobile: String

  payment_receipt_url: String

  pincode: String

  state: String
}

"""
response of any mutation on the table "book_orders"
"""
type book_orders_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [book_orders!]!
}

"""
on_conflict condition type for table "book_orders"
"""
input book_orders_on_conflict {
  constraint: book_orders_constraint!

  update_columns: [book_orders_update_column!]! = []

  where: book_orders_bool_exp
}

"""
Ordering options when selecting data from "book_orders".
"""
input book_orders_order_by {
  address: order_by

  city: order_by

  country: order_by

  created_at: order_by

  district: order_by

  district_officer_name: order_by

  district_officer_number: order_by

  fullname: order_by

  id: order_by

  is_fulfilled: order_by

  mobile: order_by

  payment_receipt_url: order_by

  pincode: order_by

  state: order_by
}

"""
primary key columns input for table: book_orders
"""
input book_orders_pk_columns_input {
  id: uuid!
}

"""
select columns of table "book_orders"
"""
enum book_orders_select_column {
  """
  column name
  """
  address

  """
  column name
  """
  city

  """
  column name
  """
  country

  """
  column name
  """
  created_at

  """
  column name
  """
  district

  """
  column name
  """
  district_officer_name

  """
  column name
  """
  district_officer_number

  """
  column name
  """
  fullname

  """
  column name
  """
  id

  """
  column name
  """
  is_fulfilled

  """
  column name
  """
  mobile

  """
  column name
  """
  payment_receipt_url

  """
  column name
  """
  pincode

  """
  column name
  """
  state
}

"""
input type for updating data in table "book_orders"
"""
input book_orders_set_input {
  address: String

  city: String

  country: String

  created_at: timestamptz

  district: String

  district_officer_name: String

  district_officer_number: String

  fullname: String

  id: uuid

  is_fulfilled: Boolean

  mobile: String

  payment_receipt_url: String

  pincode: String

  state: String
}

"""
Streaming cursor of the table "book_orders"
"""
input book_orders_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: book_orders_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input book_orders_stream_cursor_value_input {
  address: String

  city: String

  country: String

  created_at: timestamptz

  district: String

  district_officer_name: String

  district_officer_number: String

  fullname: String

  id: uuid

  is_fulfilled: Boolean

  mobile: String

  payment_receipt_url: String

  pincode: String

  state: String
}

"""
update columns of table "book_orders"
"""
enum book_orders_update_column {
  """
  column name
  """
  address

  """
  column name
  """
  city

  """
  column name
  """
  country

  """
  column name
  """
  created_at

  """
  column name
  """
  district

  """
  column name
  """
  district_officer_name

  """
  column name
  """
  district_officer_number

  """
  column name
  """
  fullname

  """
  column name
  """
  id

  """
  column name
  """
  is_fulfilled

  """
  column name
  """
  mobile

  """
  column name
  """
  payment_receipt_url

  """
  column name
  """
  pincode

  """
  column name
  """
  state
}

input book_orders_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: book_orders_set_input

  """
  filter the rows which have to be updated
  """
  where: book_orders_bool_exp!
}

"""
columns and relationships of "course_registrations"
"""
type course_registrations {
  """
  An object relationship
  """
  activity: activities

  activity_id: String

  created_at: timestamptz!

  id: String!

  name: String

  payment_receipt_url: String

  recommendation: String

  satr_date: date

  satr_place: String
}

"""
aggregated selection of "course_registrations"
"""
type course_registrations_aggregate {
  aggregate: course_registrations_aggregate_fields

  nodes: [course_registrations!]!
}

input course_registrations_aggregate_bool_exp {
  count: course_registrations_aggregate_bool_exp_count
}

input course_registrations_aggregate_bool_exp_count {
  arguments: [course_registrations_select_column!]

  distinct: Boolean

  filter: course_registrations_bool_exp

  predicate: Int_comparison_exp!
}

"""
aggregate fields of "course_registrations"
"""
type course_registrations_aggregate_fields {
  count(columns: [course_registrations_select_column!], distinct: Boolean): Int!

  max: course_registrations_max_fields

  min: course_registrations_min_fields
}

"""
order by aggregate values of table "course_registrations"
"""
input course_registrations_aggregate_order_by {
  count: order_by

  max: course_registrations_max_order_by

  min: course_registrations_min_order_by
}

"""
input type for inserting array relation for remote table "course_registrations"
"""
input course_registrations_arr_rel_insert_input {
  data: [course_registrations_insert_input!]!

  """
  upsert condition
  """
  on_conflict: course_registrations_on_conflict
}

"""
Boolean expression to filter rows from the table "course_registrations". All fields are combined with a logical 'AND'.
"""
input course_registrations_bool_exp {
  _and: [course_registrations_bool_exp!]

  _not: course_registrations_bool_exp

  _or: [course_registrations_bool_exp!]

  activity: activities_bool_exp

  activity_id: String_comparison_exp

  created_at: timestamptz_comparison_exp

  id: String_comparison_exp

  name: String_comparison_exp

  payment_receipt_url: String_comparison_exp

  recommendation: String_comparison_exp

  satr_date: date_comparison_exp

  satr_place: String_comparison_exp
}

"""
unique or primary key constraints on table "course_registrations"
"""
enum course_registrations_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  course_registrations_pkey
}

"""
input type for inserting data into table "course_registrations"
"""
input course_registrations_insert_input {
  activity: activities_obj_rel_insert_input

  activity_id: String

  created_at: timestamptz

  id: String

  name: String

  payment_receipt_url: String

  recommendation: String

  satr_date: date

  satr_place: String
}

"""
aggregate max on columns
"""
type course_registrations_max_fields {
  activity_id: String

  created_at: timestamptz

  id: String

  name: String

  payment_receipt_url: String

  recommendation: String

  satr_date: date

  satr_place: String
}

"""
order by max() on columns of table "course_registrations"
"""
input course_registrations_max_order_by {
  activity_id: order_by

  created_at: order_by

  id: order_by

  name: order_by

  payment_receipt_url: order_by

  recommendation: order_by

  satr_date: order_by

  satr_place: order_by
}

"""
aggregate min on columns
"""
type course_registrations_min_fields {
  activity_id: String

  created_at: timestamptz

  id: String

  name: String

  payment_receipt_url: String

  recommendation: String

  satr_date: date

  satr_place: String
}

"""
order by min() on columns of table "course_registrations"
"""
input course_registrations_min_order_by {
  activity_id: order_by

  created_at: order_by

  id: order_by

  name: order_by

  payment_receipt_url: order_by

  recommendation: order_by

  satr_date: order_by

  satr_place: order_by
}

"""
response of any mutation on the table "course_registrations"
"""
type course_registrations_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [course_registrations!]!
}

"""
on_conflict condition type for table "course_registrations"
"""
input course_registrations_on_conflict {
  constraint: course_registrations_constraint!

  update_columns: [course_registrations_update_column!]! = []

  where: course_registrations_bool_exp
}

"""
Ordering options when selecting data from "course_registrations".
"""
input course_registrations_order_by {
  activity: activities_order_by

  activity_id: order_by

  created_at: order_by

  id: order_by

  name: order_by

  payment_receipt_url: order_by

  recommendation: order_by

  satr_date: order_by

  satr_place: order_by
}

"""
primary key columns input for table: course_registrations
"""
input course_registrations_pk_columns_input {
  id: String!
}

"""
select columns of table "course_registrations"
"""
enum course_registrations_select_column {
  """
  column name
  """
  activity_id

  """
  column name
  """
  created_at

  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  payment_receipt_url

  """
  column name
  """
  recommendation

  """
  column name
  """
  satr_date

  """
  column name
  """
  satr_place
}

"""
input type for updating data in table "course_registrations"
"""
input course_registrations_set_input {
  activity_id: String

  created_at: timestamptz

  id: String

  name: String

  payment_receipt_url: String

  recommendation: String

  satr_date: date

  satr_place: String
}

"""
Streaming cursor of the table "course_registrations"
"""
input course_registrations_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: course_registrations_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input course_registrations_stream_cursor_value_input {
  activity_id: String

  created_at: timestamptz

  id: String

  name: String

  payment_receipt_url: String

  recommendation: String

  satr_date: date

  satr_place: String
}

"""
update columns of table "course_registrations"
"""
enum course_registrations_update_column {
  """
  column name
  """
  activity_id

  """
  column name
  """
  created_at

  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  payment_receipt_url

  """
  column name
  """
  recommendation

  """
  column name
  """
  satr_date

  """
  column name
  """
  satr_place
}

input course_registrations_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: course_registrations_set_input

  """
  filter the rows which have to be updated
  """
  where: course_registrations_bool_exp!
}

"""
ordering argument of a cursor
"""
enum cursor_ordering {
  """
  ascending ordering of the cursor
  """
  ASC

  """
  descending ordering of the cursor
  """
  DESC
}

scalar date

"""
Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'.
"""
input date_comparison_exp {
  _eq: date

  _gt: date

  _gte: date

  _in: [date!]

  _is_null: Boolean

  _lt: date

  _lte: date

  _neq: date

  _nin: [date!]
}

"""
columns and relationships of "family"
"""
type family {
  """
  An object relationship
  """
  address: address

  address_id: String

  """
  An object relationship
  """
  arya_samaj: arya_samaj

  arya_samaj_id: String

  created_at: timestamptz!

  """
  An array relationship
  """
  family_members("distinct select on columns" distinct_on: [family_member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [family_member_order_by!], "filter the rows returned" where: family_member_bool_exp): [family_member!]!

  """
  An aggregate relationship
  """
  family_members_aggregate("distinct select on columns" distinct_on: [family_member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [family_member_order_by!], "filter the rows returned" where: family_member_bool_exp): family_member_aggregate!

  id: String!

  name: String

  photos: [String!]

  updated_at: timestamptz
}

"""
aggregated selection of "family"
"""
type family_aggregate {
  aggregate: family_aggregate_fields

  nodes: [family!]!
}

input family_aggregate_bool_exp {
  count: family_aggregate_bool_exp_count
}

input family_aggregate_bool_exp_count {
  arguments: [family_select_column!]

  distinct: Boolean

  filter: family_bool_exp

  predicate: Int_comparison_exp!
}

"""
aggregate fields of "family"
"""
type family_aggregate_fields {
  count(columns: [family_select_column!], distinct: Boolean): Int!

  max: family_max_fields

  min: family_min_fields
}

"""
order by aggregate values of table "family"
"""
input family_aggregate_order_by {
  count: order_by

  max: family_max_order_by

  min: family_min_order_by
}

"""
input type for inserting array relation for remote table "family"
"""
input family_arr_rel_insert_input {
  data: [family_insert_input!]!

  """
  upsert condition
  """
  on_conflict: family_on_conflict
}

"""
Boolean expression to filter rows from the table "family". All fields are combined with a logical 'AND'.
"""
input family_bool_exp {
  _and: [family_bool_exp!]

  _not: family_bool_exp

  _or: [family_bool_exp!]

  address: address_bool_exp

  address_id: String_comparison_exp

  arya_samaj: arya_samaj_bool_exp

  arya_samaj_id: String_comparison_exp

  created_at: timestamptz_comparison_exp

  family_members: family_member_bool_exp

  family_members_aggregate: family_member_aggregate_bool_exp

  id: String_comparison_exp

  name: String_comparison_exp

  photos: String_array_comparison_exp

  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "family"
"""
enum family_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  family_pkey
}

"""
input type for inserting data into table "family"
"""
input family_insert_input {
  address: address_obj_rel_insert_input

  address_id: String

  arya_samaj: arya_samaj_obj_rel_insert_input

  arya_samaj_id: String

  created_at: timestamptz

  family_members: family_member_arr_rel_insert_input

  id: String

  name: String

  photos: [String!]

  updated_at: timestamptz
}

"""
aggregate max on columns
"""
type family_max_fields {
  address_id: String

  arya_samaj_id: String

  created_at: timestamptz

  id: String

  name: String

  photos: [String!]

  updated_at: timestamptz
}

"""
order by max() on columns of table "family"
"""
input family_max_order_by {
  address_id: order_by

  arya_samaj_id: order_by

  created_at: order_by

  id: order_by

  name: order_by

  photos: order_by

  updated_at: order_by
}

"""
columns and relationships of "family_member"
"""
type family_member {
  created_at: timestamptz!

  """
  An object relationship
  """
  family: family!

  family_id: String!

  """
  An object relationship
  """
  family_relation: family_relation

  id: String!

  is_head: Boolean!

  """
  An object relationship
  """
  member: member!

  member_id: String!

  relation_to_head: String
}

"""
aggregated selection of "family_member"
"""
type family_member_aggregate {
  aggregate: family_member_aggregate_fields

  nodes: [family_member!]!
}

input family_member_aggregate_bool_exp {
  bool_and: family_member_aggregate_bool_exp_bool_and

  bool_or: family_member_aggregate_bool_exp_bool_or

  count: family_member_aggregate_bool_exp_count
}

input family_member_aggregate_bool_exp_bool_and {
  arguments: family_member_select_column_family_member_aggregate_bool_exp_bool_and_arguments_columns!

  distinct: Boolean

  filter: family_member_bool_exp

  predicate: Boolean_comparison_exp!
}

input family_member_aggregate_bool_exp_bool_or {
  arguments: family_member_select_column_family_member_aggregate_bool_exp_bool_or_arguments_columns!

  distinct: Boolean

  filter: family_member_bool_exp

  predicate: Boolean_comparison_exp!
}

input family_member_aggregate_bool_exp_count {
  arguments: [family_member_select_column!]

  distinct: Boolean

  filter: family_member_bool_exp

  predicate: Int_comparison_exp!
}

"""
aggregate fields of "family_member"
"""
type family_member_aggregate_fields {
  count(columns: [family_member_select_column!], distinct: Boolean): Int!

  max: family_member_max_fields

  min: family_member_min_fields
}

"""
order by aggregate values of table "family_member"
"""
input family_member_aggregate_order_by {
  count: order_by

  max: family_member_max_order_by

  min: family_member_min_order_by
}

"""
input type for inserting array relation for remote table "family_member"
"""
input family_member_arr_rel_insert_input {
  data: [family_member_insert_input!]!

  """
  upsert condition
  """
  on_conflict: family_member_on_conflict
}

"""
Boolean expression to filter rows from the table "family_member". All fields are combined with a logical 'AND'.
"""
input family_member_bool_exp {
  _and: [family_member_bool_exp!]

  _not: family_member_bool_exp

  _or: [family_member_bool_exp!]

  created_at: timestamptz_comparison_exp

  family: family_bool_exp

  family_id: String_comparison_exp

  family_relation: family_relation_bool_exp

  id: String_comparison_exp

  is_head: Boolean_comparison_exp

  member: member_bool_exp

  member_id: String_comparison_exp

  relation_to_head: String_comparison_exp
}

"""
unique or primary key constraints on table "family_member"
"""
enum family_member_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  family_member_pkey
}

"""
input type for inserting data into table "family_member"
"""
input family_member_insert_input {
  created_at: timestamptz

  family: family_obj_rel_insert_input

  family_id: String

  family_relation: family_relation_obj_rel_insert_input

  id: String

  is_head: Boolean

  member: member_obj_rel_insert_input

  member_id: String

  relation_to_head: String
}

"""
aggregate max on columns
"""
type family_member_max_fields {
  created_at: timestamptz

  family_id: String

  id: String

  member_id: String

  relation_to_head: String
}

"""
order by max() on columns of table "family_member"
"""
input family_member_max_order_by {
  created_at: order_by

  family_id: order_by

  id: order_by

  member_id: order_by

  relation_to_head: order_by
}

"""
aggregate min on columns
"""
type family_member_min_fields {
  created_at: timestamptz

  family_id: String

  id: String

  member_id: String

  relation_to_head: String
}

"""
order by min() on columns of table "family_member"
"""
input family_member_min_order_by {
  created_at: order_by

  family_id: order_by

  id: order_by

  member_id: order_by

  relation_to_head: order_by
}

"""
response of any mutation on the table "family_member"
"""
type family_member_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [family_member!]!
}

"""
on_conflict condition type for table "family_member"
"""
input family_member_on_conflict {
  constraint: family_member_constraint!

  update_columns: [family_member_update_column!]! = []

  where: family_member_bool_exp
}

"""
Ordering options when selecting data from "family_member".
"""
input family_member_order_by {
  created_at: order_by

  family: family_order_by

  family_id: order_by

  family_relation: family_relation_order_by

  id: order_by

  is_head: order_by

  member: member_order_by

  member_id: order_by

  relation_to_head: order_by
}

"""
primary key columns input for table: family_member
"""
input family_member_pk_columns_input {
  id: String!
}

"""
select columns of table "family_member"
"""
enum family_member_select_column {
  """
  column name
  """
  created_at

  """
  column name
  """
  family_id

  """
  column name
  """
  id

  """
  column name
  """
  is_head

  """
  column name
  """
  member_id

  """
  column name
  """
  relation_to_head
}

"""
select "family_member_aggregate_bool_exp_bool_and_arguments_columns" columns of table "family_member"
"""
enum family_member_select_column_family_member_aggregate_bool_exp_bool_and_arguments_columns {
  """
  column name
  """
  is_head
}

"""
select "family_member_aggregate_bool_exp_bool_or_arguments_columns" columns of table "family_member"
"""
enum family_member_select_column_family_member_aggregate_bool_exp_bool_or_arguments_columns {
  """
  column name
  """
  is_head
}

"""
input type for updating data in table "family_member"
"""
input family_member_set_input {
  created_at: timestamptz

  family_id: String

  id: String

  is_head: Boolean

  member_id: String

  relation_to_head: String
}

"""
Streaming cursor of the table "family_member"
"""
input family_member_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: family_member_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input family_member_stream_cursor_value_input {
  created_at: timestamptz

  family_id: String

  id: String

  is_head: Boolean

  member_id: String

  relation_to_head: String
}

"""
update columns of table "family_member"
"""
enum family_member_update_column {
  """
  column name
  """
  created_at

  """
  column name
  """
  family_id

  """
  column name
  """
  id

  """
  column name
  """
  is_head

  """
  column name
  """
  member_id

  """
  column name
  """
  relation_to_head
}

input family_member_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: family_member_set_input

  """
  filter the rows which have to be updated
  """
  where: family_member_bool_exp!
}

"""
aggregate min on columns
"""
type family_min_fields {
  address_id: String

  arya_samaj_id: String

  created_at: timestamptz

  id: String

  name: String

  photos: [String!]

  updated_at: timestamptz
}

"""
order by min() on columns of table "family"
"""
input family_min_order_by {
  address_id: order_by

  arya_samaj_id: order_by

  created_at: order_by

  id: order_by

  name: order_by

  photos: order_by

  updated_at: order_by
}

"""
response of any mutation on the table "family"
"""
type family_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [family!]!
}

"""
input type for inserting object relation for remote table "family"
"""
input family_obj_rel_insert_input {
  data: family_insert_input!

  """
  upsert condition
  """
  on_conflict: family_on_conflict
}

"""
on_conflict condition type for table "family"
"""
input family_on_conflict {
  constraint: family_constraint!

  update_columns: [family_update_column!]! = []

  where: family_bool_exp
}

"""
Ordering options when selecting data from "family".
"""
input family_order_by {
  address: address_order_by

  address_id: order_by

  arya_samaj: arya_samaj_order_by

  arya_samaj_id: order_by

  created_at: order_by

  family_members_aggregate: family_member_aggregate_order_by

  id: order_by

  name: order_by

  photos: order_by

  updated_at: order_by
}

"""
primary key columns input for table: family
"""
input family_pk_columns_input {
  id: String!
}

"""
columns and relationships of "family_relation"
"""
type family_relation {
  comment: String

  """
  An array relationship
  """
  family_members("distinct select on columns" distinct_on: [family_member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [family_member_order_by!], "filter the rows returned" where: family_member_bool_exp): [family_member!]!

  """
  An aggregate relationship
  """
  family_members_aggregate("distinct select on columns" distinct_on: [family_member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [family_member_order_by!], "filter the rows returned" where: family_member_bool_exp): family_member_aggregate!

  value: String!
}

"""
aggregated selection of "family_relation"
"""
type family_relation_aggregate {
  aggregate: family_relation_aggregate_fields

  nodes: [family_relation!]!
}

"""
aggregate fields of "family_relation"
"""
type family_relation_aggregate_fields {
  count(columns: [family_relation_select_column!], distinct: Boolean): Int!

  max: family_relation_max_fields

  min: family_relation_min_fields
}

"""
Boolean expression to filter rows from the table "family_relation". All fields are combined with a logical 'AND'.
"""
input family_relation_bool_exp {
  _and: [family_relation_bool_exp!]

  _not: family_relation_bool_exp

  _or: [family_relation_bool_exp!]

  comment: String_comparison_exp

  family_members: family_member_bool_exp

  family_members_aggregate: family_member_aggregate_bool_exp

  value: String_comparison_exp
}

"""
unique or primary key constraints on table "family_relation"
"""
enum family_relation_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  family_relation_table_pkey
}

"""
input type for inserting data into table "family_relation"
"""
input family_relation_insert_input {
  comment: String

  family_members: family_member_arr_rel_insert_input

  value: String
}

"""
aggregate max on columns
"""
type family_relation_max_fields {
  comment: String

  value: String
}

"""
aggregate min on columns
"""
type family_relation_min_fields {
  comment: String

  value: String
}

"""
response of any mutation on the table "family_relation"
"""
type family_relation_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [family_relation!]!
}

"""
input type for inserting object relation for remote table "family_relation"
"""
input family_relation_obj_rel_insert_input {
  data: family_relation_insert_input!

  """
  upsert condition
  """
  on_conflict: family_relation_on_conflict
}

"""
on_conflict condition type for table "family_relation"
"""
input family_relation_on_conflict {
  constraint: family_relation_constraint!

  update_columns: [family_relation_update_column!]! = []

  where: family_relation_bool_exp
}

"""
Ordering options when selecting data from "family_relation".
"""
input family_relation_order_by {
  comment: order_by

  family_members_aggregate: family_member_aggregate_order_by

  value: order_by
}

"""
primary key columns input for table: family_relation
"""
input family_relation_pk_columns_input {
  value: String!
}

"""
select columns of table "family_relation"
"""
enum family_relation_select_column {
  """
  column name
  """
  comment

  """
  column name
  """
  value
}

"""
input type for updating data in table "family_relation"
"""
input family_relation_set_input {
  comment: String

  value: String
}

"""
Streaming cursor of the table "family_relation"
"""
input family_relation_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: family_relation_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input family_relation_stream_cursor_value_input {
  comment: String

  value: String
}

"""
update columns of table "family_relation"
"""
enum family_relation_update_column {
  """
  column name
  """
  comment

  """
  column name
  """
  value
}

input family_relation_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: family_relation_set_input

  """
  filter the rows which have to be updated
  """
  where: family_relation_bool_exp!
}

"""
select columns of table "family"
"""
enum family_select_column {
  """
  column name
  """
  address_id

  """
  column name
  """
  arya_samaj_id

  """
  column name
  """
  created_at

  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  photos

  """
  column name
  """
  updated_at
}

"""
input type for updating data in table "family"
"""
input family_set_input {
  address_id: String

  arya_samaj_id: String

  created_at: timestamptz

  id: String

  name: String

  photos: [String!]

  updated_at: timestamptz
}

"""
Streaming cursor of the table "family"
"""
input family_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: family_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input family_stream_cursor_value_input {
  address_id: String

  arya_samaj_id: String

  created_at: timestamptz

  id: String

  name: String

  photos: [String!]

  updated_at: timestamptz
}

"""
update columns of table "family"
"""
enum family_update_column {
  """
  column name
  """
  address_id

  """
  column name
  """
  arya_samaj_id

  """
  column name
  """
  created_at

  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  photos

  """
  column name
  """
  updated_at
}

input family_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: family_set_input

  """
  filter the rows which have to be updated
  """
  where: family_bool_exp!
}

scalar float8

"""
Boolean expression to compare columns of type "float8". All fields are combined with logical 'AND'.
"""
input float8_comparison_exp {
  _eq: float8

  _gt: float8

  _gte: float8

  _in: [float8!]

  _is_null: Boolean

  _lt: float8

  _lte: float8

  _neq: float8

  _nin: [float8!]
}

"""
columns and relationships of "gender_filter"
"""
type gender_filter {
  """
  An array relationship
  """
  activities("distinct select on columns" distinct_on: [activities_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [activities_order_by!], "filter the rows returned" where: activities_bool_exp): [activities!]!

  """
  An aggregate relationship
  """
  activities_aggregate("distinct select on columns" distinct_on: [activities_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [activities_order_by!], "filter the rows returned" where: activities_bool_exp): activities_aggregate!

  comment: String

  """
  An array relationship
  """
  members("distinct select on columns" distinct_on: [member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [member_order_by!], "filter the rows returned" where: member_bool_exp): [member!]!

  """
  An aggregate relationship
  """
  members_aggregate("distinct select on columns" distinct_on: [member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [member_order_by!], "filter the rows returned" where: member_bool_exp): member_aggregate!

  value: String!
}

"""
aggregated selection of "gender_filter"
"""
type gender_filter_aggregate {
  aggregate: gender_filter_aggregate_fields

  nodes: [gender_filter!]!
}

"""
aggregate fields of "gender_filter"
"""
type gender_filter_aggregate_fields {
  count(columns: [gender_filter_select_column!], distinct: Boolean): Int!

  max: gender_filter_max_fields

  min: gender_filter_min_fields
}

"""
Boolean expression to filter rows from the table "gender_filter". All fields are combined with a logical 'AND'.
"""
input gender_filter_bool_exp {
  _and: [gender_filter_bool_exp!]

  _not: gender_filter_bool_exp

  _or: [gender_filter_bool_exp!]

  activities: activities_bool_exp

  activities_aggregate: activities_aggregate_bool_exp

  comment: String_comparison_exp

  members: member_bool_exp

  members_aggregate: member_aggregate_bool_exp

  value: String_comparison_exp
}

"""
unique or primary key constraints on table "gender_filter"
"""
enum gender_filter_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  gender_filter_table_pkey
}

"""
input type for inserting data into table "gender_filter"
"""
input gender_filter_insert_input {
  activities: activities_arr_rel_insert_input

  comment: String

  members: member_arr_rel_insert_input

  value: String
}

"""
aggregate max on columns
"""
type gender_filter_max_fields {
  comment: String

  value: String
}

"""
aggregate min on columns
"""
type gender_filter_min_fields {
  comment: String

  value: String
}

"""
response of any mutation on the table "gender_filter"
"""
type gender_filter_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [gender_filter!]!
}

"""
input type for inserting object relation for remote table "gender_filter"
"""
input gender_filter_obj_rel_insert_input {
  data: gender_filter_insert_input!

  """
  upsert condition
  """
  on_conflict: gender_filter_on_conflict
}

"""
on_conflict condition type for table "gender_filter"
"""
input gender_filter_on_conflict {
  constraint: gender_filter_constraint!

  update_columns: [gender_filter_update_column!]! = []

  where: gender_filter_bool_exp
}

"""
Ordering options when selecting data from "gender_filter".
"""
input gender_filter_order_by {
  activities_aggregate: activities_aggregate_order_by

  comment: order_by

  members_aggregate: member_aggregate_order_by

  value: order_by
}

"""
primary key columns input for table: gender_filter
"""
input gender_filter_pk_columns_input {
  value: String!
}

"""
select columns of table "gender_filter"
"""
enum gender_filter_select_column {
  """
  column name
  """
  comment

  """
  column name
  """
  value
}

"""
input type for updating data in table "gender_filter"
"""
input gender_filter_set_input {
  comment: String

  value: String
}

"""
Streaming cursor of the table "gender_filter"
"""
input gender_filter_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: gender_filter_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input gender_filter_stream_cursor_value_input {
  comment: String

  value: String
}

"""
update columns of table "gender_filter"
"""
enum gender_filter_update_column {
  """
  column name
  """
  comment

  """
  column name
  """
  value
}

input gender_filter_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: gender_filter_set_input

  """
  filter the rows which have to be updated
  """
  where: gender_filter_bool_exp!
}

"""
columns and relationships of "learning"
"""
type learning {
  description: String

  id: String!

  thumbnail_url: String

  title: String

  url: String

  video_id: String
}

"""
aggregated selection of "learning"
"""
type learning_aggregate {
  aggregate: learning_aggregate_fields

  nodes: [learning!]!
}

"""
aggregate fields of "learning"
"""
type learning_aggregate_fields {
  count(columns: [learning_select_column!], distinct: Boolean): Int!

  max: learning_max_fields

  min: learning_min_fields
}

"""
Boolean expression to filter rows from the table "learning". All fields are combined with a logical 'AND'.
"""
input learning_bool_exp {
  _and: [learning_bool_exp!]

  _not: learning_bool_exp

  _or: [learning_bool_exp!]

  description: String_comparison_exp

  id: String_comparison_exp

  thumbnail_url: String_comparison_exp

  title: String_comparison_exp

  url: String_comparison_exp

  video_id: String_comparison_exp
}

"""
unique or primary key constraints on table "learning"
"""
enum learning_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  learning_pkey
}

"""
input type for inserting data into table "learning"
"""
input learning_insert_input {
  description: String

  id: String

  thumbnail_url: String

  title: String

  url: String

  video_id: String
}

"""
aggregate max on columns
"""
type learning_max_fields {
  description: String

  id: String

  thumbnail_url: String

  title: String

  url: String

  video_id: String
}

"""
aggregate min on columns
"""
type learning_min_fields {
  description: String

  id: String

  thumbnail_url: String

  title: String

  url: String

  video_id: String
}

"""
response of any mutation on the table "learning"
"""
type learning_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [learning!]!
}

"""
on_conflict condition type for table "learning"
"""
input learning_on_conflict {
  constraint: learning_constraint!

  update_columns: [learning_update_column!]! = []

  where: learning_bool_exp
}

"""
Ordering options when selecting data from "learning".
"""
input learning_order_by {
  description: order_by

  id: order_by

  thumbnail_url: order_by

  title: order_by

  url: order_by

  video_id: order_by
}

"""
primary key columns input for table: learning
"""
input learning_pk_columns_input {
  id: String!
}

"""
select columns of table "learning"
"""
enum learning_select_column {
  """
  column name
  """
  description

  """
  column name
  """
  id

  """
  column name
  """
  thumbnail_url

  """
  column name
  """
  title

  """
  column name
  """
  url

  """
  column name
  """
  video_id
}

"""
input type for updating data in table "learning"
"""
input learning_set_input {
  description: String

  id: String

  thumbnail_url: String

  title: String

  url: String

  video_id: String
}

"""
Streaming cursor of the table "learning"
"""
input learning_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: learning_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input learning_stream_cursor_value_input {
  description: String

  id: String

  thumbnail_url: String

  title: String

  url: String

  video_id: String
}

"""
update columns of table "learning"
"""
enum learning_update_column {
  """
  column name
  """
  description

  """
  column name
  """
  id

  """
  column name
  """
  thumbnail_url

  """
  column name
  """
  title

  """
  column name
  """
  url

  """
  column name
  """
  video_id
}

input learning_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: learning_set_input

  """
  filter the rows which have to be updated
  """
  where: learning_bool_exp!
}

"""
columns and relationships of "member"
"""
type member {
  """
  An array relationship
  """
  activity_members("distinct select on columns" distinct_on: [activity_member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [activity_member_order_by!], "filter the rows returned" where: activity_member_bool_exp): [activity_member!]!

  """
  An aggregate relationship
  """
  activity_members_aggregate("distinct select on columns" distinct_on: [activity_member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [activity_member_order_by!], "filter the rows returned" where: activity_member_bool_exp): activity_member_aggregate!

  """
  An object relationship
  """
  address: address

  """
  An object relationship
  """
  addressByTempAddressId: address

  address_id: String

  """
  An object relationship
  """
  arya_samaj: arya_samaj

  arya_samaj_id: String

  created_at: timestamptz!

  dob: date

  educational_qualification: String

  email: String

  """
  An array relationship
  """
  family_members("distinct select on columns" distinct_on: [family_member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [family_member_order_by!], "filter the rows returned" where: family_member_bool_exp): [family_member!]!

  """
  An aggregate relationship
  """
  family_members_aggregate("distinct select on columns" distinct_on: [family_member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [family_member_order_by!], "filter the rows returned" where: family_member_bool_exp): family_member_aggregate!

  gender: String

  """
  An object relationship
  """
  gender_filter: gender_filter

  id: String!

  introduction: String

  joining_date: date

  """
  An object relationship
  """
  member: member

  """
  An array relationship
  """
  members("distinct select on columns" distinct_on: [member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [member_order_by!], "filter the rows returned" where: member_bool_exp): [member!]!

  """
  An aggregate relationship
  """
  members_aggregate("distinct select on columns" distinct_on: [member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [member_order_by!], "filter the rows returned" where: member_bool_exp): member_aggregate!

  name: String!

  occupation: String

  """
  An array relationship
  """
  organisational_members("distinct select on columns" distinct_on: [organisational_member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [organisational_member_order_by!], "filter the rows returned" where: organisational_member_bool_exp): [organisational_member!]!

  """
  An aggregate relationship
  """
  organisational_members_aggregate("distinct select on columns" distinct_on: [organisational_member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [organisational_member_order_by!], "filter the rows returned" where: organisational_member_bool_exp): organisational_member_aggregate!

  phone_number: String!

  profile_image: String

  referrer_id: String

  """
  An array relationship
  """
  samaj_members("distinct select on columns" distinct_on: [samaj_member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [samaj_member_order_by!], "filter the rows returned" where: samaj_member_bool_exp): [samaj_member!]!

  """
  An aggregate relationship
  """
  samaj_members_aggregate("distinct select on columns" distinct_on: [samaj_member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [samaj_member_order_by!], "filter the rows returned" where: samaj_member_bool_exp): samaj_member_aggregate!

  temp_address_id: String

  updated_at: timestamptz!
}

"""
aggregated selection of "member"
"""
type member_aggregate {
  aggregate: member_aggregate_fields

  nodes: [member!]!
}

input member_aggregate_bool_exp {
  count: member_aggregate_bool_exp_count
}

input member_aggregate_bool_exp_count {
  arguments: [member_select_column!]

  distinct: Boolean

  filter: member_bool_exp

  predicate: Int_comparison_exp!
}

"""
aggregate fields of "member"
"""
type member_aggregate_fields {
  count(columns: [member_select_column!], distinct: Boolean): Int!

  max: member_max_fields

  min: member_min_fields
}

"""
order by aggregate values of table "member"
"""
input member_aggregate_order_by {
  count: order_by

  max: member_max_order_by

  min: member_min_order_by
}

"""
input type for inserting array relation for remote table "member"
"""
input member_arr_rel_insert_input {
  data: [member_insert_input!]!

  """
  upsert condition
  """
  on_conflict: member_on_conflict
}

"""
Boolean expression to filter rows from the table "member". All fields are combined with a logical 'AND'.
"""
input member_bool_exp {
  _and: [member_bool_exp!]

  _not: member_bool_exp

  _or: [member_bool_exp!]

  activity_members: activity_member_bool_exp

  activity_members_aggregate: activity_member_aggregate_bool_exp

  address: address_bool_exp

  addressByTempAddressId: address_bool_exp

  address_id: String_comparison_exp

  arya_samaj: arya_samaj_bool_exp

  arya_samaj_id: String_comparison_exp

  created_at: timestamptz_comparison_exp

  dob: date_comparison_exp

  educational_qualification: String_comparison_exp

  email: String_comparison_exp

  family_members: family_member_bool_exp

  family_members_aggregate: family_member_aggregate_bool_exp

  gender: String_comparison_exp

  gender_filter: gender_filter_bool_exp

  id: String_comparison_exp

  introduction: String_comparison_exp

  joining_date: date_comparison_exp

  member: member_bool_exp

  members: member_bool_exp

  members_aggregate: member_aggregate_bool_exp

  name: String_comparison_exp

  occupation: String_comparison_exp

  organisational_members: organisational_member_bool_exp

  organisational_members_aggregate: organisational_member_aggregate_bool_exp

  phone_number: String_comparison_exp

  profile_image: String_comparison_exp

  referrer_id: String_comparison_exp

  samaj_members: samaj_member_bool_exp

  samaj_members_aggregate: samaj_member_aggregate_bool_exp

  temp_address_id: String_comparison_exp

  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "member"
"""
enum member_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  member_pkey
}

"""
columns and relationships of "member_in_organisation"
"""
type member_in_organisation {
  id: String

  name: String

  phone_number: String

  profile_image: String
}

"""
aggregated selection of "member_in_organisation"
"""
type member_in_organisation_aggregate {
  aggregate: member_in_organisation_aggregate_fields

  nodes: [member_in_organisation!]!
}

"""
aggregate fields of "member_in_organisation"
"""
type member_in_organisation_aggregate_fields {
  count(columns: [member_in_organisation_select_column!], distinct: Boolean): Int!

  max: member_in_organisation_max_fields

  min: member_in_organisation_min_fields
}

"""
Boolean expression to filter rows from the table "member_in_organisation". All fields are combined with a logical 'AND'.
"""
input member_in_organisation_bool_exp {
  _and: [member_in_organisation_bool_exp!]

  _not: member_in_organisation_bool_exp

  _or: [member_in_organisation_bool_exp!]

  id: String_comparison_exp

  name: String_comparison_exp

  phone_number: String_comparison_exp

  profile_image: String_comparison_exp
}

"""
aggregate max on columns
"""
type member_in_organisation_max_fields {
  id: String

  name: String

  phone_number: String

  profile_image: String
}

"""
aggregate min on columns
"""
type member_in_organisation_min_fields {
  id: String

  name: String

  phone_number: String

  profile_image: String
}

"""
Ordering options when selecting data from "member_in_organisation".
"""
input member_in_organisation_order_by {
  id: order_by

  name: order_by

  phone_number: order_by

  profile_image: order_by
}

"""
select columns of table "member_in_organisation"
"""
enum member_in_organisation_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  phone_number

  """
  column name
  """
  profile_image
}

"""
Streaming cursor of the table "member_in_organisation"
"""
input member_in_organisation_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: member_in_organisation_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input member_in_organisation_stream_cursor_value_input {
  id: String

  name: String

  phone_number: String

  profile_image: String
}

"""
input type for inserting data into table "member"
"""
input member_insert_input {
  activity_members: activity_member_arr_rel_insert_input

  address: address_obj_rel_insert_input

  addressByTempAddressId: address_obj_rel_insert_input

  address_id: String

  arya_samaj: arya_samaj_obj_rel_insert_input

  arya_samaj_id: String

  created_at: timestamptz

  dob: date

  educational_qualification: String

  email: String

  family_members: family_member_arr_rel_insert_input

  gender: String

  gender_filter: gender_filter_obj_rel_insert_input

  id: String

  introduction: String

  joining_date: date

  member: member_obj_rel_insert_input

  members: member_arr_rel_insert_input

  name: String

  occupation: String

  organisational_members: organisational_member_arr_rel_insert_input

  phone_number: String

  profile_image: String

  referrer_id: String

  samaj_members: samaj_member_arr_rel_insert_input

  temp_address_id: String

  updated_at: timestamptz
}

"""
aggregate max on columns
"""
type member_max_fields {
  address_id: String

  arya_samaj_id: String

  created_at: timestamptz

  dob: date

  educational_qualification: String

  email: String

  gender: String

  id: String

  introduction: String

  joining_date: date

  name: String

  occupation: String

  phone_number: String

  profile_image: String

  referrer_id: String

  temp_address_id: String

  updated_at: timestamptz
}

"""
order by max() on columns of table "member"
"""
input member_max_order_by {
  address_id: order_by

  arya_samaj_id: order_by

  created_at: order_by

  dob: order_by

  educational_qualification: order_by

  email: order_by

  gender: order_by

  id: order_by

  introduction: order_by

  joining_date: order_by

  name: order_by

  occupation: order_by

  phone_number: order_by

  profile_image: order_by

  referrer_id: order_by

  temp_address_id: order_by

  updated_at: order_by
}

"""
aggregate min on columns
"""
type member_min_fields {
  address_id: String

  arya_samaj_id: String

  created_at: timestamptz

  dob: date

  educational_qualification: String

  email: String

  gender: String

  id: String

  introduction: String

  joining_date: date

  name: String

  occupation: String

  phone_number: String

  profile_image: String

  referrer_id: String

  temp_address_id: String

  updated_at: timestamptz
}

"""
order by min() on columns of table "member"
"""
input member_min_order_by {
  address_id: order_by

  arya_samaj_id: order_by

  created_at: order_by

  dob: order_by

  educational_qualification: order_by

  email: order_by

  gender: order_by

  id: order_by

  introduction: order_by

  joining_date: order_by

  name: order_by

  occupation: order_by

  phone_number: order_by

  profile_image: order_by

  referrer_id: order_by

  temp_address_id: order_by

  updated_at: order_by
}

"""
response of any mutation on the table "member"
"""
type member_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [member!]!
}

"""
columns and relationships of "member_not_in_family"
"""
type member_not_in_family {
  address_id: String

  id: String

  name: String

  phone_number: String

  profile_image: String
}

"""
aggregated selection of "member_not_in_family"
"""
type member_not_in_family_aggregate {
  aggregate: member_not_in_family_aggregate_fields

  nodes: [member_not_in_family!]!
}

"""
aggregate fields of "member_not_in_family"
"""
type member_not_in_family_aggregate_fields {
  count(columns: [member_not_in_family_select_column!], distinct: Boolean): Int!

  max: member_not_in_family_max_fields

  min: member_not_in_family_min_fields
}

"""
Boolean expression to filter rows from the table "member_not_in_family". All fields are combined with a logical 'AND'.
"""
input member_not_in_family_bool_exp {
  _and: [member_not_in_family_bool_exp!]

  _not: member_not_in_family_bool_exp

  _or: [member_not_in_family_bool_exp!]

  address_id: String_comparison_exp

  id: String_comparison_exp

  name: String_comparison_exp

  phone_number: String_comparison_exp

  profile_image: String_comparison_exp
}

"""
aggregate max on columns
"""
type member_not_in_family_max_fields {
  address_id: String

  id: String

  name: String

  phone_number: String

  profile_image: String
}

"""
aggregate min on columns
"""
type member_not_in_family_min_fields {
  address_id: String

  id: String

  name: String

  phone_number: String

  profile_image: String
}

"""
Ordering options when selecting data from "member_not_in_family".
"""
input member_not_in_family_order_by {
  address_id: order_by

  id: order_by

  name: order_by

  phone_number: order_by

  profile_image: order_by
}

"""
select columns of table "member_not_in_family"
"""
enum member_not_in_family_select_column {
  """
  column name
  """
  address_id

  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  phone_number

  """
  column name
  """
  profile_image
}

"""
Streaming cursor of the table "member_not_in_family"
"""
input member_not_in_family_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: member_not_in_family_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input member_not_in_family_stream_cursor_value_input {
  address_id: String

  id: String

  name: String

  phone_number: String

  profile_image: String
}

"""
input type for inserting object relation for remote table "member"
"""
input member_obj_rel_insert_input {
  data: member_insert_input!

  """
  upsert condition
  """
  on_conflict: member_on_conflict
}

"""
on_conflict condition type for table "member"
"""
input member_on_conflict {
  constraint: member_constraint!

  update_columns: [member_update_column!]! = []

  where: member_bool_exp
}

"""
Ordering options when selecting data from "member".
"""
input member_order_by {
  activity_members_aggregate: activity_member_aggregate_order_by

  address: address_order_by

  addressByTempAddressId: address_order_by

  address_id: order_by

  arya_samaj: arya_samaj_order_by

  arya_samaj_id: order_by

  created_at: order_by

  dob: order_by

  educational_qualification: order_by

  email: order_by

  family_members_aggregate: family_member_aggregate_order_by

  gender: order_by

  gender_filter: gender_filter_order_by

  id: order_by

  introduction: order_by

  joining_date: order_by

  member: member_order_by

  members_aggregate: member_aggregate_order_by

  name: order_by

  occupation: order_by

  organisational_members_aggregate: organisational_member_aggregate_order_by

  phone_number: order_by

  profile_image: order_by

  referrer_id: order_by

  samaj_members_aggregate: samaj_member_aggregate_order_by

  temp_address_id: order_by

  updated_at: order_by
}

"""
primary key columns input for table: member
"""
input member_pk_columns_input {
  id: String!
}

"""
select columns of table "member"
"""
enum member_select_column {
  """
  column name
  """
  address_id

  """
  column name
  """
  arya_samaj_id

  """
  column name
  """
  created_at

  """
  column name
  """
  dob

  """
  column name
  """
  educational_qualification

  """
  column name
  """
  email

  """
  column name
  """
  gender

  """
  column name
  """
  id

  """
  column name
  """
  introduction

  """
  column name
  """
  joining_date

  """
  column name
  """
  name

  """
  column name
  """
  occupation

  """
  column name
  """
  phone_number

  """
  column name
  """
  profile_image

  """
  column name
  """
  referrer_id

  """
  column name
  """
  temp_address_id

  """
  column name
  """
  updated_at
}

"""
input type for updating data in table "member"
"""
input member_set_input {
  address_id: String

  arya_samaj_id: String

  created_at: timestamptz

  dob: date

  educational_qualification: String

  email: String

  gender: String

  id: String

  introduction: String

  joining_date: date

  name: String

  occupation: String

  phone_number: String

  profile_image: String

  referrer_id: String

  temp_address_id: String

  updated_at: timestamptz
}

"""
Streaming cursor of the table "member"
"""
input member_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: member_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input member_stream_cursor_value_input {
  address_id: String

  arya_samaj_id: String

  created_at: timestamptz

  dob: date

  educational_qualification: String

  email: String

  gender: String

  id: String

  introduction: String

  joining_date: date

  name: String

  occupation: String

  phone_number: String

  profile_image: String

  referrer_id: String

  temp_address_id: String

  updated_at: timestamptz
}

"""
update columns of table "member"
"""
enum member_update_column {
  """
  column name
  """
  address_id

  """
  column name
  """
  arya_samaj_id

  """
  column name
  """
  created_at

  """
  column name
  """
  dob

  """
  column name
  """
  educational_qualification

  """
  column name
  """
  email

  """
  column name
  """
  gender

  """
  column name
  """
  id

  """
  column name
  """
  introduction

  """
  column name
  """
  joining_date

  """
  column name
  """
  name

  """
  column name
  """
  occupation

  """
  column name
  """
  phone_number

  """
  column name
  """
  profile_image

  """
  column name
  """
  referrer_id

  """
  column name
  """
  temp_address_id

  """
  column name
  """
  updated_at
}

input member_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: member_set_input

  """
  filter the rows which have to be updated
  """
  where: member_bool_exp!
}

"""
mutation root
"""
type mutation_root {
  """
  delete data from the table: "activities"
  """
  delete_activities("filter the rows which have to be deleted" where: activities_bool_exp!): activities_mutation_response

  """
  delete single row from the table: "activities"
  """
  delete_activities_by_pk(id: String!): activities

  """
  delete data from the table: "activity_member"
  """
  delete_activity_member("filter the rows which have to be deleted" where: activity_member_bool_exp!): activity_member_mutation_response

  """
  delete single row from the table: "activity_member"
  """
  delete_activity_member_by_pk(id: uuid!): activity_member

  """
  delete data from the table: "activity_type"
  """
  delete_activity_type("filter the rows which have to be deleted" where: activity_type_bool_exp!): activity_type_mutation_response

  """
  delete single row from the table: "activity_type"
  """
  delete_activity_type_by_pk(value: String!): activity_type

  """
  delete data from the table: "address"
  """
  delete_address("filter the rows which have to be deleted" where: address_bool_exp!): address_mutation_response

  """
  delete single row from the table: "address"
  """
  delete_address_by_pk(id: String!): address

  """
  delete data from the table: "admission"
  """
  delete_admission("filter the rows which have to be deleted" where: admission_bool_exp!): admission_mutation_response

  """
  delete single row from the table: "admission"
  """
  delete_admission_by_pk(id: String!): admission

  """
  delete data from the table: "app_labels"
  """
  delete_app_labels("filter the rows which have to be deleted" where: app_labels_bool_exp!): app_labels_mutation_response

  """
  delete single row from the table: "app_labels"
  """
  delete_app_labels_by_pk(id: uuid!): app_labels

  """
  delete data from the table: "arya_samaj"
  """
  delete_arya_samaj("filter the rows which have to be deleted" where: arya_samaj_bool_exp!): arya_samaj_mutation_response

  """
  delete single row from the table: "arya_samaj"
  """
  delete_arya_samaj_by_pk(id: String!): arya_samaj

  """
  delete data from the table: "book_orders"
  """
  delete_book_orders("filter the rows which have to be deleted" where: book_orders_bool_exp!): book_orders_mutation_response

  """
  delete single row from the table: "book_orders"
  """
  delete_book_orders_by_pk(id: uuid!): book_orders

  """
  delete data from the table: "course_registrations"
  """
  delete_course_registrations("filter the rows which have to be deleted" where: course_registrations_bool_exp!): course_registrations_mutation_response

  """
  delete single row from the table: "course_registrations"
  """
  delete_course_registrations_by_pk(id: String!): course_registrations

  """
  delete data from the table: "family"
  """
  delete_family("filter the rows which have to be deleted" where: family_bool_exp!): family_mutation_response

  """
  delete single row from the table: "family"
  """
  delete_family_by_pk(id: String!): family

  """
  delete data from the table: "family_member"
  """
  delete_family_member("filter the rows which have to be deleted" where: family_member_bool_exp!): family_member_mutation_response

  """
  delete single row from the table: "family_member"
  """
  delete_family_member_by_pk(id: String!): family_member

  """
  delete data from the table: "family_relation"
  """
  delete_family_relation("filter the rows which have to be deleted" where: family_relation_bool_exp!): family_relation_mutation_response

  """
  delete single row from the table: "family_relation"
  """
  delete_family_relation_by_pk(value: String!): family_relation

  """
  delete data from the table: "gender_filter"
  """
  delete_gender_filter("filter the rows which have to be deleted" where: gender_filter_bool_exp!): gender_filter_mutation_response

  """
  delete single row from the table: "gender_filter"
  """
  delete_gender_filter_by_pk(value: String!): gender_filter

  """
  delete data from the table: "learning"
  """
  delete_learning("filter the rows which have to be deleted" where: learning_bool_exp!): learning_mutation_response

  """
  delete single row from the table: "learning"
  """
  delete_learning_by_pk(id: String!): learning

  """
  delete data from the table: "member"
  """
  delete_member("filter the rows which have to be deleted" where: member_bool_exp!): member_mutation_response

  """
  delete single row from the table: "member"
  """
  delete_member_by_pk(id: String!): member

  """
  delete data from the table: "organisation"
  """
  delete_organisation("filter the rows which have to be deleted" where: organisation_bool_exp!): organisation_mutation_response

  """
  delete single row from the table: "organisation"
  """
  delete_organisation_by_pk(id: String!): organisation

  """
  delete data from the table: "organisational_activity"
  """
  delete_organisational_activity("filter the rows which have to be deleted" where: organisational_activity_bool_exp!): organisational_activity_mutation_response

  """
  delete single row from the table: "organisational_activity"
  """
  delete_organisational_activity_by_pk(id: String!): organisational_activity

  """
  delete data from the table: "organisational_member"
  """
  delete_organisational_member("filter the rows which have to be deleted" where: organisational_member_bool_exp!): organisational_member_mutation_response

  """
  delete single row from the table: "organisational_member"
  """
  delete_organisational_member_by_pk(id: String!, member_id: String!, organisation_id: String!): organisational_member

  """
  delete data from the table: "samaj_member"
  """
  delete_samaj_member("filter the rows which have to be deleted" where: samaj_member_bool_exp!): samaj_member_mutation_response

  """
  delete single row from the table: "samaj_member"
  """
  delete_samaj_member_by_pk(id: String!): samaj_member

  """
  delete data from the table: "satr_registration"
  """
  delete_satr_registration("filter the rows which have to be deleted" where: satr_registration_bool_exp!): satr_registration_mutation_response

  """
  delete single row from the table: "satr_registration"
  """
  delete_satr_registration_by_pk(id: uuid!): satr_registration

  """
  insert data into the table: "activities"
  """
  insert_activities("the rows to be inserted" objects: [activities_insert_input!]!, "upsert condition" on_conflict: activities_on_conflict): activities_mutation_response

  """
  insert a single row into the table: "activities"
  """
  insert_activities_one("the row to be inserted" object: activities_insert_input!, "upsert condition" on_conflict: activities_on_conflict): activities

  """
  insert data into the table: "activity_member"
  """
  insert_activity_member("the rows to be inserted" objects: [activity_member_insert_input!]!, "upsert condition" on_conflict: activity_member_on_conflict): activity_member_mutation_response

  """
  insert a single row into the table: "activity_member"
  """
  insert_activity_member_one("the row to be inserted" object: activity_member_insert_input!, "upsert condition" on_conflict: activity_member_on_conflict): activity_member

  """
  insert data into the table: "activity_type"
  """
  insert_activity_type("the rows to be inserted" objects: [activity_type_insert_input!]!, "upsert condition" on_conflict: activity_type_on_conflict): activity_type_mutation_response

  """
  insert a single row into the table: "activity_type"
  """
  insert_activity_type_one("the row to be inserted" object: activity_type_insert_input!, "upsert condition" on_conflict: activity_type_on_conflict): activity_type

  """
  insert data into the table: "address"
  """
  insert_address("the rows to be inserted" objects: [address_insert_input!]!, "upsert condition" on_conflict: address_on_conflict): address_mutation_response

  """
  insert a single row into the table: "address"
  """
  insert_address_one("the row to be inserted" object: address_insert_input!, "upsert condition" on_conflict: address_on_conflict): address

  """
  insert data into the table: "admission"
  """
  insert_admission("the rows to be inserted" objects: [admission_insert_input!]!, "upsert condition" on_conflict: admission_on_conflict): admission_mutation_response

  """
  insert a single row into the table: "admission"
  """
  insert_admission_one("the row to be inserted" object: admission_insert_input!, "upsert condition" on_conflict: admission_on_conflict): admission

  """
  insert data into the table: "app_labels"
  """
  insert_app_labels("the rows to be inserted" objects: [app_labels_insert_input!]!, "upsert condition" on_conflict: app_labels_on_conflict): app_labels_mutation_response

  """
  insert a single row into the table: "app_labels"
  """
  insert_app_labels_one("the row to be inserted" object: app_labels_insert_input!, "upsert condition" on_conflict: app_labels_on_conflict): app_labels

  """
  insert data into the table: "arya_samaj"
  """
  insert_arya_samaj("the rows to be inserted" objects: [arya_samaj_insert_input!]!, "upsert condition" on_conflict: arya_samaj_on_conflict): arya_samaj_mutation_response

  """
  insert a single row into the table: "arya_samaj"
  """
  insert_arya_samaj_one("the row to be inserted" object: arya_samaj_insert_input!, "upsert condition" on_conflict: arya_samaj_on_conflict): arya_samaj

  """
  insert data into the table: "book_orders"
  """
  insert_book_orders("the rows to be inserted" objects: [book_orders_insert_input!]!, "upsert condition" on_conflict: book_orders_on_conflict): book_orders_mutation_response

  """
  insert a single row into the table: "book_orders"
  """
  insert_book_orders_one("the row to be inserted" object: book_orders_insert_input!, "upsert condition" on_conflict: book_orders_on_conflict): book_orders

  """
  insert data into the table: "course_registrations"
  """
  insert_course_registrations("the rows to be inserted" objects: [course_registrations_insert_input!]!, "upsert condition" on_conflict: course_registrations_on_conflict): course_registrations_mutation_response

  """
  insert a single row into the table: "course_registrations"
  """
  insert_course_registrations_one("the row to be inserted" object: course_registrations_insert_input!, "upsert condition" on_conflict: course_registrations_on_conflict): course_registrations

  """
  insert data into the table: "family"
  """
  insert_family("the rows to be inserted" objects: [family_insert_input!]!, "upsert condition" on_conflict: family_on_conflict): family_mutation_response

  """
  insert data into the table: "family_member"
  """
  insert_family_member("the rows to be inserted" objects: [family_member_insert_input!]!, "upsert condition" on_conflict: family_member_on_conflict): family_member_mutation_response

  """
  insert a single row into the table: "family_member"
  """
  insert_family_member_one("the row to be inserted" object: family_member_insert_input!, "upsert condition" on_conflict: family_member_on_conflict): family_member

  """
  insert a single row into the table: "family"
  """
  insert_family_one("the row to be inserted" object: family_insert_input!, "upsert condition" on_conflict: family_on_conflict): family

  """
  insert data into the table: "family_relation"
  """
  insert_family_relation("the rows to be inserted" objects: [family_relation_insert_input!]!, "upsert condition" on_conflict: family_relation_on_conflict): family_relation_mutation_response

  """
  insert a single row into the table: "family_relation"
  """
  insert_family_relation_one("the row to be inserted" object: family_relation_insert_input!, "upsert condition" on_conflict: family_relation_on_conflict): family_relation

  """
  insert data into the table: "gender_filter"
  """
  insert_gender_filter("the rows to be inserted" objects: [gender_filter_insert_input!]!, "upsert condition" on_conflict: gender_filter_on_conflict): gender_filter_mutation_response

  """
  insert a single row into the table: "gender_filter"
  """
  insert_gender_filter_one("the row to be inserted" object: gender_filter_insert_input!, "upsert condition" on_conflict: gender_filter_on_conflict): gender_filter

  """
  insert data into the table: "learning"
  """
  insert_learning("the rows to be inserted" objects: [learning_insert_input!]!, "upsert condition" on_conflict: learning_on_conflict): learning_mutation_response

  """
  insert a single row into the table: "learning"
  """
  insert_learning_one("the row to be inserted" object: learning_insert_input!, "upsert condition" on_conflict: learning_on_conflict): learning

  """
  insert data into the table: "member"
  """
  insert_member("the rows to be inserted" objects: [member_insert_input!]!, "upsert condition" on_conflict: member_on_conflict): member_mutation_response

  """
  insert a single row into the table: "member"
  """
  insert_member_one("the row to be inserted" object: member_insert_input!, "upsert condition" on_conflict: member_on_conflict): member

  """
  insert data into the table: "organisation"
  """
  insert_organisation("the rows to be inserted" objects: [organisation_insert_input!]!, "upsert condition" on_conflict: organisation_on_conflict): organisation_mutation_response

  """
  insert a single row into the table: "organisation"
  """
  insert_organisation_one("the row to be inserted" object: organisation_insert_input!, "upsert condition" on_conflict: organisation_on_conflict): organisation

  """
  insert data into the table: "organisational_activity"
  """
  insert_organisational_activity("the rows to be inserted" objects: [organisational_activity_insert_input!]!, "upsert condition" on_conflict: organisational_activity_on_conflict): organisational_activity_mutation_response

  """
  insert a single row into the table: "organisational_activity"
  """
  insert_organisational_activity_one("the row to be inserted" object: organisational_activity_insert_input!, "upsert condition" on_conflict: organisational_activity_on_conflict): organisational_activity

  """
  insert data into the table: "organisational_member"
  """
  insert_organisational_member("the rows to be inserted" objects: [organisational_member_insert_input!]!, "upsert condition" on_conflict: organisational_member_on_conflict): organisational_member_mutation_response

  """
  insert a single row into the table: "organisational_member"
  """
  insert_organisational_member_one("the row to be inserted" object: organisational_member_insert_input!, "upsert condition" on_conflict: organisational_member_on_conflict): organisational_member

  """
  insert data into the table: "samaj_member"
  """
  insert_samaj_member("the rows to be inserted" objects: [samaj_member_insert_input!]!, "upsert condition" on_conflict: samaj_member_on_conflict): samaj_member_mutation_response

  """
  insert a single row into the table: "samaj_member"
  """
  insert_samaj_member_one("the row to be inserted" object: samaj_member_insert_input!, "upsert condition" on_conflict: samaj_member_on_conflict): samaj_member

  """
  insert data into the table: "satr_registration"
  """
  insert_satr_registration("the rows to be inserted" objects: [satr_registration_insert_input!]!, "upsert condition" on_conflict: satr_registration_on_conflict): satr_registration_mutation_response

  """
  insert a single row into the table: "satr_registration"
  """
  insert_satr_registration_one("the row to be inserted" object: satr_registration_insert_input!, "upsert condition" on_conflict: satr_registration_on_conflict): satr_registration

  """
  update data of the table: "activities"
  """
  update_activities("increments the numeric columns with given value of the filtered values" _inc: activities_inc_input, "sets the columns of the filtered rows to the given values" _set: activities_set_input, "filter the rows which have to be updated" where: activities_bool_exp!): activities_mutation_response

  """
  update single row of the table: "activities"
  """
  update_activities_by_pk("increments the numeric columns with given value of the filtered values" _inc: activities_inc_input, "sets the columns of the filtered rows to the given values" _set: activities_set_input, pk_columns: activities_pk_columns_input!): activities

  """
  update multiples rows of table: "activities"
  """
  update_activities_many("updates to execute, in order" updates: [activities_updates!]!): [activities_mutation_response]

  """
  update data of the table: "activity_member"
  """
  update_activity_member("increments the numeric columns with given value of the filtered values" _inc: activity_member_inc_input, "sets the columns of the filtered rows to the given values" _set: activity_member_set_input, "filter the rows which have to be updated" where: activity_member_bool_exp!): activity_member_mutation_response

  """
  update single row of the table: "activity_member"
  """
  update_activity_member_by_pk("increments the numeric columns with given value of the filtered values" _inc: activity_member_inc_input, "sets the columns of the filtered rows to the given values" _set: activity_member_set_input, pk_columns: activity_member_pk_columns_input!): activity_member

  """
  update multiples rows of table: "activity_member"
  """
  update_activity_member_many("updates to execute, in order" updates: [activity_member_updates!]!): [activity_member_mutation_response]

  """
  update data of the table: "activity_type"
  """
  update_activity_type("sets the columns of the filtered rows to the given values" _set: activity_type_set_input, "filter the rows which have to be updated" where: activity_type_bool_exp!): activity_type_mutation_response

  """
  update single row of the table: "activity_type"
  """
  update_activity_type_by_pk("sets the columns of the filtered rows to the given values" _set: activity_type_set_input, pk_columns: activity_type_pk_columns_input!): activity_type

  """
  update multiples rows of table: "activity_type"
  """
  update_activity_type_many("updates to execute, in order" updates: [activity_type_updates!]!): [activity_type_mutation_response]

  """
  update data of the table: "address"
  """
  update_address("increments the numeric columns with given value of the filtered values" _inc: address_inc_input, "sets the columns of the filtered rows to the given values" _set: address_set_input, "filter the rows which have to be updated" where: address_bool_exp!): address_mutation_response

  """
  update single row of the table: "address"
  """
  update_address_by_pk("increments the numeric columns with given value of the filtered values" _inc: address_inc_input, "sets the columns of the filtered rows to the given values" _set: address_set_input, pk_columns: address_pk_columns_input!): address

  """
  update multiples rows of table: "address"
  """
  update_address_many("updates to execute, in order" updates: [address_updates!]!): [address_mutation_response]

  """
  update data of the table: "admission"
  """
  update_admission("sets the columns of the filtered rows to the given values" _set: admission_set_input, "filter the rows which have to be updated" where: admission_bool_exp!): admission_mutation_response

  """
  update single row of the table: "admission"
  """
  update_admission_by_pk("sets the columns of the filtered rows to the given values" _set: admission_set_input, pk_columns: admission_pk_columns_input!): admission

  """
  update multiples rows of table: "admission"
  """
  update_admission_many("updates to execute, in order" updates: [admission_updates!]!): [admission_mutation_response]

  """
  update data of the table: "app_labels"
  """
  update_app_labels("sets the columns of the filtered rows to the given values" _set: app_labels_set_input, "filter the rows which have to be updated" where: app_labels_bool_exp!): app_labels_mutation_response

  """
  update single row of the table: "app_labels"
  """
  update_app_labels_by_pk("sets the columns of the filtered rows to the given values" _set: app_labels_set_input, pk_columns: app_labels_pk_columns_input!): app_labels

  """
  update multiples rows of table: "app_labels"
  """
  update_app_labels_many("updates to execute, in order" updates: [app_labels_updates!]!): [app_labels_mutation_response]

  """
  update data of the table: "arya_samaj"
  """
  update_arya_samaj("sets the columns of the filtered rows to the given values" _set: arya_samaj_set_input, "filter the rows which have to be updated" where: arya_samaj_bool_exp!): arya_samaj_mutation_response

  """
  update single row of the table: "arya_samaj"
  """
  update_arya_samaj_by_pk("sets the columns of the filtered rows to the given values" _set: arya_samaj_set_input, pk_columns: arya_samaj_pk_columns_input!): arya_samaj

  """
  update multiples rows of table: "arya_samaj"
  """
  update_arya_samaj_many("updates to execute, in order" updates: [arya_samaj_updates!]!): [arya_samaj_mutation_response]

  """
  update data of the table: "book_orders"
  """
  update_book_orders("sets the columns of the filtered rows to the given values" _set: book_orders_set_input, "filter the rows which have to be updated" where: book_orders_bool_exp!): book_orders_mutation_response

  """
  update single row of the table: "book_orders"
  """
  update_book_orders_by_pk("sets the columns of the filtered rows to the given values" _set: book_orders_set_input, pk_columns: book_orders_pk_columns_input!): book_orders

  """
  update multiples rows of table: "book_orders"
  """
  update_book_orders_many("updates to execute, in order" updates: [book_orders_updates!]!): [book_orders_mutation_response]

  """
  update data of the table: "course_registrations"
  """
  update_course_registrations("sets the columns of the filtered rows to the given values" _set: course_registrations_set_input, "filter the rows which have to be updated" where: course_registrations_bool_exp!): course_registrations_mutation_response

  """
  update single row of the table: "course_registrations"
  """
  update_course_registrations_by_pk("sets the columns of the filtered rows to the given values" _set: course_registrations_set_input, pk_columns: course_registrations_pk_columns_input!): course_registrations

  """
  update multiples rows of table: "course_registrations"
  """
  update_course_registrations_many("updates to execute, in order" updates: [course_registrations_updates!]!): [course_registrations_mutation_response]

  """
  update data of the table: "family"
  """
  update_family("sets the columns of the filtered rows to the given values" _set: family_set_input, "filter the rows which have to be updated" where: family_bool_exp!): family_mutation_response

  """
  update single row of the table: "family"
  """
  update_family_by_pk("sets the columns of the filtered rows to the given values" _set: family_set_input, pk_columns: family_pk_columns_input!): family

  """
  update multiples rows of table: "family"
  """
  update_family_many("updates to execute, in order" updates: [family_updates!]!): [family_mutation_response]

  """
  update data of the table: "family_member"
  """
  update_family_member("sets the columns of the filtered rows to the given values" _set: family_member_set_input, "filter the rows which have to be updated" where: family_member_bool_exp!): family_member_mutation_response

  """
  update single row of the table: "family_member"
  """
  update_family_member_by_pk("sets the columns of the filtered rows to the given values" _set: family_member_set_input, pk_columns: family_member_pk_columns_input!): family_member

  """
  update multiples rows of table: "family_member"
  """
  update_family_member_many("updates to execute, in order" updates: [family_member_updates!]!): [family_member_mutation_response]

  """
  update data of the table: "family_relation"
  """
  update_family_relation("sets the columns of the filtered rows to the given values" _set: family_relation_set_input, "filter the rows which have to be updated" where: family_relation_bool_exp!): family_relation_mutation_response

  """
  update single row of the table: "family_relation"
  """
  update_family_relation_by_pk("sets the columns of the filtered rows to the given values" _set: family_relation_set_input, pk_columns: family_relation_pk_columns_input!): family_relation

  """
  update multiples rows of table: "family_relation"
  """
  update_family_relation_many("updates to execute, in order" updates: [family_relation_updates!]!): [family_relation_mutation_response]

  """
  update data of the table: "gender_filter"
  """
  update_gender_filter("sets the columns of the filtered rows to the given values" _set: gender_filter_set_input, "filter the rows which have to be updated" where: gender_filter_bool_exp!): gender_filter_mutation_response

  """
  update single row of the table: "gender_filter"
  """
  update_gender_filter_by_pk("sets the columns of the filtered rows to the given values" _set: gender_filter_set_input, pk_columns: gender_filter_pk_columns_input!): gender_filter

  """
  update multiples rows of table: "gender_filter"
  """
  update_gender_filter_many("updates to execute, in order" updates: [gender_filter_updates!]!): [gender_filter_mutation_response]

  """
  update data of the table: "learning"
  """
  update_learning("sets the columns of the filtered rows to the given values" _set: learning_set_input, "filter the rows which have to be updated" where: learning_bool_exp!): learning_mutation_response

  """
  update single row of the table: "learning"
  """
  update_learning_by_pk("sets the columns of the filtered rows to the given values" _set: learning_set_input, pk_columns: learning_pk_columns_input!): learning

  """
  update multiples rows of table: "learning"
  """
  update_learning_many("updates to execute, in order" updates: [learning_updates!]!): [learning_mutation_response]

  """
  update data of the table: "member"
  """
  update_member("sets the columns of the filtered rows to the given values" _set: member_set_input, "filter the rows which have to be updated" where: member_bool_exp!): member_mutation_response

  """
  update single row of the table: "member"
  """
  update_member_by_pk("sets the columns of the filtered rows to the given values" _set: member_set_input, pk_columns: member_pk_columns_input!): member

  """
  update multiples rows of table: "member"
  """
  update_member_many("updates to execute, in order" updates: [member_updates!]!): [member_mutation_response]

  """
  update data of the table: "organisation"
  """
  update_organisation("increments the numeric columns with given value of the filtered values" _inc: organisation_inc_input, "sets the columns of the filtered rows to the given values" _set: organisation_set_input, "filter the rows which have to be updated" where: organisation_bool_exp!): organisation_mutation_response

  """
  update single row of the table: "organisation"
  """
  update_organisation_by_pk("increments the numeric columns with given value of the filtered values" _inc: organisation_inc_input, "sets the columns of the filtered rows to the given values" _set: organisation_set_input, pk_columns: organisation_pk_columns_input!): organisation

  """
  update multiples rows of table: "organisation"
  """
  update_organisation_many("updates to execute, in order" updates: [organisation_updates!]!): [organisation_mutation_response]

  """
  update data of the table: "organisational_activity"
  """
  update_organisational_activity("sets the columns of the filtered rows to the given values" _set: organisational_activity_set_input, "filter the rows which have to be updated" where: organisational_activity_bool_exp!): organisational_activity_mutation_response

  """
  update single row of the table: "organisational_activity"
  """
  update_organisational_activity_by_pk("sets the columns of the filtered rows to the given values" _set: organisational_activity_set_input, pk_columns: organisational_activity_pk_columns_input!): organisational_activity

  """
  update multiples rows of table: "organisational_activity"
  """
  update_organisational_activity_many("updates to execute, in order" updates: [organisational_activity_updates!]!): [organisational_activity_mutation_response]

  """
  update data of the table: "organisational_member"
  """
  update_organisational_member("increments the numeric columns with given value of the filtered values" _inc: organisational_member_inc_input, "sets the columns of the filtered rows to the given values" _set: organisational_member_set_input, "filter the rows which have to be updated" where: organisational_member_bool_exp!): organisational_member_mutation_response

  """
  update single row of the table: "organisational_member"
  """
  update_organisational_member_by_pk("increments the numeric columns with given value of the filtered values" _inc: organisational_member_inc_input, "sets the columns of the filtered rows to the given values" _set: organisational_member_set_input, pk_columns: organisational_member_pk_columns_input!): organisational_member

  """
  update multiples rows of table: "organisational_member"
  """
  update_organisational_member_many("updates to execute, in order" updates: [organisational_member_updates!]!): [organisational_member_mutation_response]

  """
  update data of the table: "samaj_member"
  """
  update_samaj_member("increments the numeric columns with given value of the filtered values" _inc: samaj_member_inc_input, "sets the columns of the filtered rows to the given values" _set: samaj_member_set_input, "filter the rows which have to be updated" where: samaj_member_bool_exp!): samaj_member_mutation_response

  """
  update single row of the table: "samaj_member"
  """
  update_samaj_member_by_pk("increments the numeric columns with given value of the filtered values" _inc: samaj_member_inc_input, "sets the columns of the filtered rows to the given values" _set: samaj_member_set_input, pk_columns: samaj_member_pk_columns_input!): samaj_member

  """
  update multiples rows of table: "samaj_member"
  """
  update_samaj_member_many("updates to execute, in order" updates: [samaj_member_updates!]!): [samaj_member_mutation_response]

  """
  update data of the table: "satr_registration"
  """
  update_satr_registration("sets the columns of the filtered rows to the given values" _set: satr_registration_set_input, "filter the rows which have to be updated" where: satr_registration_bool_exp!): satr_registration_mutation_response

  """
  update single row of the table: "satr_registration"
  """
  update_satr_registration_by_pk("sets the columns of the filtered rows to the given values" _set: satr_registration_set_input, pk_columns: satr_registration_pk_columns_input!): satr_registration

  """
  update multiples rows of table: "satr_registration"
  """
  update_satr_registration_many("updates to execute, in order" updates: [satr_registration_updates!]!): [satr_registration_mutation_response]
}

"""
column ordering options
"""
enum order_by {
  """
  in ascending order, nulls last
  """
  asc

  """
  in ascending order, nulls first
  """
  asc_nulls_first

  """
  in ascending order, nulls last
  """
  asc_nulls_last

  """
  in descending order, nulls first
  """
  desc

  """
  in descending order, nulls first
  """
  desc_nulls_first

  """
  in descending order, nulls last
  """
  desc_nulls_last
}

"""
columns and relationships of "organisation"
"""
type organisation {
  description: String!

  id: String!

  logo: String

  name: String!

  """
  An array relationship
  """
  organisational_activities("distinct select on columns" distinct_on: [organisational_activity_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [organisational_activity_order_by!], "filter the rows returned" where: organisational_activity_bool_exp): [organisational_activity!]!

  """
  An aggregate relationship
  """
  organisational_activities_aggregate("distinct select on columns" distinct_on: [organisational_activity_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [organisational_activity_order_by!], "filter the rows returned" where: organisational_activity_bool_exp): organisational_activity_aggregate!

  """
  An array relationship
  """
  organisational_members("distinct select on columns" distinct_on: [organisational_member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [organisational_member_order_by!], "filter the rows returned" where: organisational_member_bool_exp): [organisational_member!]!

  """
  An aggregate relationship
  """
  organisational_members_aggregate("distinct select on columns" distinct_on: [organisational_member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [organisational_member_order_by!], "filter the rows returned" where: organisational_member_bool_exp): organisational_member_aggregate!

  priority: smallint!
}

"""
aggregated selection of "organisation"
"""
type organisation_aggregate {
  aggregate: organisation_aggregate_fields

  nodes: [organisation!]!
}

"""
aggregate fields of "organisation"
"""
type organisation_aggregate_fields {
  avg: organisation_avg_fields

  count(columns: [organisation_select_column!], distinct: Boolean): Int!

  max: organisation_max_fields

  min: organisation_min_fields

  stddev: organisation_stddev_fields

  stddev_pop: organisation_stddev_pop_fields

  stddev_samp: organisation_stddev_samp_fields

  sum: organisation_sum_fields

  var_pop: organisation_var_pop_fields

  var_samp: organisation_var_samp_fields

  variance: organisation_variance_fields
}

"""
aggregate avg on columns
"""
type organisation_avg_fields {
  priority: Float
}

"""
Boolean expression to filter rows from the table "organisation". All fields are combined with a logical 'AND'.
"""
input organisation_bool_exp {
  _and: [organisation_bool_exp!]

  _not: organisation_bool_exp

  _or: [organisation_bool_exp!]

  description: String_comparison_exp

  id: String_comparison_exp

  logo: String_comparison_exp

  name: String_comparison_exp

  organisational_activities: organisational_activity_bool_exp

  organisational_activities_aggregate: organisational_activity_aggregate_bool_exp

  organisational_members: organisational_member_bool_exp

  organisational_members_aggregate: organisational_member_aggregate_bool_exp

  priority: smallint_comparison_exp
}

"""
unique or primary key constraints on table "organisation"
"""
enum organisation_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  organisation_pkey
}

"""
input type for incrementing numeric columns in table "organisation"
"""
input organisation_inc_input {
  priority: smallint
}

"""
input type for inserting data into table "organisation"
"""
input organisation_insert_input {
  description: String

  id: String

  logo: String

  name: String

  organisational_activities: organisational_activity_arr_rel_insert_input

  organisational_members: organisational_member_arr_rel_insert_input

  priority: smallint
}

"""
aggregate max on columns
"""
type organisation_max_fields {
  description: String

  id: String

  logo: String

  name: String

  priority: smallint
}

"""
aggregate min on columns
"""
type organisation_min_fields {
  description: String

  id: String

  logo: String

  name: String

  priority: smallint
}

"""
response of any mutation on the table "organisation"
"""
type organisation_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [organisation!]!
}

"""
input type for inserting object relation for remote table "organisation"
"""
input organisation_obj_rel_insert_input {
  data: organisation_insert_input!

  """
  upsert condition
  """
  on_conflict: organisation_on_conflict
}

"""
on_conflict condition type for table "organisation"
"""
input organisation_on_conflict {
  constraint: organisation_constraint!

  update_columns: [organisation_update_column!]! = []

  where: organisation_bool_exp
}

"""
Ordering options when selecting data from "organisation".
"""
input organisation_order_by {
  description: order_by

  id: order_by

  logo: order_by

  name: order_by

  organisational_activities_aggregate: organisational_activity_aggregate_order_by

  organisational_members_aggregate: organisational_member_aggregate_order_by

  priority: order_by
}

"""
primary key columns input for table: organisation
"""
input organisation_pk_columns_input {
  id: String!
}

"""
select columns of table "organisation"
"""
enum organisation_select_column {
  """
  column name
  """
  description

  """
  column name
  """
  id

  """
  column name
  """
  logo

  """
  column name
  """
  name

  """
  column name
  """
  priority
}

"""
input type for updating data in table "organisation"
"""
input organisation_set_input {
  description: String

  id: String

  logo: String

  name: String

  priority: smallint
}

"""
aggregate stddev on columns
"""
type organisation_stddev_fields {
  priority: Float
}

"""
aggregate stddev_pop on columns
"""
type organisation_stddev_pop_fields {
  priority: Float
}

"""
aggregate stddev_samp on columns
"""
type organisation_stddev_samp_fields {
  priority: Float
}

"""
Streaming cursor of the table "organisation"
"""
input organisation_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: organisation_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input organisation_stream_cursor_value_input {
  description: String

  id: String

  logo: String

  name: String

  priority: smallint
}

"""
aggregate sum on columns
"""
type organisation_sum_fields {
  priority: smallint
}

"""
update columns of table "organisation"
"""
enum organisation_update_column {
  """
  column name
  """
  description

  """
  column name
  """
  id

  """
  column name
  """
  logo

  """
  column name
  """
  name

  """
  column name
  """
  priority
}

input organisation_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: organisation_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: organisation_set_input

  """
  filter the rows which have to be updated
  """
  where: organisation_bool_exp!
}

"""
aggregate var_pop on columns
"""
type organisation_var_pop_fields {
  priority: Float
}

"""
aggregate var_samp on columns
"""
type organisation_var_samp_fields {
  priority: Float
}

"""
aggregate variance on columns
"""
type organisation_variance_fields {
  priority: Float
}

"""
columns and relationships of "organisational_activity"
"""
type organisational_activity {
  """
  An object relationship
  """
  activity: activities!

  activity_id: String!

  id: String!

  """
  An object relationship
  """
  organisation: organisation!

  organisation_id: String!
}

"""
aggregated selection of "organisational_activity"
"""
type organisational_activity_aggregate {
  aggregate: organisational_activity_aggregate_fields

  nodes: [organisational_activity!]!
}

input organisational_activity_aggregate_bool_exp {
  count: organisational_activity_aggregate_bool_exp_count
}

input organisational_activity_aggregate_bool_exp_count {
  arguments: [organisational_activity_select_column!]

  distinct: Boolean

  filter: organisational_activity_bool_exp

  predicate: Int_comparison_exp!
}

"""
aggregate fields of "organisational_activity"
"""
type organisational_activity_aggregate_fields {
  count(columns: [organisational_activity_select_column!], distinct: Boolean): Int!

  max: organisational_activity_max_fields

  min: organisational_activity_min_fields
}

"""
order by aggregate values of table "organisational_activity"
"""
input organisational_activity_aggregate_order_by {
  count: order_by

  max: organisational_activity_max_order_by

  min: organisational_activity_min_order_by
}

"""
input type for inserting array relation for remote table "organisational_activity"
"""
input organisational_activity_arr_rel_insert_input {
  data: [organisational_activity_insert_input!]!

  """
  upsert condition
  """
  on_conflict: organisational_activity_on_conflict
}

"""
Boolean expression to filter rows from the table "organisational_activity". All fields are combined with a logical 'AND'.
"""
input organisational_activity_bool_exp {
  _and: [organisational_activity_bool_exp!]

  _not: organisational_activity_bool_exp

  _or: [organisational_activity_bool_exp!]

  activity: activities_bool_exp

  activity_id: String_comparison_exp

  id: String_comparison_exp

  organisation: organisation_bool_exp

  organisation_id: String_comparison_exp
}

"""
unique or primary key constraints on table "organisational_activity"
"""
enum organisational_activity_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  organisational_activity_pkey
}

"""
input type for inserting data into table "organisational_activity"
"""
input organisational_activity_insert_input {
  activity: activities_obj_rel_insert_input

  activity_id: String

  id: String

  organisation: organisation_obj_rel_insert_input

  organisation_id: String
}

"""
aggregate max on columns
"""
type organisational_activity_max_fields {
  activity_id: String

  id: String

  organisation_id: String
}

"""
order by max() on columns of table "organisational_activity"
"""
input organisational_activity_max_order_by {
  activity_id: order_by

  id: order_by

  organisation_id: order_by
}

"""
aggregate min on columns
"""
type organisational_activity_min_fields {
  activity_id: String

  id: String

  organisation_id: String
}

"""
order by min() on columns of table "organisational_activity"
"""
input organisational_activity_min_order_by {
  activity_id: order_by

  id: order_by

  organisation_id: order_by
}

"""
response of any mutation on the table "organisational_activity"
"""
type organisational_activity_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [organisational_activity!]!
}

"""
on_conflict condition type for table "organisational_activity"
"""
input organisational_activity_on_conflict {
  constraint: organisational_activity_constraint!

  update_columns: [organisational_activity_update_column!]! = []

  where: organisational_activity_bool_exp
}

"""
Ordering options when selecting data from "organisational_activity".
"""
input organisational_activity_order_by {
  activity: activities_order_by

  activity_id: order_by

  id: order_by

  organisation: organisation_order_by

  organisation_id: order_by
}

"""
primary key columns input for table: organisational_activity
"""
input organisational_activity_pk_columns_input {
  id: String!
}

"""
select columns of table "organisational_activity"
"""
enum organisational_activity_select_column {
  """
  column name
  """
  activity_id

  """
  column name
  """
  id

  """
  column name
  """
  organisation_id
}

"""
input type for updating data in table "organisational_activity"
"""
input organisational_activity_set_input {
  activity_id: String

  id: String

  organisation_id: String
}

"""
Streaming cursor of the table "organisational_activity"
"""
input organisational_activity_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: organisational_activity_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input organisational_activity_stream_cursor_value_input {
  activity_id: String

  id: String

  organisation_id: String
}

"""
update columns of table "organisational_activity"
"""
enum organisational_activity_update_column {
  """
  column name
  """
  activity_id

  """
  column name
  """
  id

  """
  column name
  """
  organisation_id
}

input organisational_activity_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: organisational_activity_set_input

  """
  filter the rows which have to be updated
  """
  where: organisational_activity_bool_exp!
}

"""
columns and relationships of "organisational_member"
"""
type organisational_member {
  id: String!

  """
  An object relationship
  """
  member: member!

  member_id: String!

  """
  An object relationship
  """
  organisation: organisation!

  organisation_id: String!

  post: String

  priority: smallint!
}

"""
aggregated selection of "organisational_member"
"""
type organisational_member_aggregate {
  aggregate: organisational_member_aggregate_fields

  nodes: [organisational_member!]!
}

input organisational_member_aggregate_bool_exp {
  count: organisational_member_aggregate_bool_exp_count
}

input organisational_member_aggregate_bool_exp_count {
  arguments: [organisational_member_select_column!]

  distinct: Boolean

  filter: organisational_member_bool_exp

  predicate: Int_comparison_exp!
}

"""
aggregate fields of "organisational_member"
"""
type organisational_member_aggregate_fields {
  avg: organisational_member_avg_fields

  count(columns: [organisational_member_select_column!], distinct: Boolean): Int!

  max: organisational_member_max_fields

  min: organisational_member_min_fields

  stddev: organisational_member_stddev_fields

  stddev_pop: organisational_member_stddev_pop_fields

  stddev_samp: organisational_member_stddev_samp_fields

  sum: organisational_member_sum_fields

  var_pop: organisational_member_var_pop_fields

  var_samp: organisational_member_var_samp_fields

  variance: organisational_member_variance_fields
}

"""
order by aggregate values of table "organisational_member"
"""
input organisational_member_aggregate_order_by {
  avg: organisational_member_avg_order_by

  count: order_by

  max: organisational_member_max_order_by

  min: organisational_member_min_order_by

  stddev: organisational_member_stddev_order_by

  stddev_pop: organisational_member_stddev_pop_order_by

  stddev_samp: organisational_member_stddev_samp_order_by

  sum: organisational_member_sum_order_by

  var_pop: organisational_member_var_pop_order_by

  var_samp: organisational_member_var_samp_order_by

  variance: organisational_member_variance_order_by
}

"""
input type for inserting array relation for remote table "organisational_member"
"""
input organisational_member_arr_rel_insert_input {
  data: [organisational_member_insert_input!]!

  """
  upsert condition
  """
  on_conflict: organisational_member_on_conflict
}

"""
aggregate avg on columns
"""
type organisational_member_avg_fields {
  priority: Float
}

"""
order by avg() on columns of table "organisational_member"
"""
input organisational_member_avg_order_by {
  priority: order_by
}

"""
Boolean expression to filter rows from the table "organisational_member". All fields are combined with a logical 'AND'.
"""
input organisational_member_bool_exp {
  _and: [organisational_member_bool_exp!]

  _not: organisational_member_bool_exp

  _or: [organisational_member_bool_exp!]

  id: String_comparison_exp

  member: member_bool_exp

  member_id: String_comparison_exp

  organisation: organisation_bool_exp

  organisation_id: String_comparison_exp

  post: String_comparison_exp

  priority: smallint_comparison_exp
}

"""
unique or primary key constraints on table "organisational_member"
"""
enum organisational_member_constraint {
  """
  unique or primary key constraint on columns "member_id", "id", "organisation_id"
  """
  organisational_member_pkey
}

"""
input type for incrementing numeric columns in table "organisational_member"
"""
input organisational_member_inc_input {
  priority: smallint
}

"""
input type for inserting data into table "organisational_member"
"""
input organisational_member_insert_input {
  id: String

  member: member_obj_rel_insert_input

  member_id: String

  organisation: organisation_obj_rel_insert_input

  organisation_id: String

  post: String

  priority: smallint
}

"""
aggregate max on columns
"""
type organisational_member_max_fields {
  id: String

  member_id: String

  organisation_id: String

  post: String

  priority: smallint
}

"""
order by max() on columns of table "organisational_member"
"""
input organisational_member_max_order_by {
  id: order_by

  member_id: order_by

  organisation_id: order_by

  post: order_by

  priority: order_by
}

"""
aggregate min on columns
"""
type organisational_member_min_fields {
  id: String

  member_id: String

  organisation_id: String

  post: String

  priority: smallint
}

"""
order by min() on columns of table "organisational_member"
"""
input organisational_member_min_order_by {
  id: order_by

  member_id: order_by

  organisation_id: order_by

  post: order_by

  priority: order_by
}

"""
response of any mutation on the table "organisational_member"
"""
type organisational_member_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [organisational_member!]!
}

"""
on_conflict condition type for table "organisational_member"
"""
input organisational_member_on_conflict {
  constraint: organisational_member_constraint!

  update_columns: [organisational_member_update_column!]! = []

  where: organisational_member_bool_exp
}

"""
Ordering options when selecting data from "organisational_member".
"""
input organisational_member_order_by {
  id: order_by

  member: member_order_by

  member_id: order_by

  organisation: organisation_order_by

  organisation_id: order_by

  post: order_by

  priority: order_by
}

"""
primary key columns input for table: organisational_member
"""
input organisational_member_pk_columns_input {
  id: String!

  member_id: String!

  organisation_id: String!
}

"""
select columns of table "organisational_member"
"""
enum organisational_member_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  member_id

  """
  column name
  """
  organisation_id

  """
  column name
  """
  post

  """
  column name
  """
  priority
}

"""
input type for updating data in table "organisational_member"
"""
input organisational_member_set_input {
  id: String

  member_id: String

  organisation_id: String

  post: String

  priority: smallint
}

"""
aggregate stddev on columns
"""
type organisational_member_stddev_fields {
  priority: Float
}

"""
order by stddev() on columns of table "organisational_member"
"""
input organisational_member_stddev_order_by {
  priority: order_by
}

"""
aggregate stddev_pop on columns
"""
type organisational_member_stddev_pop_fields {
  priority: Float
}

"""
order by stddev_pop() on columns of table "organisational_member"
"""
input organisational_member_stddev_pop_order_by {
  priority: order_by
}

"""
aggregate stddev_samp on columns
"""
type organisational_member_stddev_samp_fields {
  priority: Float
}

"""
order by stddev_samp() on columns of table "organisational_member"
"""
input organisational_member_stddev_samp_order_by {
  priority: order_by
}

"""
Streaming cursor of the table "organisational_member"
"""
input organisational_member_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: organisational_member_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input organisational_member_stream_cursor_value_input {
  id: String

  member_id: String

  organisation_id: String

  post: String

  priority: smallint
}

"""
aggregate sum on columns
"""
type organisational_member_sum_fields {
  priority: smallint
}

"""
order by sum() on columns of table "organisational_member"
"""
input organisational_member_sum_order_by {
  priority: order_by
}

"""
update columns of table "organisational_member"
"""
enum organisational_member_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  member_id

  """
  column name
  """
  organisation_id

  """
  column name
  """
  post

  """
  column name
  """
  priority
}

input organisational_member_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: organisational_member_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: organisational_member_set_input

  """
  filter the rows which have to be updated
  """
  where: organisational_member_bool_exp!
}

"""
aggregate var_pop on columns
"""
type organisational_member_var_pop_fields {
  priority: Float
}

"""
order by var_pop() on columns of table "organisational_member"
"""
input organisational_member_var_pop_order_by {
  priority: order_by
}

"""
aggregate var_samp on columns
"""
type organisational_member_var_samp_fields {
  priority: Float
}

"""
order by var_samp() on columns of table "organisational_member"
"""
input organisational_member_var_samp_order_by {
  priority: order_by
}

"""
aggregate variance on columns
"""
type organisational_member_variance_fields {
  priority: Float
}

"""
order by variance() on columns of table "organisational_member"
"""
input organisational_member_variance_order_by {
  priority: order_by
}

type query_root {
  """
  An array relationship
  """
  activities("distinct select on columns" distinct_on: [activities_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [activities_order_by!], "filter the rows returned" where: activities_bool_exp): [activities!]!

  """
  An aggregate relationship
  """
  activities_aggregate("distinct select on columns" distinct_on: [activities_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [activities_order_by!], "filter the rows returned" where: activities_bool_exp): activities_aggregate!

  """
  fetch data from the table: "activities" using primary key columns
  """
  activities_by_pk(id: String!): activities

  """
  fetch data from the table: "activity_member"
  """
  activity_member("distinct select on columns" distinct_on: [activity_member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [activity_member_order_by!], "filter the rows returned" where: activity_member_bool_exp): [activity_member!]!

  """
  fetch aggregated fields from the table: "activity_member"
  """
  activity_member_aggregate("distinct select on columns" distinct_on: [activity_member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [activity_member_order_by!], "filter the rows returned" where: activity_member_bool_exp): activity_member_aggregate!

  """
  fetch data from the table: "activity_member" using primary key columns
  """
  activity_member_by_pk(id: uuid!): activity_member

  """
  fetch data from the table: "activity_type"
  """
  activity_type("distinct select on columns" distinct_on: [activity_type_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [activity_type_order_by!], "filter the rows returned" where: activity_type_bool_exp): [activity_type!]!

  """
  fetch aggregated fields from the table: "activity_type"
  """
  activity_type_aggregate("distinct select on columns" distinct_on: [activity_type_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [activity_type_order_by!], "filter the rows returned" where: activity_type_bool_exp): activity_type_aggregate!

  """
  fetch data from the table: "activity_type" using primary key columns
  """
  activity_type_by_pk(value: String!): activity_type

  """
  fetch data from the table: "address"
  """
  address("distinct select on columns" distinct_on: [address_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [address_order_by!], "filter the rows returned" where: address_bool_exp): [address!]!

  """
  fetch aggregated fields from the table: "address"
  """
  address_aggregate("distinct select on columns" distinct_on: [address_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [address_order_by!], "filter the rows returned" where: address_bool_exp): address_aggregate!

  """
  fetch data from the table: "address" using primary key columns
  """
  address_by_pk(id: String!): address

  """
  fetch data from the table: "admission"
  """
  admission("distinct select on columns" distinct_on: [admission_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [admission_order_by!], "filter the rows returned" where: admission_bool_exp): [admission!]!

  """
  fetch aggregated fields from the table: "admission"
  """
  admission_aggregate("distinct select on columns" distinct_on: [admission_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [admission_order_by!], "filter the rows returned" where: admission_bool_exp): admission_aggregate!

  """
  fetch data from the table: "admission" using primary key columns
  """
  admission_by_pk(id: String!): admission

  """
  fetch data from the table: "app_labels"
  """
  app_labels("distinct select on columns" distinct_on: [app_labels_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [app_labels_order_by!], "filter the rows returned" where: app_labels_bool_exp): [app_labels!]!

  """
  fetch aggregated fields from the table: "app_labels"
  """
  app_labels_aggregate("distinct select on columns" distinct_on: [app_labels_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [app_labels_order_by!], "filter the rows returned" where: app_labels_bool_exp): app_labels_aggregate!

  """
  fetch data from the table: "app_labels" using primary key columns
  """
  app_labels_by_pk(id: uuid!): app_labels

  """
  fetch data from the table: "arya_samaj"
  """
  arya_samaj("distinct select on columns" distinct_on: [arya_samaj_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [arya_samaj_order_by!], "filter the rows returned" where: arya_samaj_bool_exp): [arya_samaj!]!

  """
  fetch aggregated fields from the table: "arya_samaj"
  """
  arya_samaj_aggregate("distinct select on columns" distinct_on: [arya_samaj_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [arya_samaj_order_by!], "filter the rows returned" where: arya_samaj_bool_exp): arya_samaj_aggregate!

  """
  fetch data from the table: "arya_samaj" using primary key columns
  """
  arya_samaj_by_pk(id: String!): arya_samaj

  """
  fetch data from the table: "arya_samaj_with_address"
  """
  arya_samaj_with_address("distinct select on columns" distinct_on: [arya_samaj_with_address_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [arya_samaj_with_address_order_by!], "filter the rows returned" where: arya_samaj_with_address_bool_exp): [arya_samaj_with_address!]!

  """
  fetch aggregated fields from the table: "arya_samaj_with_address"
  """
  arya_samaj_with_address_aggregate("distinct select on columns" distinct_on: [arya_samaj_with_address_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [arya_samaj_with_address_order_by!], "filter the rows returned" where: arya_samaj_with_address_bool_exp): arya_samaj_with_address_aggregate!

  """
  fetch data from the table: "book_orders"
  """
  book_orders("distinct select on columns" distinct_on: [book_orders_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [book_orders_order_by!], "filter the rows returned" where: book_orders_bool_exp): [book_orders!]!

  """
  fetch aggregated fields from the table: "book_orders"
  """
  book_orders_aggregate("distinct select on columns" distinct_on: [book_orders_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [book_orders_order_by!], "filter the rows returned" where: book_orders_bool_exp): book_orders_aggregate!

  """
  fetch data from the table: "book_orders" using primary key columns
  """
  book_orders_by_pk(id: uuid!): book_orders

  """
  An array relationship
  """
  course_registrations("distinct select on columns" distinct_on: [course_registrations_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [course_registrations_order_by!], "filter the rows returned" where: course_registrations_bool_exp): [course_registrations!]!

  """
  An aggregate relationship
  """
  course_registrations_aggregate("distinct select on columns" distinct_on: [course_registrations_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [course_registrations_order_by!], "filter the rows returned" where: course_registrations_bool_exp): course_registrations_aggregate!

  """
  fetch data from the table: "course_registrations" using primary key columns
  """
  course_registrations_by_pk(id: String!): course_registrations

  """
  fetch data from the table: "family"
  """
  family("distinct select on columns" distinct_on: [family_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [family_order_by!], "filter the rows returned" where: family_bool_exp): [family!]!

  """
  fetch aggregated fields from the table: "family"
  """
  family_aggregate("distinct select on columns" distinct_on: [family_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [family_order_by!], "filter the rows returned" where: family_bool_exp): family_aggregate!

  """
  fetch data from the table: "family" using primary key columns
  """
  family_by_pk(id: String!): family

  """
  fetch data from the table: "family_member"
  """
  family_member("distinct select on columns" distinct_on: [family_member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [family_member_order_by!], "filter the rows returned" where: family_member_bool_exp): [family_member!]!

  """
  fetch aggregated fields from the table: "family_member"
  """
  family_member_aggregate("distinct select on columns" distinct_on: [family_member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [family_member_order_by!], "filter the rows returned" where: family_member_bool_exp): family_member_aggregate!

  """
  fetch data from the table: "family_member" using primary key columns
  """
  family_member_by_pk(id: String!): family_member

  """
  fetch data from the table: "family_relation"
  """
  family_relation("distinct select on columns" distinct_on: [family_relation_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [family_relation_order_by!], "filter the rows returned" where: family_relation_bool_exp): [family_relation!]!

  """
  fetch aggregated fields from the table: "family_relation"
  """
  family_relation_aggregate("distinct select on columns" distinct_on: [family_relation_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [family_relation_order_by!], "filter the rows returned" where: family_relation_bool_exp): family_relation_aggregate!

  """
  fetch data from the table: "family_relation" using primary key columns
  """
  family_relation_by_pk(value: String!): family_relation

  """
  fetch data from the table: "gender_filter"
  """
  gender_filter("distinct select on columns" distinct_on: [gender_filter_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [gender_filter_order_by!], "filter the rows returned" where: gender_filter_bool_exp): [gender_filter!]!

  """
  fetch aggregated fields from the table: "gender_filter"
  """
  gender_filter_aggregate("distinct select on columns" distinct_on: [gender_filter_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [gender_filter_order_by!], "filter the rows returned" where: gender_filter_bool_exp): gender_filter_aggregate!

  """
  fetch data from the table: "gender_filter" using primary key columns
  """
  gender_filter_by_pk(value: String!): gender_filter

  """
  fetch data from the table: "learning"
  """
  learning("distinct select on columns" distinct_on: [learning_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [learning_order_by!], "filter the rows returned" where: learning_bool_exp): [learning!]!

  """
  fetch aggregated fields from the table: "learning"
  """
  learning_aggregate("distinct select on columns" distinct_on: [learning_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [learning_order_by!], "filter the rows returned" where: learning_bool_exp): learning_aggregate!

  """
  fetch data from the table: "learning" using primary key columns
  """
  learning_by_pk(id: String!): learning

  """
  fetch data from the table: "member"
  """
  member("distinct select on columns" distinct_on: [member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [member_order_by!], "filter the rows returned" where: member_bool_exp): [member!]!

  """
  fetch aggregated fields from the table: "member"
  """
  member_aggregate("distinct select on columns" distinct_on: [member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [member_order_by!], "filter the rows returned" where: member_bool_exp): member_aggregate!

  """
  fetch data from the table: "member" using primary key columns
  """
  member_by_pk(id: String!): member

  """
  fetch data from the table: "member_in_organisation"
  """
  member_in_organisation("distinct select on columns" distinct_on: [member_in_organisation_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [member_in_organisation_order_by!], "filter the rows returned" where: member_in_organisation_bool_exp): [member_in_organisation!]!

  """
  fetch aggregated fields from the table: "member_in_organisation"
  """
  member_in_organisation_aggregate("distinct select on columns" distinct_on: [member_in_organisation_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [member_in_organisation_order_by!], "filter the rows returned" where: member_in_organisation_bool_exp): member_in_organisation_aggregate!

  """
  fetch data from the table: "member_not_in_family"
  """
  member_not_in_family("distinct select on columns" distinct_on: [member_not_in_family_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [member_not_in_family_order_by!], "filter the rows returned" where: member_not_in_family_bool_exp): [member_not_in_family!]!

  """
  fetch aggregated fields from the table: "member_not_in_family"
  """
  member_not_in_family_aggregate("distinct select on columns" distinct_on: [member_not_in_family_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [member_not_in_family_order_by!], "filter the rows returned" where: member_not_in_family_bool_exp): member_not_in_family_aggregate!

  """
  fetch data from the table: "organisation"
  """
  organisation("distinct select on columns" distinct_on: [organisation_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [organisation_order_by!], "filter the rows returned" where: organisation_bool_exp): [organisation!]!

  """
  fetch aggregated fields from the table: "organisation"
  """
  organisation_aggregate("distinct select on columns" distinct_on: [organisation_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [organisation_order_by!], "filter the rows returned" where: organisation_bool_exp): organisation_aggregate!

  """
  fetch data from the table: "organisation" using primary key columns
  """
  organisation_by_pk(id: String!): organisation

  """
  fetch data from the table: "organisational_activity"
  """
  organisational_activity("distinct select on columns" distinct_on: [organisational_activity_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [organisational_activity_order_by!], "filter the rows returned" where: organisational_activity_bool_exp): [organisational_activity!]!

  """
  fetch aggregated fields from the table: "organisational_activity"
  """
  organisational_activity_aggregate("distinct select on columns" distinct_on: [organisational_activity_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [organisational_activity_order_by!], "filter the rows returned" where: organisational_activity_bool_exp): organisational_activity_aggregate!

  """
  fetch data from the table: "organisational_activity" using primary key columns
  """
  organisational_activity_by_pk(id: String!): organisational_activity

  """
  fetch data from the table: "organisational_member"
  """
  organisational_member("distinct select on columns" distinct_on: [organisational_member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [organisational_member_order_by!], "filter the rows returned" where: organisational_member_bool_exp): [organisational_member!]!

  """
  fetch aggregated fields from the table: "organisational_member"
  """
  organisational_member_aggregate("distinct select on columns" distinct_on: [organisational_member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [organisational_member_order_by!], "filter the rows returned" where: organisational_member_bool_exp): organisational_member_aggregate!

  """
  fetch data from the table: "organisational_member" using primary key columns
  """
  organisational_member_by_pk(id: String!, member_id: String!, organisation_id: String!): organisational_member

  """
  fetch data from the table: "samaj_member"
  """
  samaj_member("distinct select on columns" distinct_on: [samaj_member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [samaj_member_order_by!], "filter the rows returned" where: samaj_member_bool_exp): [samaj_member!]!

  """
  fetch aggregated fields from the table: "samaj_member"
  """
  samaj_member_aggregate("distinct select on columns" distinct_on: [samaj_member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [samaj_member_order_by!], "filter the rows returned" where: samaj_member_bool_exp): samaj_member_aggregate!

  """
  fetch data from the table: "samaj_member" using primary key columns
  """
  samaj_member_by_pk(id: String!): samaj_member

  """
  fetch data from the table: "satr_registration"
  """
  satr_registration("distinct select on columns" distinct_on: [satr_registration_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [satr_registration_order_by!], "filter the rows returned" where: satr_registration_bool_exp): [satr_registration!]!

  """
  fetch aggregated fields from the table: "satr_registration"
  """
  satr_registration_aggregate("distinct select on columns" distinct_on: [satr_registration_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [satr_registration_order_by!], "filter the rows returned" where: satr_registration_bool_exp): satr_registration_aggregate!

  """
  fetch data from the table: "satr_registration" using primary key columns
  """
  satr_registration_by_pk(id: uuid!): satr_registration
}

"""
columns and relationships of "samaj_member"
"""
type samaj_member {
  """
  An object relationship
  """
  arya_samaj: arya_samaj

  arya_samaj_id: String

  created_at: timestamptz!

  id: String!

  """
  An object relationship
  """
  member: member

  member_id: String

  post: String

  priority: smallint
}

"""
aggregated selection of "samaj_member"
"""
type samaj_member_aggregate {
  aggregate: samaj_member_aggregate_fields

  nodes: [samaj_member!]!
}

input samaj_member_aggregate_bool_exp {
  count: samaj_member_aggregate_bool_exp_count
}

input samaj_member_aggregate_bool_exp_count {
  arguments: [samaj_member_select_column!]

  distinct: Boolean

  filter: samaj_member_bool_exp

  predicate: Int_comparison_exp!
}

"""
aggregate fields of "samaj_member"
"""
type samaj_member_aggregate_fields {
  avg: samaj_member_avg_fields

  count(columns: [samaj_member_select_column!], distinct: Boolean): Int!

  max: samaj_member_max_fields

  min: samaj_member_min_fields

  stddev: samaj_member_stddev_fields

  stddev_pop: samaj_member_stddev_pop_fields

  stddev_samp: samaj_member_stddev_samp_fields

  sum: samaj_member_sum_fields

  var_pop: samaj_member_var_pop_fields

  var_samp: samaj_member_var_samp_fields

  variance: samaj_member_variance_fields
}

"""
order by aggregate values of table "samaj_member"
"""
input samaj_member_aggregate_order_by {
  avg: samaj_member_avg_order_by

  count: order_by

  max: samaj_member_max_order_by

  min: samaj_member_min_order_by

  stddev: samaj_member_stddev_order_by

  stddev_pop: samaj_member_stddev_pop_order_by

  stddev_samp: samaj_member_stddev_samp_order_by

  sum: samaj_member_sum_order_by

  var_pop: samaj_member_var_pop_order_by

  var_samp: samaj_member_var_samp_order_by

  variance: samaj_member_variance_order_by
}

"""
input type for inserting array relation for remote table "samaj_member"
"""
input samaj_member_arr_rel_insert_input {
  data: [samaj_member_insert_input!]!

  """
  upsert condition
  """
  on_conflict: samaj_member_on_conflict
}

"""
aggregate avg on columns
"""
type samaj_member_avg_fields {
  priority: Float
}

"""
order by avg() on columns of table "samaj_member"
"""
input samaj_member_avg_order_by {
  priority: order_by
}

"""
Boolean expression to filter rows from the table "samaj_member". All fields are combined with a logical 'AND'.
"""
input samaj_member_bool_exp {
  _and: [samaj_member_bool_exp!]

  _not: samaj_member_bool_exp

  _or: [samaj_member_bool_exp!]

  arya_samaj: arya_samaj_bool_exp

  arya_samaj_id: String_comparison_exp

  created_at: timestamptz_comparison_exp

  id: String_comparison_exp

  member: member_bool_exp

  member_id: String_comparison_exp

  post: String_comparison_exp

  priority: smallint_comparison_exp
}

"""
unique or primary key constraints on table "samaj_member"
"""
enum samaj_member_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  samaj_member_pkey
}

"""
input type for incrementing numeric columns in table "samaj_member"
"""
input samaj_member_inc_input {
  priority: smallint
}

"""
input type for inserting data into table "samaj_member"
"""
input samaj_member_insert_input {
  arya_samaj: arya_samaj_obj_rel_insert_input

  arya_samaj_id: String

  created_at: timestamptz

  id: String

  member: member_obj_rel_insert_input

  member_id: String

  post: String

  priority: smallint
}

"""
aggregate max on columns
"""
type samaj_member_max_fields {
  arya_samaj_id: String

  created_at: timestamptz

  id: String

  member_id: String

  post: String

  priority: smallint
}

"""
order by max() on columns of table "samaj_member"
"""
input samaj_member_max_order_by {
  arya_samaj_id: order_by

  created_at: order_by

  id: order_by

  member_id: order_by

  post: order_by

  priority: order_by
}

"""
aggregate min on columns
"""
type samaj_member_min_fields {
  arya_samaj_id: String

  created_at: timestamptz

  id: String

  member_id: String

  post: String

  priority: smallint
}

"""
order by min() on columns of table "samaj_member"
"""
input samaj_member_min_order_by {
  arya_samaj_id: order_by

  created_at: order_by

  id: order_by

  member_id: order_by

  post: order_by

  priority: order_by
}

"""
response of any mutation on the table "samaj_member"
"""
type samaj_member_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [samaj_member!]!
}

"""
on_conflict condition type for table "samaj_member"
"""
input samaj_member_on_conflict {
  constraint: samaj_member_constraint!

  update_columns: [samaj_member_update_column!]! = []

  where: samaj_member_bool_exp
}

"""
Ordering options when selecting data from "samaj_member".
"""
input samaj_member_order_by {
  arya_samaj: arya_samaj_order_by

  arya_samaj_id: order_by

  created_at: order_by

  id: order_by

  member: member_order_by

  member_id: order_by

  post: order_by

  priority: order_by
}

"""
primary key columns input for table: samaj_member
"""
input samaj_member_pk_columns_input {
  id: String!
}

"""
select columns of table "samaj_member"
"""
enum samaj_member_select_column {
  """
  column name
  """
  arya_samaj_id

  """
  column name
  """
  created_at

  """
  column name
  """
  id

  """
  column name
  """
  member_id

  """
  column name
  """
  post

  """
  column name
  """
  priority
}

"""
input type for updating data in table "samaj_member"
"""
input samaj_member_set_input {
  arya_samaj_id: String

  created_at: timestamptz

  id: String

  member_id: String

  post: String

  priority: smallint
}

"""
aggregate stddev on columns
"""
type samaj_member_stddev_fields {
  priority: Float
}

"""
order by stddev() on columns of table "samaj_member"
"""
input samaj_member_stddev_order_by {
  priority: order_by
}

"""
aggregate stddev_pop on columns
"""
type samaj_member_stddev_pop_fields {
  priority: Float
}

"""
order by stddev_pop() on columns of table "samaj_member"
"""
input samaj_member_stddev_pop_order_by {
  priority: order_by
}

"""
aggregate stddev_samp on columns
"""
type samaj_member_stddev_samp_fields {
  priority: Float
}

"""
order by stddev_samp() on columns of table "samaj_member"
"""
input samaj_member_stddev_samp_order_by {
  priority: order_by
}

"""
Streaming cursor of the table "samaj_member"
"""
input samaj_member_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: samaj_member_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input samaj_member_stream_cursor_value_input {
  arya_samaj_id: String

  created_at: timestamptz

  id: String

  member_id: String

  post: String

  priority: smallint
}

"""
aggregate sum on columns
"""
type samaj_member_sum_fields {
  priority: smallint
}

"""
order by sum() on columns of table "samaj_member"
"""
input samaj_member_sum_order_by {
  priority: order_by
}

"""
update columns of table "samaj_member"
"""
enum samaj_member_update_column {
  """
  column name
  """
  arya_samaj_id

  """
  column name
  """
  created_at

  """
  column name
  """
  id

  """
  column name
  """
  member_id

  """
  column name
  """
  post

  """
  column name
  """
  priority
}

input samaj_member_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: samaj_member_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: samaj_member_set_input

  """
  filter the rows which have to be updated
  """
  where: samaj_member_bool_exp!
}

"""
aggregate var_pop on columns
"""
type samaj_member_var_pop_fields {
  priority: Float
}

"""
order by var_pop() on columns of table "samaj_member"
"""
input samaj_member_var_pop_order_by {
  priority: order_by
}

"""
aggregate var_samp on columns
"""
type samaj_member_var_samp_fields {
  priority: Float
}

"""
order by var_samp() on columns of table "samaj_member"
"""
input samaj_member_var_samp_order_by {
  priority: order_by
}

"""
aggregate variance on columns
"""
type samaj_member_variance_fields {
  priority: Float
}

"""
order by variance() on columns of table "samaj_member"
"""
input samaj_member_variance_order_by {
  priority: order_by
}

"""
columns and relationships of "satr_registration"
"""
type satr_registration {
  aadhar_no: String

  """
  An object relationship
  """
  activity: activities!

  activity_id: String!

  address: String

  created_at: timestamptz!

  educational_qualification: String

  fullname: String!

  gender: String!

  has_trained_arya_in_family: Boolean

  id: uuid!

  inspiration_source: String

  inspiration_source_name: String

  inspiration_source_no: String

  mobile: String!

  trained_arya_name: String

  trained_arya_no: String
}

"""
aggregated selection of "satr_registration"
"""
type satr_registration_aggregate {
  aggregate: satr_registration_aggregate_fields

  nodes: [satr_registration!]!
}

input satr_registration_aggregate_bool_exp {
  bool_and: satr_registration_aggregate_bool_exp_bool_and

  bool_or: satr_registration_aggregate_bool_exp_bool_or

  count: satr_registration_aggregate_bool_exp_count
}

input satr_registration_aggregate_bool_exp_bool_and {
  arguments: satr_registration_select_column_satr_registration_aggregate_bool_exp_bool_and_arguments_columns!

  distinct: Boolean

  filter: satr_registration_bool_exp

  predicate: Boolean_comparison_exp!
}

input satr_registration_aggregate_bool_exp_bool_or {
  arguments: satr_registration_select_column_satr_registration_aggregate_bool_exp_bool_or_arguments_columns!

  distinct: Boolean

  filter: satr_registration_bool_exp

  predicate: Boolean_comparison_exp!
}

input satr_registration_aggregate_bool_exp_count {
  arguments: [satr_registration_select_column!]

  distinct: Boolean

  filter: satr_registration_bool_exp

  predicate: Int_comparison_exp!
}

"""
aggregate fields of "satr_registration"
"""
type satr_registration_aggregate_fields {
  count(columns: [satr_registration_select_column!], distinct: Boolean): Int!

  max: satr_registration_max_fields

  min: satr_registration_min_fields
}

"""
order by aggregate values of table "satr_registration"
"""
input satr_registration_aggregate_order_by {
  count: order_by

  max: satr_registration_max_order_by

  min: satr_registration_min_order_by
}

"""
input type for inserting array relation for remote table "satr_registration"
"""
input satr_registration_arr_rel_insert_input {
  data: [satr_registration_insert_input!]!

  """
  upsert condition
  """
  on_conflict: satr_registration_on_conflict
}

"""
Boolean expression to filter rows from the table "satr_registration". All fields are combined with a logical 'AND'.
"""
input satr_registration_bool_exp {
  _and: [satr_registration_bool_exp!]

  _not: satr_registration_bool_exp

  _or: [satr_registration_bool_exp!]

  aadhar_no: String_comparison_exp

  activity: activities_bool_exp

  activity_id: String_comparison_exp

  address: String_comparison_exp

  created_at: timestamptz_comparison_exp

  educational_qualification: String_comparison_exp

  fullname: String_comparison_exp

  gender: String_comparison_exp

  has_trained_arya_in_family: Boolean_comparison_exp

  id: uuid_comparison_exp

  inspiration_source: String_comparison_exp

  inspiration_source_name: String_comparison_exp

  inspiration_source_no: String_comparison_exp

  mobile: String_comparison_exp

  trained_arya_name: String_comparison_exp

  trained_arya_no: String_comparison_exp
}

"""
unique or primary key constraints on table "satr_registration"
"""
enum satr_registration_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  satr_registration_pkey
}

"""
input type for inserting data into table "satr_registration"
"""
input satr_registration_insert_input {
  aadhar_no: String

  activity: activities_obj_rel_insert_input

  activity_id: String

  address: String

  created_at: timestamptz

  educational_qualification: String

  fullname: String

  gender: String

  has_trained_arya_in_family: Boolean

  id: uuid

  inspiration_source: String

  inspiration_source_name: String

  inspiration_source_no: String

  mobile: String

  trained_arya_name: String

  trained_arya_no: String
}

"""
aggregate max on columns
"""
type satr_registration_max_fields {
  aadhar_no: String

  activity_id: String

  address: String

  created_at: timestamptz

  educational_qualification: String

  fullname: String

  gender: String

  id: uuid

  inspiration_source: String

  inspiration_source_name: String

  inspiration_source_no: String

  mobile: String

  trained_arya_name: String

  trained_arya_no: String
}

"""
order by max() on columns of table "satr_registration"
"""
input satr_registration_max_order_by {
  aadhar_no: order_by

  activity_id: order_by

  address: order_by

  created_at: order_by

  educational_qualification: order_by

  fullname: order_by

  gender: order_by

  id: order_by

  inspiration_source: order_by

  inspiration_source_name: order_by

  inspiration_source_no: order_by

  mobile: order_by

  trained_arya_name: order_by

  trained_arya_no: order_by
}

"""
aggregate min on columns
"""
type satr_registration_min_fields {
  aadhar_no: String

  activity_id: String

  address: String

  created_at: timestamptz

  educational_qualification: String

  fullname: String

  gender: String

  id: uuid

  inspiration_source: String

  inspiration_source_name: String

  inspiration_source_no: String

  mobile: String

  trained_arya_name: String

  trained_arya_no: String
}

"""
order by min() on columns of table "satr_registration"
"""
input satr_registration_min_order_by {
  aadhar_no: order_by

  activity_id: order_by

  address: order_by

  created_at: order_by

  educational_qualification: order_by

  fullname: order_by

  gender: order_by

  id: order_by

  inspiration_source: order_by

  inspiration_source_name: order_by

  inspiration_source_no: order_by

  mobile: order_by

  trained_arya_name: order_by

  trained_arya_no: order_by
}

"""
response of any mutation on the table "satr_registration"
"""
type satr_registration_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [satr_registration!]!
}

"""
on_conflict condition type for table "satr_registration"
"""
input satr_registration_on_conflict {
  constraint: satr_registration_constraint!

  update_columns: [satr_registration_update_column!]! = []

  where: satr_registration_bool_exp
}

"""
Ordering options when selecting data from "satr_registration".
"""
input satr_registration_order_by {
  aadhar_no: order_by

  activity: activities_order_by

  activity_id: order_by

  address: order_by

  created_at: order_by

  educational_qualification: order_by

  fullname: order_by

  gender: order_by

  has_trained_arya_in_family: order_by

  id: order_by

  inspiration_source: order_by

  inspiration_source_name: order_by

  inspiration_source_no: order_by

  mobile: order_by

  trained_arya_name: order_by

  trained_arya_no: order_by
}

"""
primary key columns input for table: satr_registration
"""
input satr_registration_pk_columns_input {
  id: uuid!
}

"""
select columns of table "satr_registration"
"""
enum satr_registration_select_column {
  """
  column name
  """
  aadhar_no

  """
  column name
  """
  activity_id

  """
  column name
  """
  address

  """
  column name
  """
  created_at

  """
  column name
  """
  educational_qualification

  """
  column name
  """
  fullname

  """
  column name
  """
  gender

  """
  column name
  """
  has_trained_arya_in_family

  """
  column name
  """
  id

  """
  column name
  """
  inspiration_source

  """
  column name
  """
  inspiration_source_name

  """
  column name
  """
  inspiration_source_no

  """
  column name
  """
  mobile

  """
  column name
  """
  trained_arya_name

  """
  column name
  """
  trained_arya_no
}

"""
select "satr_registration_aggregate_bool_exp_bool_and_arguments_columns" columns of table "satr_registration"
"""
enum satr_registration_select_column_satr_registration_aggregate_bool_exp_bool_and_arguments_columns {
  """
  column name
  """
  has_trained_arya_in_family
}

"""
select "satr_registration_aggregate_bool_exp_bool_or_arguments_columns" columns of table "satr_registration"
"""
enum satr_registration_select_column_satr_registration_aggregate_bool_exp_bool_or_arguments_columns {
  """
  column name
  """
  has_trained_arya_in_family
}

"""
input type for updating data in table "satr_registration"
"""
input satr_registration_set_input {
  aadhar_no: String

  activity_id: String

  address: String

  created_at: timestamptz

  educational_qualification: String

  fullname: String

  gender: String

  has_trained_arya_in_family: Boolean

  id: uuid

  inspiration_source: String

  inspiration_source_name: String

  inspiration_source_no: String

  mobile: String

  trained_arya_name: String

  trained_arya_no: String
}

"""
Streaming cursor of the table "satr_registration"
"""
input satr_registration_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: satr_registration_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input satr_registration_stream_cursor_value_input {
  aadhar_no: String

  activity_id: String

  address: String

  created_at: timestamptz

  educational_qualification: String

  fullname: String

  gender: String

  has_trained_arya_in_family: Boolean

  id: uuid

  inspiration_source: String

  inspiration_source_name: String

  inspiration_source_no: String

  mobile: String

  trained_arya_name: String

  trained_arya_no: String
}

"""
update columns of table "satr_registration"
"""
enum satr_registration_update_column {
  """
  column name
  """
  aadhar_no

  """
  column name
  """
  activity_id

  """
  column name
  """
  address

  """
  column name
  """
  created_at

  """
  column name
  """
  educational_qualification

  """
  column name
  """
  fullname

  """
  column name
  """
  gender

  """
  column name
  """
  has_trained_arya_in_family

  """
  column name
  """
  id

  """
  column name
  """
  inspiration_source

  """
  column name
  """
  inspiration_source_name

  """
  column name
  """
  inspiration_source_no

  """
  column name
  """
  mobile

  """
  column name
  """
  trained_arya_name

  """
  column name
  """
  trained_arya_no
}

input satr_registration_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: satr_registration_set_input

  """
  filter the rows which have to be updated
  """
  where: satr_registration_bool_exp!
}

scalar smallint

"""
Boolean expression to compare columns of type "smallint". All fields are combined with logical 'AND'.
"""
input smallint_comparison_exp {
  _eq: smallint

  _gt: smallint

  _gte: smallint

  _in: [smallint!]

  _is_null: Boolean

  _lt: smallint

  _lte: smallint

  _neq: smallint

  _nin: [smallint!]
}

type subscription_root {
  """
  An array relationship
  """
  activities("distinct select on columns" distinct_on: [activities_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [activities_order_by!], "filter the rows returned" where: activities_bool_exp): [activities!]!

  """
  An aggregate relationship
  """
  activities_aggregate("distinct select on columns" distinct_on: [activities_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [activities_order_by!], "filter the rows returned" where: activities_bool_exp): activities_aggregate!

  """
  fetch data from the table: "activities" using primary key columns
  """
  activities_by_pk(id: String!): activities

  """
  fetch data from the table in a streaming manner: "activities"
  """
  activities_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [activities_stream_cursor_input]!, "filter the rows returned" where: activities_bool_exp): [activities!]!

  """
  fetch data from the table: "activity_member"
  """
  activity_member("distinct select on columns" distinct_on: [activity_member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [activity_member_order_by!], "filter the rows returned" where: activity_member_bool_exp): [activity_member!]!

  """
  fetch aggregated fields from the table: "activity_member"
  """
  activity_member_aggregate("distinct select on columns" distinct_on: [activity_member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [activity_member_order_by!], "filter the rows returned" where: activity_member_bool_exp): activity_member_aggregate!

  """
  fetch data from the table: "activity_member" using primary key columns
  """
  activity_member_by_pk(id: uuid!): activity_member

  """
  fetch data from the table in a streaming manner: "activity_member"
  """
  activity_member_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [activity_member_stream_cursor_input]!, "filter the rows returned" where: activity_member_bool_exp): [activity_member!]!

  """
  fetch data from the table: "activity_type"
  """
  activity_type("distinct select on columns" distinct_on: [activity_type_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [activity_type_order_by!], "filter the rows returned" where: activity_type_bool_exp): [activity_type!]!

  """
  fetch aggregated fields from the table: "activity_type"
  """
  activity_type_aggregate("distinct select on columns" distinct_on: [activity_type_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [activity_type_order_by!], "filter the rows returned" where: activity_type_bool_exp): activity_type_aggregate!

  """
  fetch data from the table: "activity_type" using primary key columns
  """
  activity_type_by_pk(value: String!): activity_type

  """
  fetch data from the table in a streaming manner: "activity_type"
  """
  activity_type_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [activity_type_stream_cursor_input]!, "filter the rows returned" where: activity_type_bool_exp): [activity_type!]!

  """
  fetch data from the table: "address"
  """
  address("distinct select on columns" distinct_on: [address_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [address_order_by!], "filter the rows returned" where: address_bool_exp): [address!]!

  """
  fetch aggregated fields from the table: "address"
  """
  address_aggregate("distinct select on columns" distinct_on: [address_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [address_order_by!], "filter the rows returned" where: address_bool_exp): address_aggregate!

  """
  fetch data from the table: "address" using primary key columns
  """
  address_by_pk(id: String!): address

  """
  fetch data from the table in a streaming manner: "address"
  """
  address_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [address_stream_cursor_input]!, "filter the rows returned" where: address_bool_exp): [address!]!

  """
  fetch data from the table: "admission"
  """
  admission("distinct select on columns" distinct_on: [admission_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [admission_order_by!], "filter the rows returned" where: admission_bool_exp): [admission!]!

  """
  fetch aggregated fields from the table: "admission"
  """
  admission_aggregate("distinct select on columns" distinct_on: [admission_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [admission_order_by!], "filter the rows returned" where: admission_bool_exp): admission_aggregate!

  """
  fetch data from the table: "admission" using primary key columns
  """
  admission_by_pk(id: String!): admission

  """
  fetch data from the table in a streaming manner: "admission"
  """
  admission_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [admission_stream_cursor_input]!, "filter the rows returned" where: admission_bool_exp): [admission!]!

  """
  fetch data from the table: "app_labels"
  """
  app_labels("distinct select on columns" distinct_on: [app_labels_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [app_labels_order_by!], "filter the rows returned" where: app_labels_bool_exp): [app_labels!]!

  """
  fetch aggregated fields from the table: "app_labels"
  """
  app_labels_aggregate("distinct select on columns" distinct_on: [app_labels_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [app_labels_order_by!], "filter the rows returned" where: app_labels_bool_exp): app_labels_aggregate!

  """
  fetch data from the table: "app_labels" using primary key columns
  """
  app_labels_by_pk(id: uuid!): app_labels

  """
  fetch data from the table in a streaming manner: "app_labels"
  """
  app_labels_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [app_labels_stream_cursor_input]!, "filter the rows returned" where: app_labels_bool_exp): [app_labels!]!

  """
  fetch data from the table: "arya_samaj"
  """
  arya_samaj("distinct select on columns" distinct_on: [arya_samaj_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [arya_samaj_order_by!], "filter the rows returned" where: arya_samaj_bool_exp): [arya_samaj!]!

  """
  fetch aggregated fields from the table: "arya_samaj"
  """
  arya_samaj_aggregate("distinct select on columns" distinct_on: [arya_samaj_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [arya_samaj_order_by!], "filter the rows returned" where: arya_samaj_bool_exp): arya_samaj_aggregate!

  """
  fetch data from the table: "arya_samaj" using primary key columns
  """
  arya_samaj_by_pk(id: String!): arya_samaj

  """
  fetch data from the table in a streaming manner: "arya_samaj"
  """
  arya_samaj_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [arya_samaj_stream_cursor_input]!, "filter the rows returned" where: arya_samaj_bool_exp): [arya_samaj!]!

  """
  fetch data from the table: "arya_samaj_with_address"
  """
  arya_samaj_with_address("distinct select on columns" distinct_on: [arya_samaj_with_address_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [arya_samaj_with_address_order_by!], "filter the rows returned" where: arya_samaj_with_address_bool_exp): [arya_samaj_with_address!]!

  """
  fetch aggregated fields from the table: "arya_samaj_with_address"
  """
  arya_samaj_with_address_aggregate("distinct select on columns" distinct_on: [arya_samaj_with_address_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [arya_samaj_with_address_order_by!], "filter the rows returned" where: arya_samaj_with_address_bool_exp): arya_samaj_with_address_aggregate!

  """
  fetch data from the table in a streaming manner: "arya_samaj_with_address"
  """
  arya_samaj_with_address_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [arya_samaj_with_address_stream_cursor_input]!, "filter the rows returned" where: arya_samaj_with_address_bool_exp): [arya_samaj_with_address!]!

  """
  fetch data from the table: "book_orders"
  """
  book_orders("distinct select on columns" distinct_on: [book_orders_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [book_orders_order_by!], "filter the rows returned" where: book_orders_bool_exp): [book_orders!]!

  """
  fetch aggregated fields from the table: "book_orders"
  """
  book_orders_aggregate("distinct select on columns" distinct_on: [book_orders_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [book_orders_order_by!], "filter the rows returned" where: book_orders_bool_exp): book_orders_aggregate!

  """
  fetch data from the table: "book_orders" using primary key columns
  """
  book_orders_by_pk(id: uuid!): book_orders

  """
  fetch data from the table in a streaming manner: "book_orders"
  """
  book_orders_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [book_orders_stream_cursor_input]!, "filter the rows returned" where: book_orders_bool_exp): [book_orders!]!

  """
  An array relationship
  """
  course_registrations("distinct select on columns" distinct_on: [course_registrations_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [course_registrations_order_by!], "filter the rows returned" where: course_registrations_bool_exp): [course_registrations!]!

  """
  An aggregate relationship
  """
  course_registrations_aggregate("distinct select on columns" distinct_on: [course_registrations_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [course_registrations_order_by!], "filter the rows returned" where: course_registrations_bool_exp): course_registrations_aggregate!

  """
  fetch data from the table: "course_registrations" using primary key columns
  """
  course_registrations_by_pk(id: String!): course_registrations

  """
  fetch data from the table in a streaming manner: "course_registrations"
  """
  course_registrations_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [course_registrations_stream_cursor_input]!, "filter the rows returned" where: course_registrations_bool_exp): [course_registrations!]!

  """
  fetch data from the table: "family"
  """
  family("distinct select on columns" distinct_on: [family_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [family_order_by!], "filter the rows returned" where: family_bool_exp): [family!]!

  """
  fetch aggregated fields from the table: "family"
  """
  family_aggregate("distinct select on columns" distinct_on: [family_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [family_order_by!], "filter the rows returned" where: family_bool_exp): family_aggregate!

  """
  fetch data from the table: "family" using primary key columns
  """
  family_by_pk(id: String!): family

  """
  fetch data from the table: "family_member"
  """
  family_member("distinct select on columns" distinct_on: [family_member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [family_member_order_by!], "filter the rows returned" where: family_member_bool_exp): [family_member!]!

  """
  fetch aggregated fields from the table: "family_member"
  """
  family_member_aggregate("distinct select on columns" distinct_on: [family_member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [family_member_order_by!], "filter the rows returned" where: family_member_bool_exp): family_member_aggregate!

  """
  fetch data from the table: "family_member" using primary key columns
  """
  family_member_by_pk(id: String!): family_member

  """
  fetch data from the table in a streaming manner: "family_member"
  """
  family_member_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [family_member_stream_cursor_input]!, "filter the rows returned" where: family_member_bool_exp): [family_member!]!

  """
  fetch data from the table: "family_relation"
  """
  family_relation("distinct select on columns" distinct_on: [family_relation_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [family_relation_order_by!], "filter the rows returned" where: family_relation_bool_exp): [family_relation!]!

  """
  fetch aggregated fields from the table: "family_relation"
  """
  family_relation_aggregate("distinct select on columns" distinct_on: [family_relation_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [family_relation_order_by!], "filter the rows returned" where: family_relation_bool_exp): family_relation_aggregate!

  """
  fetch data from the table: "family_relation" using primary key columns
  """
  family_relation_by_pk(value: String!): family_relation

  """
  fetch data from the table in a streaming manner: "family_relation"
  """
  family_relation_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [family_relation_stream_cursor_input]!, "filter the rows returned" where: family_relation_bool_exp): [family_relation!]!

  """
  fetch data from the table in a streaming manner: "family"
  """
  family_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [family_stream_cursor_input]!, "filter the rows returned" where: family_bool_exp): [family!]!

  """
  fetch data from the table: "gender_filter"
  """
  gender_filter("distinct select on columns" distinct_on: [gender_filter_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [gender_filter_order_by!], "filter the rows returned" where: gender_filter_bool_exp): [gender_filter!]!

  """
  fetch aggregated fields from the table: "gender_filter"
  """
  gender_filter_aggregate("distinct select on columns" distinct_on: [gender_filter_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [gender_filter_order_by!], "filter the rows returned" where: gender_filter_bool_exp): gender_filter_aggregate!

  """
  fetch data from the table: "gender_filter" using primary key columns
  """
  gender_filter_by_pk(value: String!): gender_filter

  """
  fetch data from the table in a streaming manner: "gender_filter"
  """
  gender_filter_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [gender_filter_stream_cursor_input]!, "filter the rows returned" where: gender_filter_bool_exp): [gender_filter!]!

  """
  fetch data from the table: "learning"
  """
  learning("distinct select on columns" distinct_on: [learning_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [learning_order_by!], "filter the rows returned" where: learning_bool_exp): [learning!]!

  """
  fetch aggregated fields from the table: "learning"
  """
  learning_aggregate("distinct select on columns" distinct_on: [learning_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [learning_order_by!], "filter the rows returned" where: learning_bool_exp): learning_aggregate!

  """
  fetch data from the table: "learning" using primary key columns
  """
  learning_by_pk(id: String!): learning

  """
  fetch data from the table in a streaming manner: "learning"
  """
  learning_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [learning_stream_cursor_input]!, "filter the rows returned" where: learning_bool_exp): [learning!]!

  """
  fetch data from the table: "member"
  """
  member("distinct select on columns" distinct_on: [member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [member_order_by!], "filter the rows returned" where: member_bool_exp): [member!]!

  """
  fetch aggregated fields from the table: "member"
  """
  member_aggregate("distinct select on columns" distinct_on: [member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [member_order_by!], "filter the rows returned" where: member_bool_exp): member_aggregate!

  """
  fetch data from the table: "member" using primary key columns
  """
  member_by_pk(id: String!): member

  """
  fetch data from the table: "member_in_organisation"
  """
  member_in_organisation("distinct select on columns" distinct_on: [member_in_organisation_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [member_in_organisation_order_by!], "filter the rows returned" where: member_in_organisation_bool_exp): [member_in_organisation!]!

  """
  fetch aggregated fields from the table: "member_in_organisation"
  """
  member_in_organisation_aggregate("distinct select on columns" distinct_on: [member_in_organisation_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [member_in_organisation_order_by!], "filter the rows returned" where: member_in_organisation_bool_exp): member_in_organisation_aggregate!

  """
  fetch data from the table in a streaming manner: "member_in_organisation"
  """
  member_in_organisation_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [member_in_organisation_stream_cursor_input]!, "filter the rows returned" where: member_in_organisation_bool_exp): [member_in_organisation!]!

  """
  fetch data from the table: "member_not_in_family"
  """
  member_not_in_family("distinct select on columns" distinct_on: [member_not_in_family_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [member_not_in_family_order_by!], "filter the rows returned" where: member_not_in_family_bool_exp): [member_not_in_family!]!

  """
  fetch aggregated fields from the table: "member_not_in_family"
  """
  member_not_in_family_aggregate("distinct select on columns" distinct_on: [member_not_in_family_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [member_not_in_family_order_by!], "filter the rows returned" where: member_not_in_family_bool_exp): member_not_in_family_aggregate!

  """
  fetch data from the table in a streaming manner: "member_not_in_family"
  """
  member_not_in_family_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [member_not_in_family_stream_cursor_input]!, "filter the rows returned" where: member_not_in_family_bool_exp): [member_not_in_family!]!

  """
  fetch data from the table in a streaming manner: "member"
  """
  member_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [member_stream_cursor_input]!, "filter the rows returned" where: member_bool_exp): [member!]!

  """
  fetch data from the table: "organisation"
  """
  organisation("distinct select on columns" distinct_on: [organisation_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [organisation_order_by!], "filter the rows returned" where: organisation_bool_exp): [organisation!]!

  """
  fetch aggregated fields from the table: "organisation"
  """
  organisation_aggregate("distinct select on columns" distinct_on: [organisation_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [organisation_order_by!], "filter the rows returned" where: organisation_bool_exp): organisation_aggregate!

  """
  fetch data from the table: "organisation" using primary key columns
  """
  organisation_by_pk(id: String!): organisation

  """
  fetch data from the table in a streaming manner: "organisation"
  """
  organisation_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [organisation_stream_cursor_input]!, "filter the rows returned" where: organisation_bool_exp): [organisation!]!

  """
  fetch data from the table: "organisational_activity"
  """
  organisational_activity("distinct select on columns" distinct_on: [organisational_activity_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [organisational_activity_order_by!], "filter the rows returned" where: organisational_activity_bool_exp): [organisational_activity!]!

  """
  fetch aggregated fields from the table: "organisational_activity"
  """
  organisational_activity_aggregate("distinct select on columns" distinct_on: [organisational_activity_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [organisational_activity_order_by!], "filter the rows returned" where: organisational_activity_bool_exp): organisational_activity_aggregate!

  """
  fetch data from the table: "organisational_activity" using primary key columns
  """
  organisational_activity_by_pk(id: String!): organisational_activity

  """
  fetch data from the table in a streaming manner: "organisational_activity"
  """
  organisational_activity_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [organisational_activity_stream_cursor_input]!, "filter the rows returned" where: organisational_activity_bool_exp): [organisational_activity!]!

  """
  fetch data from the table: "organisational_member"
  """
  organisational_member("distinct select on columns" distinct_on: [organisational_member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [organisational_member_order_by!], "filter the rows returned" where: organisational_member_bool_exp): [organisational_member!]!

  """
  fetch aggregated fields from the table: "organisational_member"
  """
  organisational_member_aggregate("distinct select on columns" distinct_on: [organisational_member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [organisational_member_order_by!], "filter the rows returned" where: organisational_member_bool_exp): organisational_member_aggregate!

  """
  fetch data from the table: "organisational_member" using primary key columns
  """
  organisational_member_by_pk(id: String!, member_id: String!, organisation_id: String!): organisational_member

  """
  fetch data from the table in a streaming manner: "organisational_member"
  """
  organisational_member_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [organisational_member_stream_cursor_input]!, "filter the rows returned" where: organisational_member_bool_exp): [organisational_member!]!

  """
  fetch data from the table: "samaj_member"
  """
  samaj_member("distinct select on columns" distinct_on: [samaj_member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [samaj_member_order_by!], "filter the rows returned" where: samaj_member_bool_exp): [samaj_member!]!

  """
  fetch aggregated fields from the table: "samaj_member"
  """
  samaj_member_aggregate("distinct select on columns" distinct_on: [samaj_member_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [samaj_member_order_by!], "filter the rows returned" where: samaj_member_bool_exp): samaj_member_aggregate!

  """
  fetch data from the table: "samaj_member" using primary key columns
  """
  samaj_member_by_pk(id: String!): samaj_member

  """
  fetch data from the table in a streaming manner: "samaj_member"
  """
  samaj_member_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [samaj_member_stream_cursor_input]!, "filter the rows returned" where: samaj_member_bool_exp): [samaj_member!]!

  """
  fetch data from the table: "satr_registration"
  """
  satr_registration("distinct select on columns" distinct_on: [satr_registration_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [satr_registration_order_by!], "filter the rows returned" where: satr_registration_bool_exp): [satr_registration!]!

  """
  fetch aggregated fields from the table: "satr_registration"
  """
  satr_registration_aggregate("distinct select on columns" distinct_on: [satr_registration_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [satr_registration_order_by!], "filter the rows returned" where: satr_registration_bool_exp): satr_registration_aggregate!

  """
  fetch data from the table: "satr_registration" using primary key columns
  """
  satr_registration_by_pk(id: uuid!): satr_registration

  """
  fetch data from the table in a streaming manner: "satr_registration"
  """
  satr_registration_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [satr_registration_stream_cursor_input]!, "filter the rows returned" where: satr_registration_bool_exp): [satr_registration!]!
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz

  _gt: timestamptz

  _gte: timestamptz

  _in: [timestamptz!]

  _is_null: Boolean

  _lt: timestamptz

  _lte: timestamptz

  _neq: timestamptz

  _nin: [timestamptz!]
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid

  _gt: uuid

  _gte: uuid

  _in: [uuid!]

  _is_null: Boolean

  _lt: uuid

  _lte: uuid

  _neq: uuid

  _nin: [uuid!]
}

"""
whether this query should be included
"""
directive @include (if: Boolean!) on FIELD|FRAGMENT_SPREAD|INLINE_FRAGMENT

"""
whether this query should be skipped
"""
directive @skip (if: Boolean!) on FIELD|FRAGMENT_SPREAD|INLINE_FRAGMENT

"""
whether this query should be cached (Hasura Cloud only)
"""
directive @cached ("measured in seconds" ttl: Int! = 60, "refresh the cache entry" refresh: Boolean! = false) on QUERY

schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}
