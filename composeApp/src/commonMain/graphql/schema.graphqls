type Activities implements Node {
  """
  Globally Unique Record Identifier
  """
  nodeId: ID!

  id: String!

  name: String!

  type: ActivityType!

  shortDescription: String!

  longDescription: String!

  address: String

  state: String

  district: String

  startDatetime: Datetime!

  endDatetime: Datetime!

  mediaFiles: [String]!

  additionalInstructions: String

  capacity: Int

  latitude: Float

  longitude: Float

  allowedGender: GenderFilter

  overviewDescription: String

  overviewMediaUrls: [String]!

  activityMemberCollection("Query the first `n` records in the collection" first: Int, "Query the last `n` records in the collection" last: Int, "Query values in the collection before the provided cursor" before: Cursor, "Query values in the collection after the provided cursor" after: Cursor, "Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported." offset: Int, "Filters to apply to the results set when querying from the collection" filter: ActivityMemberFilter, "Sort order to apply to the collection" orderBy: [ActivityMemberOrderBy!]): ActivityMemberConnection

  organisationalActivityCollection("Query the first `n` records in the collection" first: Int, "Query the last `n` records in the collection" last: Int, "Query values in the collection before the provided cursor" before: Cursor, "Query values in the collection after the provided cursor" after: Cursor, "Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported." offset: Int, "Filters to apply to the results set when querying from the collection" filter: OrganisationalActivityFilter, "Sort order to apply to the collection" orderBy: [OrganisationalActivityOrderBy!]): OrganisationalActivityConnection

  satrRegistrationCollection("Query the first `n` records in the collection" first: Int, "Query the last `n` records in the collection" last: Int, "Query values in the collection before the provided cursor" before: Cursor, "Query values in the collection after the provided cursor" after: Cursor, "Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported." offset: Int, "Filters to apply to the results set when querying from the collection" filter: SatrRegistrationFilter, "Sort order to apply to the collection" orderBy: [SatrRegistrationOrderBy!]): SatrRegistrationConnection
}

type ActivitiesConnection {
  edges: [ActivitiesEdge!]!

  pageInfo: PageInfo!
}

type ActivitiesDeleteResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [Activities!]!
}

type ActivitiesEdge {
  cursor: String!

  node: Activities!
}

input ActivitiesFilter {
  id: StringFilter

  name: StringFilter

  type: ActivityTypeFilter

  shortDescription: StringFilter

  longDescription: StringFilter

  address: StringFilter

  state: StringFilter

  district: StringFilter

  startDatetime: DatetimeFilter

  endDatetime: DatetimeFilter

  mediaFiles: StringListFilter

  additionalInstructions: StringFilter

  capacity: IntFilter

  latitude: FloatFilter

  longitude: FloatFilter

  allowedGender: GenderFilterFilter

  overviewDescription: StringFilter

  overviewMediaUrls: StringListFilter

  nodeId: IDFilter

  """
  Returns true only if all its inner filters are true, otherwise returns false
  """
  and: [ActivitiesFilter!]

  """
  Returns true if at least one of its inner filters is true, otherwise returns false
  """
  or: [ActivitiesFilter!]

  """
  Negates a filter
  """
  not: ActivitiesFilter
}

input ActivitiesInsertInput {
  id: String

  name: String

  type: ActivityType

  shortDescription: String

  longDescription: String

  address: String

  state: String

  district: String

  startDatetime: Datetime

  endDatetime: Datetime

  mediaFiles: [String]

  additionalInstructions: String

  capacity: Int

  latitude: Float

  longitude: Float

  allowedGender: GenderFilter

  overviewDescription: String

  overviewMediaUrls: [String]
}

type ActivitiesInsertResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [Activities!]!
}

input ActivitiesOrderBy {
  id: OrderByDirection

  name: OrderByDirection

  type: OrderByDirection

  shortDescription: OrderByDirection

  longDescription: OrderByDirection

  address: OrderByDirection

  state: OrderByDirection

  district: OrderByDirection

  startDatetime: OrderByDirection

  endDatetime: OrderByDirection

  additionalInstructions: OrderByDirection

  capacity: OrderByDirection

  latitude: OrderByDirection

  longitude: OrderByDirection

  allowedGender: OrderByDirection

  overviewDescription: OrderByDirection
}

input ActivitiesUpdateInput {
  id: String

  name: String

  type: ActivityType

  shortDescription: String

  longDescription: String

  address: String

  state: String

  district: String

  startDatetime: Datetime

  endDatetime: Datetime

  mediaFiles: [String]

  additionalInstructions: String

  capacity: Int

  latitude: Float

  longitude: Float

  allowedGender: GenderFilter

  overviewDescription: String

  overviewMediaUrls: [String]
}

type ActivitiesUpdateResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [Activities!]!
}

type ActivityMember implements Node {
  """
  Globally Unique Record Identifier
  """
  nodeId: ID!

  id: UUID!

  activityId: String!

  memberId: String!

  post: String

  priority: Int!

  activity: Activities

  member: Member
}

type ActivityMemberConnection {
  edges: [ActivityMemberEdge!]!

  pageInfo: PageInfo!
}

type ActivityMemberDeleteResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [ActivityMember!]!
}

type ActivityMemberEdge {
  cursor: String!

  node: ActivityMember!
}

input ActivityMemberFilter {
  id: UUIDFilter

  activityId: StringFilter

  memberId: StringFilter

  post: StringFilter

  priority: IntFilter

  nodeId: IDFilter

  """
  Returns true only if all its inner filters are true, otherwise returns false
  """
  and: [ActivityMemberFilter!]

  """
  Returns true if at least one of its inner filters is true, otherwise returns false
  """
  or: [ActivityMemberFilter!]

  """
  Negates a filter
  """
  not: ActivityMemberFilter
}

input ActivityMemberInsertInput {
  id: UUID

  activityId: String

  memberId: String

  post: String

  priority: Int
}

type ActivityMemberInsertResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [ActivityMember!]!
}

input ActivityMemberOrderBy {
  id: OrderByDirection

  activityId: OrderByDirection

  memberId: OrderByDirection

  post: OrderByDirection

  priority: OrderByDirection
}

input ActivityMemberUpdateInput {
  id: UUID

  activityId: String

  memberId: String

  post: String

  priority: Int
}

type ActivityMemberUpdateResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [ActivityMember!]!
}

enum ActivityType {
  SESSION

  CAMP

  COURSE

  EVENT

  CAMPAIGN
}

"""
Boolean expression comparing fields on type "ActivityType"
"""
input ActivityTypeFilter {
  eq: ActivityType

  in: [ActivityType!]

  is: FilterIs

  neq: ActivityType
}

type Address implements Node {
  """
  Globally Unique Record Identifier
  """
  nodeId: ID!

  id: String!

  createdAt: Datetime!

  basicAddress: String

  state: String

  district: String

  pincode: String

  latitude: Float

  longitude: Float

  vidhansabha: String

  aryaSamajCollection("Query the first `n` records in the collection" first: Int, "Query the last `n` records in the collection" last: Int, "Query values in the collection before the provided cursor" before: Cursor, "Query values in the collection after the provided cursor" after: Cursor, "Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported." offset: Int, "Filters to apply to the results set when querying from the collection" filter: AryaSamajFilter, "Sort order to apply to the collection" orderBy: [AryaSamajOrderBy!]): AryaSamajConnection

  memberCollection("Query the first `n` records in the collection" first: Int, "Query the last `n` records in the collection" last: Int, "Query values in the collection before the provided cursor" before: Cursor, "Query values in the collection after the provided cursor" after: Cursor, "Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported." offset: Int, "Filters to apply to the results set when querying from the collection" filter: MemberFilter, "Sort order to apply to the collection" orderBy: [MemberOrderBy!]): MemberConnection

  memberWithTempAddressCollection("Query the first `n` records in the collection" first: Int, "Query the last `n` records in the collection" last: Int, "Query values in the collection before the provided cursor" before: Cursor, "Query values in the collection after the provided cursor" after: Cursor, "Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported." offset: Int, "Filters to apply to the results set when querying from the collection" filter: MemberFilter, "Sort order to apply to the collection" orderBy: [MemberOrderBy!]): MemberConnection

  familyCollection("Query the first `n` records in the collection" first: Int, "Query the last `n` records in the collection" last: Int, "Query values in the collection before the provided cursor" before: Cursor, "Query values in the collection after the provided cursor" after: Cursor, "Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported." offset: Int, "Filters to apply to the results set when querying from the collection" filter: FamilyFilter, "Sort order to apply to the collection" orderBy: [FamilyOrderBy!]): FamilyConnection
}

type AddressConnection {
  edges: [AddressEdge!]!

  pageInfo: PageInfo!
}

type AddressDeleteResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [Address!]!
}

type AddressEdge {
  cursor: String!

  node: Address!
}

input AddressFilter {
  id: StringFilter

  createdAt: DatetimeFilter

  basicAddress: StringFilter

  state: StringFilter

  district: StringFilter

  pincode: StringFilter

  latitude: FloatFilter

  longitude: FloatFilter

  vidhansabha: StringFilter

  nodeId: IDFilter

  """
  Returns true only if all its inner filters are true, otherwise returns false
  """
  and: [AddressFilter!]

  """
  Returns true if at least one of its inner filters is true, otherwise returns false
  """
  or: [AddressFilter!]

  """
  Negates a filter
  """
  not: AddressFilter
}

input AddressInsertInput {
  id: String

  createdAt: Datetime

  basicAddress: String

  state: String

  district: String

  pincode: String

  latitude: Float

  longitude: Float

  vidhansabha: String
}

type AddressInsertResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [Address!]!
}

input AddressOrderBy {
  id: OrderByDirection

  createdAt: OrderByDirection

  basicAddress: OrderByDirection

  state: OrderByDirection

  district: OrderByDirection

  pincode: OrderByDirection

  latitude: OrderByDirection

  longitude: OrderByDirection

  vidhansabha: OrderByDirection
}

input AddressUpdateInput {
  id: String

  createdAt: Datetime

  basicAddress: String

  state: String

  district: String

  pincode: String

  latitude: Float

  longitude: Float

  vidhansabha: String
}

type AddressUpdateResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [Address!]!
}

type Admission implements Node {
  """
  Globally Unique Record Identifier
  """
  nodeId: ID!

  id: String!

  studentName: String

  aadharNo: String

  dob: String

  bloodGroup: String

  previousClass: String

  marksObtained: String

  schoolName: String

  fatherName: String

  fatherOccupation: String

  fatherQualification: String

  motherName: String

  motherOccupation: String

  motherQualification: String

  fullAddress: String

  mobileNo: String

  alternateMobileNo: String

  attachedDocuments: [String]

  studentPhoto: String

  studentSignature: String

  parentSignature: String
}

type AdmissionConnection {
  edges: [AdmissionEdge!]!

  pageInfo: PageInfo!
}

type AdmissionDeleteResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [Admission!]!
}

type AdmissionEdge {
  cursor: String!

  node: Admission!
}

input AdmissionFilter {
  id: StringFilter

  studentName: StringFilter

  aadharNo: StringFilter

  dob: StringFilter

  bloodGroup: StringFilter

  previousClass: StringFilter

  marksObtained: StringFilter

  schoolName: StringFilter

  fatherName: StringFilter

  fatherOccupation: StringFilter

  fatherQualification: StringFilter

  motherName: StringFilter

  motherOccupation: StringFilter

  motherQualification: StringFilter

  fullAddress: StringFilter

  mobileNo: StringFilter

  alternateMobileNo: StringFilter

  attachedDocuments: StringListFilter

  studentPhoto: StringFilter

  studentSignature: StringFilter

  parentSignature: StringFilter

  nodeId: IDFilter

  """
  Returns true only if all its inner filters are true, otherwise returns false
  """
  and: [AdmissionFilter!]

  """
  Returns true if at least one of its inner filters is true, otherwise returns false
  """
  or: [AdmissionFilter!]

  """
  Negates a filter
  """
  not: AdmissionFilter
}

input AdmissionInsertInput {
  id: String

  studentName: String

  aadharNo: String

  dob: String

  bloodGroup: String

  previousClass: String

  marksObtained: String

  schoolName: String

  fatherName: String

  fatherOccupation: String

  fatherQualification: String

  motherName: String

  motherOccupation: String

  motherQualification: String

  fullAddress: String

  mobileNo: String

  alternateMobileNo: String

  attachedDocuments: [String]

  studentPhoto: String

  studentSignature: String

  parentSignature: String
}

type AdmissionInsertResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [Admission!]!
}

input AdmissionOrderBy {
  id: OrderByDirection

  studentName: OrderByDirection

  aadharNo: OrderByDirection

  dob: OrderByDirection

  bloodGroup: OrderByDirection

  previousClass: OrderByDirection

  marksObtained: OrderByDirection

  schoolName: OrderByDirection

  fatherName: OrderByDirection

  fatherOccupation: OrderByDirection

  fatherQualification: OrderByDirection

  motherName: OrderByDirection

  motherOccupation: OrderByDirection

  motherQualification: OrderByDirection

  fullAddress: OrderByDirection

  mobileNo: OrderByDirection

  alternateMobileNo: OrderByDirection

  studentPhoto: OrderByDirection

  studentSignature: OrderByDirection

  parentSignature: OrderByDirection
}

input AdmissionUpdateInput {
  id: String

  studentName: String

  aadharNo: String

  dob: String

  bloodGroup: String

  previousClass: String

  marksObtained: String

  schoolName: String

  fatherName: String

  fatherOccupation: String

  fatherQualification: String

  motherName: String

  motherOccupation: String

  motherQualification: String

  fullAddress: String

  mobileNo: String

  alternateMobileNo: String

  attachedDocuments: [String]

  studentPhoto: String

  studentSignature: String

  parentSignature: String
}

type AdmissionUpdateResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [Admission!]!
}

type AppLabels implements Node {
  """
  Globally Unique Record Identifier
  """
  nodeId: ID!

  id: UUID!

  createdAt: Datetime!

  labelKey: String

  labelValue: String
}

type AppLabelsConnection {
  edges: [AppLabelsEdge!]!

  pageInfo: PageInfo!
}

type AppLabelsDeleteResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [AppLabels!]!
}

type AppLabelsEdge {
  cursor: String!

  node: AppLabels!
}

input AppLabelsFilter {
  id: UUIDFilter

  createdAt: DatetimeFilter

  labelKey: StringFilter

  labelValue: StringFilter

  nodeId: IDFilter

  """
  Returns true only if all its inner filters are true, otherwise returns false
  """
  and: [AppLabelsFilter!]

  """
  Returns true if at least one of its inner filters is true, otherwise returns false
  """
  or: [AppLabelsFilter!]

  """
  Negates a filter
  """
  not: AppLabelsFilter
}

input AppLabelsInsertInput {
  id: UUID

  createdAt: Datetime

  labelKey: String

  labelValue: String
}

type AppLabelsInsertResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [AppLabels!]!
}

input AppLabelsOrderBy {
  id: OrderByDirection

  createdAt: OrderByDirection

  labelKey: OrderByDirection

  labelValue: OrderByDirection
}

input AppLabelsUpdateInput {
  id: UUID

  createdAt: Datetime

  labelKey: String

  labelValue: String
}

type AppLabelsUpdateResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [AppLabels!]!
}

type AryaSamaj implements Node {
  """
  Globally Unique Record Identifier
  """
  nodeId: ID!

  id: String!

  createdAt: Datetime!

  name: String!

  description: String!

  mediaUrls: [String]!

  addressId: String

  address: Address

  samajMemberCollection("Query the first `n` records in the collection" first: Int, "Query the last `n` records in the collection" last: Int, "Query values in the collection before the provided cursor" before: Cursor, "Query values in the collection after the provided cursor" after: Cursor, "Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported." offset: Int, "Filters to apply to the results set when querying from the collection" filter: SamajMemberFilter, "Sort order to apply to the collection" orderBy: [SamajMemberOrderBy!]): SamajMemberConnection

  memberCollection("Query the first `n` records in the collection" first: Int, "Query the last `n` records in the collection" last: Int, "Query values in the collection before the provided cursor" before: Cursor, "Query values in the collection after the provided cursor" after: Cursor, "Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported." offset: Int, "Filters to apply to the results set when querying from the collection" filter: MemberFilter, "Sort order to apply to the collection" orderBy: [MemberOrderBy!]): MemberConnection

  familyCollection("Query the first `n` records in the collection" first: Int, "Query the last `n` records in the collection" last: Int, "Query values in the collection before the provided cursor" before: Cursor, "Query values in the collection after the provided cursor" after: Cursor, "Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported." offset: Int, "Filters to apply to the results set when querying from the collection" filter: FamilyFilter, "Sort order to apply to the collection" orderBy: [FamilyOrderBy!]): FamilyConnection
}

type AryaSamajConnection {
  edges: [AryaSamajEdge!]!

  pageInfo: PageInfo!

  """
  The total number of records matching the `filter` criteria
  """
  totalCount: Int!
}

type AryaSamajDeleteResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [AryaSamaj!]!
}

type AryaSamajEdge {
  cursor: String!

  node: AryaSamaj!
}

input AryaSamajFilter {
  id: StringFilter

  createdAt: DatetimeFilter

  name: StringFilter

  description: StringFilter

  mediaUrls: StringListFilter

  addressId: StringFilter

  nodeId: IDFilter

  """
  Returns true only if all its inner filters are true, otherwise returns false
  """
  and: [AryaSamajFilter!]

  """
  Returns true if at least one of its inner filters is true, otherwise returns false
  """
  or: [AryaSamajFilter!]

  """
  Negates a filter
  """
  not: AryaSamajFilter
}

input AryaSamajInsertInput {
  id: String

  createdAt: Datetime

  name: String

  description: String

  mediaUrls: [String]

  addressId: String
}

type AryaSamajInsertResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [AryaSamaj!]!
}

input AryaSamajOrderBy {
  id: OrderByDirection

  createdAt: OrderByDirection

  name: OrderByDirection

  description: OrderByDirection

  addressId: OrderByDirection
}

input AryaSamajUpdateInput {
  id: String

  createdAt: Datetime

  name: String

  description: String

  mediaUrls: [String]

  addressId: String
}

type AryaSamajUpdateResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [AryaSamaj!]!
}

"""
A high precision floating point value represented as a string
"""
scalar BigFloat

"""
Boolean expression comparing fields on type "BigFloat"
"""
input BigFloatFilter {
  eq: BigFloat

  gt: BigFloat

  gte: BigFloat

  in: [BigFloat!]

  is: FilterIs

  lt: BigFloat

  lte: BigFloat

  neq: BigFloat
}

"""
Boolean expression comparing fields on type "BigFloatList"
"""
input BigFloatListFilter {
  containedBy: [BigFloat!]

  contains: [BigFloat!]

  eq: [BigFloat!]

  is: FilterIs

  overlaps: [BigFloat!]
}

"""
An arbitrary size integer represented as a string
"""
scalar BigInt

"""
Boolean expression comparing fields on type "BigInt"
"""
input BigIntFilter {
  eq: BigInt

  gt: BigInt

  gte: BigInt

  in: [BigInt!]

  is: FilterIs

  lt: BigInt

  lte: BigInt

  neq: BigInt
}

"""
Boolean expression comparing fields on type "BigIntList"
"""
input BigIntListFilter {
  containedBy: [BigInt!]

  contains: [BigInt!]

  eq: [BigInt!]

  is: FilterIs

  overlaps: [BigInt!]
}

type BookOrders implements Node {
  """
  Globally Unique Record Identifier
  """
  nodeId: ID!

  id: UUID!

  fullname: String!

  address: String

  city: String

  district: String

  state: String

  mobile: String

  pincode: String

  country: String

  districtOfficerName: String

  districtOfficerNumber: String

  paymentReceiptUrl: String

  isFulfilled: Boolean

  createdAt: Datetime
}

type BookOrdersConnection {
  edges: [BookOrdersEdge!]!

  pageInfo: PageInfo!
}

type BookOrdersDeleteResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [BookOrders!]!
}

type BookOrdersEdge {
  cursor: String!

  node: BookOrders!
}

input BookOrdersFilter {
  id: UUIDFilter

  fullname: StringFilter

  address: StringFilter

  city: StringFilter

  district: StringFilter

  state: StringFilter

  mobile: StringFilter

  pincode: StringFilter

  country: StringFilter

  districtOfficerName: StringFilter

  districtOfficerNumber: StringFilter

  paymentReceiptUrl: StringFilter

  isFulfilled: BooleanFilter

  createdAt: DatetimeFilter

  nodeId: IDFilter

  """
  Returns true only if all its inner filters are true, otherwise returns false
  """
  and: [BookOrdersFilter!]

  """
  Returns true if at least one of its inner filters is true, otherwise returns false
  """
  or: [BookOrdersFilter!]

  """
  Negates a filter
  """
  not: BookOrdersFilter
}

input BookOrdersInsertInput {
  id: UUID

  fullname: String

  address: String

  city: String

  district: String

  state: String

  mobile: String

  pincode: String

  country: String

  districtOfficerName: String

  districtOfficerNumber: String

  paymentReceiptUrl: String

  isFulfilled: Boolean

  createdAt: Datetime
}

type BookOrdersInsertResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [BookOrders!]!
}

input BookOrdersOrderBy {
  id: OrderByDirection

  fullname: OrderByDirection

  address: OrderByDirection

  city: OrderByDirection

  district: OrderByDirection

  state: OrderByDirection

  mobile: OrderByDirection

  pincode: OrderByDirection

  country: OrderByDirection

  districtOfficerName: OrderByDirection

  districtOfficerNumber: OrderByDirection

  paymentReceiptUrl: OrderByDirection

  isFulfilled: OrderByDirection

  createdAt: OrderByDirection
}

input BookOrdersUpdateInput {
  id: UUID

  fullname: String

  address: String

  city: String

  district: String

  state: String

  mobile: String

  pincode: String

  country: String

  districtOfficerName: String

  districtOfficerNumber: String

  paymentReceiptUrl: String

  isFulfilled: Boolean

  createdAt: Datetime
}

type BookOrdersUpdateResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [BookOrders!]!
}

"""
Boolean expression comparing fields on type "Boolean"
"""
input BooleanFilter {
  eq: Boolean

  is: FilterIs
}

"""
Boolean expression comparing fields on type "BooleanList"
"""
input BooleanListFilter {
  containedBy: [Boolean!]

  contains: [Boolean!]

  eq: [Boolean!]

  is: FilterIs

  overlaps: [Boolean!]
}

"""
An opaque string using for tracking a position in results during pagination
"""
scalar Cursor

"""
A date without time information
"""
scalar Date

"""
Boolean expression comparing fields on type "Date"
"""
input DateFilter {
  eq: Date

  gt: Date

  gte: Date

  in: [Date!]

  is: FilterIs

  lt: Date

  lte: Date

  neq: Date
}

"""
Boolean expression comparing fields on type "DateList"
"""
input DateListFilter {
  containedBy: [Date!]

  contains: [Date!]

  eq: [Date!]

  is: FilterIs

  overlaps: [Date!]
}

"""
A date and time
"""
scalar Datetime

"""
Boolean expression comparing fields on type "Datetime"
"""
input DatetimeFilter {
  eq: Datetime

  gt: Datetime

  gte: Datetime

  in: [Datetime!]

  is: FilterIs

  lt: Datetime

  lte: Datetime

  neq: Datetime
}

"""
Boolean expression comparing fields on type "DatetimeList"
"""
input DatetimeListFilter {
  containedBy: [Datetime!]

  contains: [Datetime!]

  eq: [Datetime!]

  is: FilterIs

  overlaps: [Datetime!]
}

type Family implements Node {
  """
  Globally Unique Record Identifier
  """
  nodeId: ID!

  id: String!

  createdAt: Datetime!

  addressId: String

  aryaSamajId: String

  name: String

  photos: [String]

  address: Address

  aryaSamaj: AryaSamaj

  familyMemberCollection("Query the first `n` records in the collection" first: Int, "Query the last `n` records in the collection" last: Int, "Query values in the collection before the provided cursor" before: Cursor, "Query values in the collection after the provided cursor" after: Cursor, "Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported." offset: Int, "Filters to apply to the results set when querying from the collection" filter: FamilyMemberFilter, "Sort order to apply to the collection" orderBy: [FamilyMemberOrderBy!]): FamilyMemberConnection
}

type FamilyConnection {
  edges: [FamilyEdge!]!

  pageInfo: PageInfo!
}

type FamilyDeleteResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [Family!]!
}

type FamilyEdge {
  cursor: String!

  node: Family!
}

input FamilyFilter {
  id: StringFilter

  createdAt: DatetimeFilter

  addressId: StringFilter

  aryaSamajId: StringFilter

  name: StringFilter

  photos: StringListFilter

  nodeId: IDFilter

  """
  Returns true only if all its inner filters are true, otherwise returns false
  """
  and: [FamilyFilter!]

  """
  Returns true if at least one of its inner filters is true, otherwise returns false
  """
  or: [FamilyFilter!]

  """
  Negates a filter
  """
  not: FamilyFilter
}

input FamilyInsertInput {
  id: String

  createdAt: Datetime

  addressId: String

  aryaSamajId: String

  name: String

  photos: [String]
}

type FamilyInsertResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [Family!]!
}

type FamilyMember implements Node {
  """
  Globally Unique Record Identifier
  """
  nodeId: ID!

  id: String!

  createdAt: Datetime!

  familyId: String!

  memberId: String!

  isHead: Boolean!

  relationToHead: FamilyRelation!

  family: Family

  member: Member
}

type FamilyMemberConnection {
  edges: [FamilyMemberEdge!]!

  pageInfo: PageInfo!
}

type FamilyMemberDeleteResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [FamilyMember!]!
}

type FamilyMemberEdge {
  cursor: String!

  node: FamilyMember!
}

input FamilyMemberFilter {
  id: StringFilter

  createdAt: DatetimeFilter

  familyId: StringFilter

  memberId: StringFilter

  isHead: BooleanFilter

  relationToHead: FamilyRelationFilter

  nodeId: IDFilter

  """
  Returns true only if all its inner filters are true, otherwise returns false
  """
  and: [FamilyMemberFilter!]

  """
  Returns true if at least one of its inner filters is true, otherwise returns false
  """
  or: [FamilyMemberFilter!]

  """
  Negates a filter
  """
  not: FamilyMemberFilter
}

input FamilyMemberInsertInput {
  id: String

  createdAt: Datetime

  familyId: String

  memberId: String

  isHead: Boolean

  relationToHead: FamilyRelation
}

type FamilyMemberInsertResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [FamilyMember!]!
}

input FamilyMemberOrderBy {
  id: OrderByDirection

  createdAt: OrderByDirection

  familyId: OrderByDirection

  memberId: OrderByDirection

  isHead: OrderByDirection

  relationToHead: OrderByDirection
}

input FamilyMemberUpdateInput {
  id: String

  createdAt: Datetime

  familyId: String

  memberId: String

  isHead: Boolean

  relationToHead: FamilyRelation
}

type FamilyMemberUpdateResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [FamilyMember!]!
}

input FamilyOrderBy {
  id: OrderByDirection

  createdAt: OrderByDirection

  addressId: OrderByDirection

  aryaSamajId: OrderByDirection

  name: OrderByDirection
}

enum FamilyRelation {
  SELF

  FATHER

  MOTHER

  HUSBAND

  WIFE

  SON

  DAUGHTER

  BROTHER

  SISTER

  GRANDFATHER

  GRANDMOTHER

  GRANDSON

  GRANDDAUGHTER

  UNCLE

  AUNT

  COUSIN

  NEPHEW

  NIECE

  GUARDIAN

  RELATIVE

  OTHER
}

"""
Boolean expression comparing fields on type "FamilyRelation"
"""
input FamilyRelationFilter {
  eq: FamilyRelation

  in: [FamilyRelation!]

  is: FilterIs

  neq: FamilyRelation
}

input FamilyUpdateInput {
  id: String

  createdAt: Datetime

  addressId: String

  aryaSamajId: String

  name: String

  photos: [String]
}

type FamilyUpdateResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [Family!]!
}

enum FilterIs {
  NULL

  NOT_NULL
}

"""
Boolean expression comparing fields on type "Float"
"""
input FloatFilter {
  eq: Float

  gt: Float

  gte: Float

  in: [Float!]

  is: FilterIs

  lt: Float

  lte: Float

  neq: Float
}

"""
Boolean expression comparing fields on type "FloatList"
"""
input FloatListFilter {
  containedBy: [Float!]

  contains: [Float!]

  eq: [Float!]

  is: FilterIs

  overlaps: [Float!]
}

enum GenderFilter {
  MALE

  FEMALE

  ANY
}

"""
Boolean expression comparing fields on type "GenderFilter"
"""
input GenderFilterFilter {
  eq: GenderFilter

  in: [GenderFilter!]

  is: FilterIs

  neq: GenderFilter
}

"""
Boolean expression comparing fields on type "ID"
"""
input IDFilter {
  eq: ID
}

"""
Boolean expression comparing fields on type "Int"
"""
input IntFilter {
  eq: Int

  gt: Int

  gte: Int

  in: [Int!]

  is: FilterIs

  lt: Int

  lte: Int

  neq: Int
}

"""
Boolean expression comparing fields on type "IntList"
"""
input IntListFilter {
  containedBy: [Int!]

  contains: [Int!]

  eq: [Int!]

  is: FilterIs

  overlaps: [Int!]
}

"""
A Javascript Object Notation value serialized as a string
"""
scalar JSON

type Learning implements Node {
  """
  Globally Unique Record Identifier
  """
  nodeId: ID!

  id: String!

  title: String

  description: String

  url: String

  thumbnailUrl: String

  videoId: String
}

type LearningConnection {
  edges: [LearningEdge!]!

  pageInfo: PageInfo!
}

type LearningDeleteResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [Learning!]!
}

type LearningEdge {
  cursor: String!

  node: Learning!
}

input LearningFilter {
  id: StringFilter

  title: StringFilter

  description: StringFilter

  url: StringFilter

  thumbnailUrl: StringFilter

  videoId: StringFilter

  nodeId: IDFilter

  """
  Returns true only if all its inner filters are true, otherwise returns false
  """
  and: [LearningFilter!]

  """
  Returns true if at least one of its inner filters is true, otherwise returns false
  """
  or: [LearningFilter!]

  """
  Negates a filter
  """
  not: LearningFilter
}

input LearningInsertInput {
  id: String

  title: String

  description: String

  url: String

  thumbnailUrl: String

  videoId: String
}

type LearningInsertResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [Learning!]!
}

input LearningOrderBy {
  id: OrderByDirection

  title: OrderByDirection

  description: OrderByDirection

  url: OrderByDirection

  thumbnailUrl: OrderByDirection

  videoId: OrderByDirection
}

input LearningUpdateInput {
  id: String

  title: String

  description: String

  url: String

  thumbnailUrl: String

  videoId: String
}

type LearningUpdateResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [Learning!]!
}

type Member implements Node {
  """
  Globally Unique Record Identifier
  """
  nodeId: ID!

  id: String!

  name: String!

  profileImage: String

  educationalQualification: String

  phoneNumber: String!

  email: String

  dob: Date

  addressId: String

  aryaSamajId: String

  joiningDate: Date

  tempAddressId: String

  referrerId: String

  occupation: String

  introduction: String

  gender: GenderFilter

  address: Address

  aryaSamaj: AryaSamaj

  tempAddress: Address

  referrer: Member

  activityMemberCollection("Query the first `n` records in the collection" first: Int, "Query the last `n` records in the collection" last: Int, "Query values in the collection before the provided cursor" before: Cursor, "Query values in the collection after the provided cursor" after: Cursor, "Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported." offset: Int, "Filters to apply to the results set when querying from the collection" filter: ActivityMemberFilter, "Sort order to apply to the collection" orderBy: [ActivityMemberOrderBy!]): ActivityMemberConnection

  organisationalMemberCollection("Query the first `n` records in the collection" first: Int, "Query the last `n` records in the collection" last: Int, "Query values in the collection before the provided cursor" before: Cursor, "Query values in the collection after the provided cursor" after: Cursor, "Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported." offset: Int, "Filters to apply to the results set when querying from the collection" filter: OrganisationalMemberFilter, "Sort order to apply to the collection" orderBy: [OrganisationalMemberOrderBy!]): OrganisationalMemberConnection

  samajMemberCollection("Query the first `n` records in the collection" first: Int, "Query the last `n` records in the collection" last: Int, "Query values in the collection before the provided cursor" before: Cursor, "Query values in the collection after the provided cursor" after: Cursor, "Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported." offset: Int, "Filters to apply to the results set when querying from the collection" filter: SamajMemberFilter, "Sort order to apply to the collection" orderBy: [SamajMemberOrderBy!]): SamajMemberConnection

  familyMember: FamilyMember

  referredMembers("Query the first `n` records in the collection" first: Int, "Query the last `n` records in the collection" last: Int, "Query values in the collection before the provided cursor" before: Cursor, "Query values in the collection after the provided cursor" after: Cursor, "Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported." offset: Int, "Filters to apply to the results set when querying from the collection" filter: MemberFilter, "Sort order to apply to the collection" orderBy: [MemberOrderBy!]): MemberConnection
}

type MemberConnection {
  edges: [MemberEdge!]!

  pageInfo: PageInfo!

  """
  The total number of records matching the `filter` criteria
  """
  totalCount: Int!
}

type MemberDeleteResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [Member!]!
}

type MemberEdge {
  cursor: String!

  node: Member!
}

input MemberFilter {
  id: StringFilter

  name: StringFilter

  profileImage: StringFilter

  educationalQualification: StringFilter

  phoneNumber: StringFilter

  email: StringFilter

  dob: DateFilter

  addressId: StringFilter

  aryaSamajId: StringFilter

  joiningDate: DateFilter

  tempAddressId: StringFilter

  referrerId: StringFilter

  occupation: StringFilter

  introduction: StringFilter

  gender: GenderFilterFilter

  nodeId: IDFilter

  """
  Returns true only if all its inner filters are true, otherwise returns false
  """
  and: [MemberFilter!]

  """
  Returns true if at least one of its inner filters is true, otherwise returns false
  """
  or: [MemberFilter!]

  """
  Negates a filter
  """
  not: MemberFilter
}

input MemberInsertInput {
  id: String

  name: String

  profileImage: String

  educationalQualification: String

  phoneNumber: String

  email: String

  dob: Date

  addressId: String

  aryaSamajId: String

  joiningDate: Date

  tempAddressId: String

  referrerId: String

  occupation: String

  introduction: String

  gender: GenderFilter
}

type MemberInsertResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [Member!]!
}

input MemberOrderBy {
  id: OrderByDirection

  name: OrderByDirection

  profileImage: OrderByDirection

  educationalQualification: OrderByDirection

  phoneNumber: OrderByDirection

  email: OrderByDirection

  dob: OrderByDirection

  addressId: OrderByDirection

  aryaSamajId: OrderByDirection

  joiningDate: OrderByDirection

  tempAddressId: OrderByDirection

  referrerId: OrderByDirection

  occupation: OrderByDirection

  introduction: OrderByDirection

  gender: OrderByDirection
}

input MemberUpdateInput {
  id: String

  name: String

  profileImage: String

  educationalQualification: String

  phoneNumber: String

  email: String

  dob: Date

  addressId: String

  aryaSamajId: String

  joiningDate: Date

  tempAddressId: String

  referrerId: String

  occupation: String

  introduction: String

  gender: GenderFilter
}

type MemberUpdateResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [Member!]!
}

"""
The root type for creating and mutating data
"""
type Mutation {
  """
  Deletes zero or more records from the `Activities` collection
  """
  deleteFromActivitiesCollection("Restricts the mutation's impact to records matching the criteria" filter: ActivitiesFilter, "The maximum number of records in the collection permitted to be affected" atMost: Int! = 1): ActivitiesDeleteResponse!

  """
  Deletes zero or more records from the `ActivityMember` collection
  """
  deleteFromActivityMemberCollection("Restricts the mutation's impact to records matching the criteria" filter: ActivityMemberFilter, "The maximum number of records in the collection permitted to be affected" atMost: Int! = 1): ActivityMemberDeleteResponse!

  """
  Deletes zero or more records from the `Address` collection
  """
  deleteFromAddressCollection("Restricts the mutation's impact to records matching the criteria" filter: AddressFilter, "The maximum number of records in the collection permitted to be affected" atMost: Int! = 1): AddressDeleteResponse!

  """
  Deletes zero or more records from the `Admission` collection
  """
  deleteFromAdmissionCollection("Restricts the mutation's impact to records matching the criteria" filter: AdmissionFilter, "The maximum number of records in the collection permitted to be affected" atMost: Int! = 1): AdmissionDeleteResponse!

  """
  Deletes zero or more records from the `AppLabels` collection
  """
  deleteFromAppLabelsCollection("Restricts the mutation's impact to records matching the criteria" filter: AppLabelsFilter, "The maximum number of records in the collection permitted to be affected" atMost: Int! = 1): AppLabelsDeleteResponse!

  """
  Deletes zero or more records from the `AryaSamaj` collection
  """
  deleteFromAryaSamajCollection("Restricts the mutation's impact to records matching the criteria" filter: AryaSamajFilter, "The maximum number of records in the collection permitted to be affected" atMost: Int! = 1): AryaSamajDeleteResponse!

  """
  Deletes zero or more records from the `BookOrders` collection
  """
  deleteFromBookOrdersCollection("Restricts the mutation's impact to records matching the criteria" filter: BookOrdersFilter, "The maximum number of records in the collection permitted to be affected" atMost: Int! = 1): BookOrdersDeleteResponse!

  """
  Deletes zero or more records from the `Family` collection
  """
  deleteFromFamilyCollection("Restricts the mutation's impact to records matching the criteria" filter: FamilyFilter, "The maximum number of records in the collection permitted to be affected" atMost: Int! = 1): FamilyDeleteResponse!

  """
  Deletes zero or more records from the `FamilyMember` collection
  """
  deleteFromFamilyMemberCollection("Restricts the mutation's impact to records matching the criteria" filter: FamilyMemberFilter, "The maximum number of records in the collection permitted to be affected" atMost: Int! = 1): FamilyMemberDeleteResponse!

  """
  Deletes zero or more records from the `Learning` collection
  """
  deleteFromLearningCollection("Restricts the mutation's impact to records matching the criteria" filter: LearningFilter, "The maximum number of records in the collection permitted to be affected" atMost: Int! = 1): LearningDeleteResponse!

  """
  Deletes zero or more records from the `Member` collection
  """
  deleteFromMemberCollection("Restricts the mutation's impact to records matching the criteria" filter: MemberFilter, "The maximum number of records in the collection permitted to be affected" atMost: Int! = 1): MemberDeleteResponse!

  """
  Deletes zero or more records from the `Organisation` collection
  """
  deleteFromOrganisationCollection("Restricts the mutation's impact to records matching the criteria" filter: OrganisationFilter, "The maximum number of records in the collection permitted to be affected" atMost: Int! = 1): OrganisationDeleteResponse!

  """
  Deletes zero or more records from the `OrganisationalActivity` collection
  """
  deleteFromOrganisationalActivityCollection("Restricts the mutation's impact to records matching the criteria" filter: OrganisationalActivityFilter, "The maximum number of records in the collection permitted to be affected" atMost: Int! = 1): OrganisationalActivityDeleteResponse!

  """
  Deletes zero or more records from the `OrganisationalMember` collection
  """
  deleteFromOrganisationalMemberCollection("Restricts the mutation's impact to records matching the criteria" filter: OrganisationalMemberFilter, "The maximum number of records in the collection permitted to be affected" atMost: Int! = 1): OrganisationalMemberDeleteResponse!

  """
  Deletes zero or more records from the `SamajMember` collection
  """
  deleteFromSamajMemberCollection("Restricts the mutation's impact to records matching the criteria" filter: SamajMemberFilter, "The maximum number of records in the collection permitted to be affected" atMost: Int! = 1): SamajMemberDeleteResponse!

  """
  Deletes zero or more records from the `SatrRegistration` collection
  """
  deleteFromSatrRegistrationCollection("Restricts the mutation's impact to records matching the criteria" filter: SatrRegistrationFilter, "The maximum number of records in the collection permitted to be affected" atMost: Int! = 1): SatrRegistrationDeleteResponse!

  """
  Adds one or more `Activities` records to the collection
  """
  insertIntoActivitiesCollection(objects: [ActivitiesInsertInput!]!): ActivitiesInsertResponse

  """
  Adds one or more `ActivityMember` records to the collection
  """
  insertIntoActivityMemberCollection(objects: [ActivityMemberInsertInput!]!): ActivityMemberInsertResponse

  """
  Adds one or more `Address` records to the collection
  """
  insertIntoAddressCollection(objects: [AddressInsertInput!]!): AddressInsertResponse

  """
  Adds one or more `Admission` records to the collection
  """
  insertIntoAdmissionCollection(objects: [AdmissionInsertInput!]!): AdmissionInsertResponse

  """
  Adds one or more `AppLabels` records to the collection
  """
  insertIntoAppLabelsCollection(objects: [AppLabelsInsertInput!]!): AppLabelsInsertResponse

  """
  Adds one or more `AryaSamaj` records to the collection
  """
  insertIntoAryaSamajCollection(objects: [AryaSamajInsertInput!]!): AryaSamajInsertResponse

  """
  Adds one or more `BookOrders` records to the collection
  """
  insertIntoBookOrdersCollection(objects: [BookOrdersInsertInput!]!): BookOrdersInsertResponse

  """
  Adds one or more `Family` records to the collection
  """
  insertIntoFamilyCollection(objects: [FamilyInsertInput!]!): FamilyInsertResponse

  """
  Adds one or more `FamilyMember` records to the collection
  """
  insertIntoFamilyMemberCollection(objects: [FamilyMemberInsertInput!]!): FamilyMemberInsertResponse

  """
  Adds one or more `Learning` records to the collection
  """
  insertIntoLearningCollection(objects: [LearningInsertInput!]!): LearningInsertResponse

  """
  Adds one or more `Member` records to the collection
  """
  insertIntoMemberCollection(objects: [MemberInsertInput!]!): MemberInsertResponse

  """
  Adds one or more `Organisation` records to the collection
  """
  insertIntoOrganisationCollection(objects: [OrganisationInsertInput!]!): OrganisationInsertResponse

  """
  Adds one or more `OrganisationalActivity` records to the collection
  """
  insertIntoOrganisationalActivityCollection(objects: [OrganisationalActivityInsertInput!]!): OrganisationalActivityInsertResponse

  """
  Adds one or more `OrganisationalMember` records to the collection
  """
  insertIntoOrganisationalMemberCollection(objects: [OrganisationalMemberInsertInput!]!): OrganisationalMemberInsertResponse

  """
  Adds one or more `SamajMember` records to the collection
  """
  insertIntoSamajMemberCollection(objects: [SamajMemberInsertInput!]!): SamajMemberInsertResponse

  """
  Adds one or more `SatrRegistration` records to the collection
  """
  insertIntoSatrRegistrationCollection(objects: [SatrRegistrationInsertInput!]!): SatrRegistrationInsertResponse

  """
  Updates zero or more records in the `Activities` collection
  """
  updateActivitiesCollection("Fields that are set will be updated for all records matching the `filter`" set: ActivitiesUpdateInput!, "Restricts the mutation's impact to records matching the criteria" filter: ActivitiesFilter, "The maximum number of records in the collection permitted to be affected" atMost: Int! = 1): ActivitiesUpdateResponse!

  """
  Updates zero or more records in the `ActivityMember` collection
  """
  updateActivityMemberCollection("Fields that are set will be updated for all records matching the `filter`" set: ActivityMemberUpdateInput!, "Restricts the mutation's impact to records matching the criteria" filter: ActivityMemberFilter, "The maximum number of records in the collection permitted to be affected" atMost: Int! = 1): ActivityMemberUpdateResponse!

  """
  Updates zero or more records in the `Address` collection
  """
  updateAddressCollection("Fields that are set will be updated for all records matching the `filter`" set: AddressUpdateInput!, "Restricts the mutation's impact to records matching the criteria" filter: AddressFilter, "The maximum number of records in the collection permitted to be affected" atMost: Int! = 1): AddressUpdateResponse!

  """
  Updates zero or more records in the `Admission` collection
  """
  updateAdmissionCollection("Fields that are set will be updated for all records matching the `filter`" set: AdmissionUpdateInput!, "Restricts the mutation's impact to records matching the criteria" filter: AdmissionFilter, "The maximum number of records in the collection permitted to be affected" atMost: Int! = 1): AdmissionUpdateResponse!

  """
  Updates zero or more records in the `AppLabels` collection
  """
  updateAppLabelsCollection("Fields that are set will be updated for all records matching the `filter`" set: AppLabelsUpdateInput!, "Restricts the mutation's impact to records matching the criteria" filter: AppLabelsFilter, "The maximum number of records in the collection permitted to be affected" atMost: Int! = 1): AppLabelsUpdateResponse!

  """
  Updates zero or more records in the `AryaSamaj` collection
  """
  updateAryaSamajCollection("Fields that are set will be updated for all records matching the `filter`" set: AryaSamajUpdateInput!, "Restricts the mutation's impact to records matching the criteria" filter: AryaSamajFilter, "The maximum number of records in the collection permitted to be affected" atMost: Int! = 1): AryaSamajUpdateResponse!

  """
  Updates zero or more records in the `BookOrders` collection
  """
  updateBookOrdersCollection("Fields that are set will be updated for all records matching the `filter`" set: BookOrdersUpdateInput!, "Restricts the mutation's impact to records matching the criteria" filter: BookOrdersFilter, "The maximum number of records in the collection permitted to be affected" atMost: Int! = 1): BookOrdersUpdateResponse!

  """
  Updates zero or more records in the `Family` collection
  """
  updateFamilyCollection("Fields that are set will be updated for all records matching the `filter`" set: FamilyUpdateInput!, "Restricts the mutation's impact to records matching the criteria" filter: FamilyFilter, "The maximum number of records in the collection permitted to be affected" atMost: Int! = 1): FamilyUpdateResponse!

  """
  Updates zero or more records in the `FamilyMember` collection
  """
  updateFamilyMemberCollection("Fields that are set will be updated for all records matching the `filter`" set: FamilyMemberUpdateInput!, "Restricts the mutation's impact to records matching the criteria" filter: FamilyMemberFilter, "The maximum number of records in the collection permitted to be affected" atMost: Int! = 1): FamilyMemberUpdateResponse!

  """
  Updates zero or more records in the `Learning` collection
  """
  updateLearningCollection("Fields that are set will be updated for all records matching the `filter`" set: LearningUpdateInput!, "Restricts the mutation's impact to records matching the criteria" filter: LearningFilter, "The maximum number of records in the collection permitted to be affected" atMost: Int! = 1): LearningUpdateResponse!

  """
  Updates zero or more records in the `Member` collection
  """
  updateMemberCollection("Fields that are set will be updated for all records matching the `filter`" set: MemberUpdateInput!, "Restricts the mutation's impact to records matching the criteria" filter: MemberFilter, "The maximum number of records in the collection permitted to be affected" atMost: Int! = 1): MemberUpdateResponse!

  """
  Updates zero or more records in the `Organisation` collection
  """
  updateOrganisationCollection("Fields that are set will be updated for all records matching the `filter`" set: OrganisationUpdateInput!, "Restricts the mutation's impact to records matching the criteria" filter: OrganisationFilter, "The maximum number of records in the collection permitted to be affected" atMost: Int! = 1): OrganisationUpdateResponse!

  """
  Updates zero or more records in the `OrganisationalActivity` collection
  """
  updateOrganisationalActivityCollection("Fields that are set will be updated for all records matching the `filter`" set: OrganisationalActivityUpdateInput!, "Restricts the mutation's impact to records matching the criteria" filter: OrganisationalActivityFilter, "The maximum number of records in the collection permitted to be affected" atMost: Int! = 1): OrganisationalActivityUpdateResponse!

  """
  Updates zero or more records in the `OrganisationalMember` collection
  """
  updateOrganisationalMemberCollection("Fields that are set will be updated for all records matching the `filter`" set: OrganisationalMemberUpdateInput!, "Restricts the mutation's impact to records matching the criteria" filter: OrganisationalMemberFilter, "The maximum number of records in the collection permitted to be affected" atMost: Int! = 1): OrganisationalMemberUpdateResponse!

  """
  Updates zero or more records in the `SamajMember` collection
  """
  updateSamajMemberCollection("Fields that are set will be updated for all records matching the `filter`" set: SamajMemberUpdateInput!, "Restricts the mutation's impact to records matching the criteria" filter: SamajMemberFilter, "The maximum number of records in the collection permitted to be affected" atMost: Int! = 1): SamajMemberUpdateResponse!

  """
  Updates zero or more records in the `SatrRegistration` collection
  """
  updateSatrRegistrationCollection("Fields that are set will be updated for all records matching the `filter`" set: SatrRegistrationUpdateInput!, "Restricts the mutation's impact to records matching the criteria" filter: SatrRegistrationFilter, "The maximum number of records in the collection permitted to be affected" atMost: Int! = 1): SatrRegistrationUpdateResponse!
}

interface Node {
  """
  Retrieves a record by `ID`
  """
  nodeId: ID!
}

"""
Any type not handled by the type system
"""
scalar Opaque

"""
Boolean expression comparing fields on type "Opaque"
"""
input OpaqueFilter {
  eq: Opaque

  is: FilterIs
}

"""
Defines a per-field sorting order
"""
enum OrderByDirection {
  """
  Ascending order, nulls first
  """
  AscNullsFirst

  """
  Ascending order, nulls last
  """
  AscNullsLast

  """
  Descending order, nulls first
  """
  DescNullsFirst

  """
  Descending order, nulls last
  """
  DescNullsLast
}

type Organisation implements Node {
  """
  Globally Unique Record Identifier
  """
  nodeId: ID!

  id: String!

  name: String!

  logo: String

  description: String!

  priority: Int!

  organisationalActivityCollection("Query the first `n` records in the collection" first: Int, "Query the last `n` records in the collection" last: Int, "Query values in the collection before the provided cursor" before: Cursor, "Query values in the collection after the provided cursor" after: Cursor, "Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported." offset: Int, "Filters to apply to the results set when querying from the collection" filter: OrganisationalActivityFilter, "Sort order to apply to the collection" orderBy: [OrganisationalActivityOrderBy!]): OrganisationalActivityConnection

  organisationalMemberCollection("Query the first `n` records in the collection" first: Int, "Query the last `n` records in the collection" last: Int, "Query values in the collection before the provided cursor" before: Cursor, "Query values in the collection after the provided cursor" after: Cursor, "Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported." offset: Int, "Filters to apply to the results set when querying from the collection" filter: OrganisationalMemberFilter, "Sort order to apply to the collection" orderBy: [OrganisationalMemberOrderBy!]): OrganisationalMemberConnection
}

type OrganisationConnection {
  edges: [OrganisationEdge!]!

  pageInfo: PageInfo!
}

type OrganisationDeleteResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [Organisation!]!
}

type OrganisationEdge {
  cursor: String!

  node: Organisation!
}

input OrganisationFilter {
  id: StringFilter

  name: StringFilter

  logo: StringFilter

  description: StringFilter

  priority: IntFilter

  nodeId: IDFilter

  """
  Returns true only if all its inner filters are true, otherwise returns false
  """
  and: [OrganisationFilter!]

  """
  Returns true if at least one of its inner filters is true, otherwise returns false
  """
  or: [OrganisationFilter!]

  """
  Negates a filter
  """
  not: OrganisationFilter
}

input OrganisationInsertInput {
  id: String

  name: String

  logo: String

  description: String

  priority: Int
}

type OrganisationInsertResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [Organisation!]!
}

input OrganisationOrderBy {
  id: OrderByDirection

  name: OrderByDirection

  logo: OrderByDirection

  description: OrderByDirection

  priority: OrderByDirection
}

input OrganisationUpdateInput {
  id: String

  name: String

  logo: String

  description: String

  priority: Int
}

type OrganisationUpdateResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [Organisation!]!
}

type OrganisationalActivity implements Node {
  """
  Globally Unique Record Identifier
  """
  nodeId: ID!

  id: String!

  activityId: String!

  organisationId: String!

  activity: Activities

  organisation: Organisation
}

type OrganisationalActivityConnection {
  edges: [OrganisationalActivityEdge!]!

  pageInfo: PageInfo!
}

type OrganisationalActivityDeleteResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [OrganisationalActivity!]!
}

type OrganisationalActivityEdge {
  cursor: String!

  node: OrganisationalActivity!
}

input OrganisationalActivityFilter {
  id: StringFilter

  activityId: StringFilter

  organisationId: StringFilter

  nodeId: IDFilter

  """
  Returns true only if all its inner filters are true, otherwise returns false
  """
  and: [OrganisationalActivityFilter!]

  """
  Returns true if at least one of its inner filters is true, otherwise returns false
  """
  or: [OrganisationalActivityFilter!]

  """
  Negates a filter
  """
  not: OrganisationalActivityFilter
}

input OrganisationalActivityInsertInput {
  id: String

  activityId: String

  organisationId: String
}

type OrganisationalActivityInsertResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [OrganisationalActivity!]!
}

input OrganisationalActivityOrderBy {
  id: OrderByDirection

  activityId: OrderByDirection

  organisationId: OrderByDirection
}

input OrganisationalActivityUpdateInput {
  id: String

  activityId: String

  organisationId: String
}

type OrganisationalActivityUpdateResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [OrganisationalActivity!]!
}

type OrganisationalMember implements Node {
  """
  Globally Unique Record Identifier
  """
  nodeId: ID!

  id: String!

  organisationId: String!

  memberId: String!

  post: String

  priority: Int!

  member: Member

  organisation: Organisation
}

type OrganisationalMemberConnection {
  edges: [OrganisationalMemberEdge!]!

  pageInfo: PageInfo!
}

type OrganisationalMemberDeleteResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [OrganisationalMember!]!
}

type OrganisationalMemberEdge {
  cursor: String!

  node: OrganisationalMember!
}

input OrganisationalMemberFilter {
  id: StringFilter

  organisationId: StringFilter

  memberId: StringFilter

  post: StringFilter

  priority: IntFilter

  nodeId: IDFilter

  """
  Returns true only if all its inner filters are true, otherwise returns false
  """
  and: [OrganisationalMemberFilter!]

  """
  Returns true if at least one of its inner filters is true, otherwise returns false
  """
  or: [OrganisationalMemberFilter!]

  """
  Negates a filter
  """
  not: OrganisationalMemberFilter
}

input OrganisationalMemberInsertInput {
  id: String

  organisationId: String

  memberId: String

  post: String

  priority: Int
}

type OrganisationalMemberInsertResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [OrganisationalMember!]!
}

input OrganisationalMemberOrderBy {
  id: OrderByDirection

  organisationId: OrderByDirection

  memberId: OrderByDirection

  post: OrderByDirection

  priority: OrderByDirection
}

input OrganisationalMemberUpdateInput {
  id: String

  organisationId: String

  memberId: String

  post: String

  priority: Int
}

type OrganisationalMemberUpdateResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [OrganisationalMember!]!
}

type PageInfo {
  endCursor: String

  hasNextPage: Boolean!

  hasPreviousPage: Boolean!

  startCursor: String
}

"""
The root type for querying data
"""
type Query {
  """
  A pagable collection of type `Activities`
  """
  activitiesCollection("Query the first `n` records in the collection" first: Int, "Query the last `n` records in the collection" last: Int, "Query values in the collection before the provided cursor" before: Cursor, "Query values in the collection after the provided cursor" after: Cursor, "Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported." offset: Int, "Filters to apply to the results set when querying from the collection" filter: ActivitiesFilter, "Sort order to apply to the collection" orderBy: [ActivitiesOrderBy!]): ActivitiesConnection

  """
  A pagable collection of type `ActivityMember`
  """
  activityMemberCollection("Query the first `n` records in the collection" first: Int, "Query the last `n` records in the collection" last: Int, "Query values in the collection before the provided cursor" before: Cursor, "Query values in the collection after the provided cursor" after: Cursor, "Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported." offset: Int, "Filters to apply to the results set when querying from the collection" filter: ActivityMemberFilter, "Sort order to apply to the collection" orderBy: [ActivityMemberOrderBy!]): ActivityMemberConnection

  """
  A pagable collection of type `Address`
  """
  addressCollection("Query the first `n` records in the collection" first: Int, "Query the last `n` records in the collection" last: Int, "Query values in the collection before the provided cursor" before: Cursor, "Query values in the collection after the provided cursor" after: Cursor, "Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported." offset: Int, "Filters to apply to the results set when querying from the collection" filter: AddressFilter, "Sort order to apply to the collection" orderBy: [AddressOrderBy!]): AddressConnection

  """
  A pagable collection of type `Admission`
  """
  admissionCollection("Query the first `n` records in the collection" first: Int, "Query the last `n` records in the collection" last: Int, "Query values in the collection before the provided cursor" before: Cursor, "Query values in the collection after the provided cursor" after: Cursor, "Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported." offset: Int, "Filters to apply to the results set when querying from the collection" filter: AdmissionFilter, "Sort order to apply to the collection" orderBy: [AdmissionOrderBy!]): AdmissionConnection

  """
  A pagable collection of type `AppLabels`
  """
  appLabelsCollection("Query the first `n` records in the collection" first: Int, "Query the last `n` records in the collection" last: Int, "Query values in the collection before the provided cursor" before: Cursor, "Query values in the collection after the provided cursor" after: Cursor, "Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported." offset: Int, "Filters to apply to the results set when querying from the collection" filter: AppLabelsFilter, "Sort order to apply to the collection" orderBy: [AppLabelsOrderBy!]): AppLabelsConnection

  """
  A pagable collection of type `AryaSamaj`
  """
  aryaSamajCollection("Query the first `n` records in the collection" first: Int, "Query the last `n` records in the collection" last: Int, "Query values in the collection before the provided cursor" before: Cursor, "Query values in the collection after the provided cursor" after: Cursor, "Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported." offset: Int, "Filters to apply to the results set when querying from the collection" filter: AryaSamajFilter, "Sort order to apply to the collection" orderBy: [AryaSamajOrderBy!]): AryaSamajConnection

  """
  A pagable collection of type `BookOrders`
  """
  bookOrdersCollection("Query the first `n` records in the collection" first: Int, "Query the last `n` records in the collection" last: Int, "Query values in the collection before the provided cursor" before: Cursor, "Query values in the collection after the provided cursor" after: Cursor, "Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported." offset: Int, "Filters to apply to the results set when querying from the collection" filter: BookOrdersFilter, "Sort order to apply to the collection" orderBy: [BookOrdersOrderBy!]): BookOrdersConnection

  """
  A pagable collection of type `Family`
  """
  familyCollection("Query the first `n` records in the collection" first: Int, "Query the last `n` records in the collection" last: Int, "Query values in the collection before the provided cursor" before: Cursor, "Query values in the collection after the provided cursor" after: Cursor, "Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported." offset: Int, "Filters to apply to the results set when querying from the collection" filter: FamilyFilter, "Sort order to apply to the collection" orderBy: [FamilyOrderBy!]): FamilyConnection

  """
  A pagable collection of type `FamilyMember`
  """
  familyMemberCollection("Query the first `n` records in the collection" first: Int, "Query the last `n` records in the collection" last: Int, "Query values in the collection before the provided cursor" before: Cursor, "Query values in the collection after the provided cursor" after: Cursor, "Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported." offset: Int, "Filters to apply to the results set when querying from the collection" filter: FamilyMemberFilter, "Sort order to apply to the collection" orderBy: [FamilyMemberOrderBy!]): FamilyMemberConnection

  """
  A pagable collection of type `Learning`
  """
  learningCollection("Query the first `n` records in the collection" first: Int, "Query the last `n` records in the collection" last: Int, "Query values in the collection before the provided cursor" before: Cursor, "Query values in the collection after the provided cursor" after: Cursor, "Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported." offset: Int, "Filters to apply to the results set when querying from the collection" filter: LearningFilter, "Sort order to apply to the collection" orderBy: [LearningOrderBy!]): LearningConnection

  """
  A pagable collection of type `Member`
  """
  memberCollection("Query the first `n` records in the collection" first: Int, "Query the last `n` records in the collection" last: Int, "Query values in the collection before the provided cursor" before: Cursor, "Query values in the collection after the provided cursor" after: Cursor, "Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported." offset: Int, "Filters to apply to the results set when querying from the collection" filter: MemberFilter, "Sort order to apply to the collection" orderBy: [MemberOrderBy!]): MemberConnection

  """
  Retrieve a record by its `ID`
  """
  node("The record's `ID`" nodeId: ID!): Node

  """
  A pagable collection of type `Organisation`
  """
  organisationCollection("Query the first `n` records in the collection" first: Int, "Query the last `n` records in the collection" last: Int, "Query values in the collection before the provided cursor" before: Cursor, "Query values in the collection after the provided cursor" after: Cursor, "Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported." offset: Int, "Filters to apply to the results set when querying from the collection" filter: OrganisationFilter, "Sort order to apply to the collection" orderBy: [OrganisationOrderBy!]): OrganisationConnection

  """
  A pagable collection of type `OrganisationalActivity`
  """
  organisationalActivityCollection("Query the first `n` records in the collection" first: Int, "Query the last `n` records in the collection" last: Int, "Query values in the collection before the provided cursor" before: Cursor, "Query values in the collection after the provided cursor" after: Cursor, "Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported." offset: Int, "Filters to apply to the results set when querying from the collection" filter: OrganisationalActivityFilter, "Sort order to apply to the collection" orderBy: [OrganisationalActivityOrderBy!]): OrganisationalActivityConnection

  """
  A pagable collection of type `OrganisationalMember`
  """
  organisationalMemberCollection("Query the first `n` records in the collection" first: Int, "Query the last `n` records in the collection" last: Int, "Query values in the collection before the provided cursor" before: Cursor, "Query values in the collection after the provided cursor" after: Cursor, "Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported." offset: Int, "Filters to apply to the results set when querying from the collection" filter: OrganisationalMemberFilter, "Sort order to apply to the collection" orderBy: [OrganisationalMemberOrderBy!]): OrganisationalMemberConnection

  """
  A pagable collection of type `SamajMember`
  """
  samajMemberCollection("Query the first `n` records in the collection" first: Int, "Query the last `n` records in the collection" last: Int, "Query values in the collection before the provided cursor" before: Cursor, "Query values in the collection after the provided cursor" after: Cursor, "Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported." offset: Int, "Filters to apply to the results set when querying from the collection" filter: SamajMemberFilter, "Sort order to apply to the collection" orderBy: [SamajMemberOrderBy!]): SamajMemberConnection

  """
  A pagable collection of type `SatrRegistration`
  """
  satrRegistrationCollection("Query the first `n` records in the collection" first: Int, "Query the last `n` records in the collection" last: Int, "Query values in the collection before the provided cursor" before: Cursor, "Query values in the collection after the provided cursor" after: Cursor, "Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported." offset: Int, "Filters to apply to the results set when querying from the collection" filter: SatrRegistrationFilter, "Sort order to apply to the collection" orderBy: [SatrRegistrationOrderBy!]): SatrRegistrationConnection
}

type SamajMember implements Node {
  """
  Globally Unique Record Identifier
  """
  nodeId: ID!

  id: String!

  createdAt: Datetime!

  memberId: String

  aryaSamajId: String

  post: String

  priority: Int

  member: Member

  aryaSamaj: AryaSamaj
}

type SamajMemberConnection {
  edges: [SamajMemberEdge!]!

  pageInfo: PageInfo!
}

type SamajMemberDeleteResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [SamajMember!]!
}

type SamajMemberEdge {
  cursor: String!

  node: SamajMember!
}

input SamajMemberFilter {
  id: StringFilter

  createdAt: DatetimeFilter

  memberId: StringFilter

  aryaSamajId: StringFilter

  post: StringFilter

  priority: IntFilter

  nodeId: IDFilter

  """
  Returns true only if all its inner filters are true, otherwise returns false
  """
  and: [SamajMemberFilter!]

  """
  Returns true if at least one of its inner filters is true, otherwise returns false
  """
  or: [SamajMemberFilter!]

  """
  Negates a filter
  """
  not: SamajMemberFilter
}

input SamajMemberInsertInput {
  id: String

  createdAt: Datetime

  memberId: String

  aryaSamajId: String

  post: String

  priority: Int
}

type SamajMemberInsertResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [SamajMember!]!
}

input SamajMemberOrderBy {
  id: OrderByDirection

  createdAt: OrderByDirection

  memberId: OrderByDirection

  aryaSamajId: OrderByDirection

  post: OrderByDirection

  priority: OrderByDirection
}

input SamajMemberUpdateInput {
  id: String

  createdAt: Datetime

  memberId: String

  aryaSamajId: String

  post: String

  priority: Int
}

type SamajMemberUpdateResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [SamajMember!]!
}

type SatrRegistration implements Node {
  """
  Globally Unique Record Identifier
  """
  nodeId: ID!

  id: UUID!

  createdAt: Datetime!

  fullname: String!

  gender: String!

  mobile: String!

  aadharNo: String

  educationalQualification: String

  address: String

  inspirationSource: String

  inspirationSourceName: String

  inspirationSourceNo: String

  hasTrainedAryaInFamily: Boolean

  trainedAryaName: String

  trainedAryaNo: String

  activityId: String!

  activity: Activities
}

type SatrRegistrationConnection {
  edges: [SatrRegistrationEdge!]!

  pageInfo: PageInfo!
}

type SatrRegistrationDeleteResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [SatrRegistration!]!
}

type SatrRegistrationEdge {
  cursor: String!

  node: SatrRegistration!
}

input SatrRegistrationFilter {
  id: UUIDFilter

  createdAt: DatetimeFilter

  fullname: StringFilter

  gender: StringFilter

  mobile: StringFilter

  aadharNo: StringFilter

  educationalQualification: StringFilter

  address: StringFilter

  inspirationSource: StringFilter

  inspirationSourceName: StringFilter

  inspirationSourceNo: StringFilter

  hasTrainedAryaInFamily: BooleanFilter

  trainedAryaName: StringFilter

  trainedAryaNo: StringFilter

  activityId: StringFilter

  nodeId: IDFilter

  """
  Returns true only if all its inner filters are true, otherwise returns false
  """
  and: [SatrRegistrationFilter!]

  """
  Returns true if at least one of its inner filters is true, otherwise returns false
  """
  or: [SatrRegistrationFilter!]

  """
  Negates a filter
  """
  not: SatrRegistrationFilter
}

input SatrRegistrationInsertInput {
  id: UUID

  createdAt: Datetime

  fullname: String

  gender: String

  mobile: String

  aadharNo: String

  educationalQualification: String

  address: String

  inspirationSource: String

  inspirationSourceName: String

  inspirationSourceNo: String

  hasTrainedAryaInFamily: Boolean

  trainedAryaName: String

  trainedAryaNo: String

  activityId: String
}

type SatrRegistrationInsertResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [SatrRegistration!]!
}

input SatrRegistrationOrderBy {
  id: OrderByDirection

  createdAt: OrderByDirection

  fullname: OrderByDirection

  gender: OrderByDirection

  mobile: OrderByDirection

  aadharNo: OrderByDirection

  educationalQualification: OrderByDirection

  address: OrderByDirection

  inspirationSource: OrderByDirection

  inspirationSourceName: OrderByDirection

  inspirationSourceNo: OrderByDirection

  hasTrainedAryaInFamily: OrderByDirection

  trainedAryaName: OrderByDirection

  trainedAryaNo: OrderByDirection

  activityId: OrderByDirection
}

input SatrRegistrationUpdateInput {
  id: UUID

  createdAt: Datetime

  fullname: String

  gender: String

  mobile: String

  aadharNo: String

  educationalQualification: String

  address: String

  inspirationSource: String

  inspirationSourceName: String

  inspirationSourceNo: String

  hasTrainedAryaInFamily: Boolean

  trainedAryaName: String

  trainedAryaNo: String

  activityId: String
}

type SatrRegistrationUpdateResponse {
  """
  Count of the records impacted by the mutation
  """
  affectedCount: Int!

  """
  Array of records impacted by the mutation
  """
  records: [SatrRegistration!]!
}

"""
Boolean expression comparing fields on type "String"
"""
input StringFilter {
  eq: String

  gt: String

  gte: String

  ilike: String

  in: [String!]

  iregex: String

  is: FilterIs

  like: String

  lt: String

  lte: String

  neq: String

  regex: String

  startsWith: String
}

"""
Boolean expression comparing fields on type "StringList"
"""
input StringListFilter {
  containedBy: [String!]

  contains: [String!]

  eq: [String!]

  is: FilterIs

  overlaps: [String!]
}

"""
A time without date information
"""
scalar Time

"""
Boolean expression comparing fields on type "Time"
"""
input TimeFilter {
  eq: Time

  gt: Time

  gte: Time

  in: [Time!]

  is: FilterIs

  lt: Time

  lte: Time

  neq: Time
}

"""
Boolean expression comparing fields on type "TimeList"
"""
input TimeListFilter {
  containedBy: [Time!]

  contains: [Time!]

  eq: [Time!]

  is: FilterIs

  overlaps: [Time!]
}

"""
A universally unique identifier
"""
scalar UUID

"""
Boolean expression comparing fields on type "UUID"
"""
input UUIDFilter {
  eq: UUID

  in: [UUID!]

  is: FilterIs

  neq: UUID
}

"""
Boolean expression comparing fields on type "UUIDList"
"""
input UUIDListFilter {
  containedBy: [UUID!]

  contains: [UUID!]

  eq: [UUID!]

  is: FilterIs

  overlaps: [UUID!]
}

"""
A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.
"""
type __Directive {
  args(includeDeprecated: Boolean = false): [__InputValue!]!

  description: String

  isRepeatable: Boolean!

  locations: [__DirectiveLocation!]!

  name: String!
}

"""
A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.
"""
enum __DirectiveLocation {
  """
  Location adjacent to a query operation.
  """
  QUERY

  """
  Location adjacent to a mutation operation.
  """
  MUTATION

  """
  Location adjacent to a subscription operation.
  """
  SUBSCRIPTION

  """
  Location adjacent to a field.
  """
  FIELD

  """
  Location adjacent to a fragment definition.
  """
  FRAGMENT_DEFINITION

  """
  Location adjacent to a fragment spread.
  """
  FRAGMENT_SPREAD

  """
  Location adjacent to an inline fragment.
  """
  INLINE_FRAGMENT

  """
  Location adjacent to a variable definition.
  """
  VARIABLE_DEFINITION

  """
  Location adjacent to a schema definition.
  """
  SCHEMA

  """
  Location adjacent to a scalar definition.
  """
  SCALAR

  """
  Location adjacent to an object type definition.
  """
  OBJECT

  """
  Location adjacent to a field definition.
  """
  FIELD_DEFINITION

  """
  Location adjacent to an argument definition.
  """
  ARGUMENT_DEFINITION

  """
  Location adjacent to an interface definition.
  """
  INTERFACE

  """
  Location adjacent to a union definition.
  """
  UNION

  """
  Location adjacent to an enum definition.
  """
  ENUM

  """
  Location adjacent to an enum value definition.
  """
  ENUM_VALUE

  """
  Location adjacent to an input object type definition.
  """
  INPUT_OBJECT

  """
  Location adjacent to an input object field definition.
  """
  INPUT_FIELD_DEFINITION
}

"""
One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.
"""
type __EnumValue {
  deprecationReason: String

  description: String

  isDeprecated: Boolean!

  name: String!
}

"""
Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.
"""
type __Field {
  args(includeDeprecated: Boolean = false): [__InputValue!]!

  deprecationReason: String

  description: String

  isDeprecated: Boolean!

  name: String!

  type: __Type!
}

"""
Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.
"""
type __InputValue {
  """
  A GraphQL-formatted string representing the default value for this input value.
  """
  defaultValue: String

  deprecationReason: String

  description: String

  isDeprecated: Boolean!

  name: String!

  type: __Type!
}

"""
A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.
"""
type __Schema {
  description: String

  """
  A list of all directives supported by this server.
  """
  directives(includeDeprecated: Boolean = false): [__Directive!]!

  """
  If this server supports mutation, the type that mutation operations will be rooted at.
  """
  mutationType: __Type

  """
  The type that query operations will be rooted at.
  """
  queryType: __Type!

  """
  If this server support subscription, the type that subscription operations will be rooted at.
  """
  subscriptionType: __Type

  """
  A list of all types supported by this server.
  """
  types: [__Type!]!
}

"""
The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types 
"""
type __Type {
  description: String

  enumValues(includeDeprecated: Boolean = false): [__EnumValue!]

  fields(includeDeprecated: Boolean = false): [__Field!]

  inputFields(includeDeprecated: Boolean = false): [__InputValue!]

  interfaces: [__Type!]

  kind: __TypeKind!

  name: String

  ofType: __Type

  possibleTypes: [__Type!]

  specifiedByURL: String
}

"""
An enum describing what kind of type a given `__Type` is.
"""
enum __TypeKind {
  SCALAR

  OBJECT

  INTERFACE

  UNION

  ENUM

  INPUT_OBJECT

  LIST

  NON_NULL
}

"""
This field or fragment will be included only when the `if` argument is true.
"""
directive @include ("Included when true" if: Boolean!) on FIELD|FRAGMENT_SPREAD|INLINE_FRAGMENT

"""
This field or fragment will be skipped when the `if` argument is true.
"""
directive @skip ("Skipped when true" if: Boolean!) on FIELD|FRAGMENT_SPREAD|INLINE_FRAGMENT

schema {
  query: Query
  mutation: Mutation
}
