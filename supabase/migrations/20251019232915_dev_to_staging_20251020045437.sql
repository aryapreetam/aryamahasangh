create extension if not exists "http" with schema "public" version '1.6';

create type "public"."activity_type" as enum ('SESSION', 'CAMP', 'COURSE', 'EVENT', 'CAMPAIGN');

create type "public"."family_relation" as enum ('SELF', 'FATHER', 'MOTHER', 'HUSBAND', 'WIFE', 'SON', 'DAUGHTER', 'BROTHER', 'SISTER', 'GRANDFATHER', 'GRANDMOTHER', 'GRANDSON', 'GRANDDAUGHTER', 'UNCLE', 'AUNT', 'COUSIN', 'NEPHEW', 'NIECE', 'GUARDIAN', 'RELATIVE', 'OTHER');

create type "public"."gender_filter" as enum ('MALE', 'FEMALE', 'ANY');

create sequence "public"."storage_cleanup_queue_id_seq";

create sequence "public"."trigger_debug_log_id_seq";

create table "public"."activities" (
    "id" text not null default gen_random_uuid(),
    "name" text not null,
    "type" activity_type not null default 'EVENT'::activity_type,
    "short_description" text not null,
    "long_description" text not null,
    "start_datetime" timestamp with time zone not null,
    "end_datetime" timestamp with time zone not null,
    "media_files" text[] not null default '{}'::text[],
    "additional_instructions" text default ''::text,
    "capacity" integer default 100,
    "allowed_gender" gender_filter default 'ANY'::gender_filter,
    "overview_description" text default ''::text,
    "overview_media_urls" text[] not null default '{}'::text[],
    "address_id" text
);


alter table "public"."activities" enable row level security;

create table "public"."activity_member" (
    "id" uuid not null default gen_random_uuid(),
    "activity_id" text not null,
    "member_id" text not null,
    "post" text,
    "priority" smallint not null
);


alter table "public"."activity_member" enable row level security;

create table "public"."address" (
    "id" text not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "basic_address" text,
    "state" text,
    "district" text,
    "pincode" text,
    "latitude" double precision,
    "longitude" double precision,
    "vidhansabha" text
);


alter table "public"."address" enable row level security;

create table "public"."admission" (
    "id" text not null default gen_random_uuid(),
    "studentName" text,
    "aadharNo" text,
    "dob" text,
    "bloodGroup" text,
    "previousClass" text,
    "marksObtained" text,
    "schoolName" text,
    "fatherName" text,
    "fatherOccupation" text,
    "fatherQualification" text,
    "motherName" text,
    "motherOccupation" text,
    "motherQualification" text,
    "fullAddress" text,
    "mobileNo" text,
    "alternateMobileNo" text,
    "attachedDocuments" text[],
    "studentPhoto" text,
    "studentSignature" text,
    "parentSignature" text
);


create table "public"."app_labels" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "label_key" text,
    "label_value" text
);


alter table "public"."app_labels" enable row level security;

create table "public"."arya_samaj" (
    "id" text not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "name" text not null,
    "description" text not null,
    "media_urls" text[] not null default '{}'::text[],
    "address_id" text
);


alter table "public"."arya_samaj" enable row level security;

create table "public"."book_orders" (
    "id" uuid not null default gen_random_uuid(),
    "fullname" text not null,
    "address" text,
    "city" text,
    "district" text,
    "state" text,
    "mobile" text,
    "pincode" text,
    "country" text,
    "district_officer_name" text,
    "district_officer_number" text,
    "payment_receipt_url" text,
    "is_fulfilled" boolean default false,
    "created_at" timestamp with time zone default now()
);


create table "public"."course_registrations" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "name" text,
    "satr_date" timestamp with time zone default now(),
    "satr_place" text default ''::text,
    "recommendation" text,
    "activity_id" text,
    "payment_receipt_url" text
);


alter table "public"."course_registrations" enable row level security;

create table "public"."family" (
    "id" text not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "address_id" text,
    "arya_samaj_id" text,
    "name" text,
    "photos" text[],
    "updated_at" timestamp with time zone default now()
);


alter table "public"."family" enable row level security;

create table "public"."family_member" (
    "id" text not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "family_id" text not null,
    "member_id" text not null,
    "is_head" boolean not null default false,
    "relation_to_head" family_relation not null
);


alter table "public"."family_member" enable row level security;

create table "public"."learning" (
    "id" text not null default gen_random_uuid(),
    "title" text,
    "description" text,
    "url" text,
    "thumbnail_url" text,
    "video_id" text
);


create table "public"."member" (
    "id" text not null default gen_random_uuid(),
    "name" text not null,
    "profile_image" text,
    "educational_qualification" text,
    "phone_number" text not null default ''::text,
    "email" text,
    "dob" date,
    "address_id" text,
    "arya_samaj_id" text,
    "joining_date" date,
    "temp_address_id" text,
    "referrer_id" text,
    "occupation" text,
    "introduction" text,
    "gender" gender_filter,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
);


alter table "public"."member" enable row level security;

create table "public"."organisation" (
    "id" text not null default gen_random_uuid(),
    "name" text not null,
    "logo" text,
    "description" text not null,
    "priority" smallint not null default '0'::smallint
);


alter table "public"."organisation" enable row level security;

create table "public"."organisational_activity" (
    "id" text not null default gen_random_uuid(),
    "activity_id" text not null,
    "organisation_id" text not null
);


alter table "public"."organisational_activity" enable row level security;

create table "public"."organisational_member" (
    "id" text not null default gen_random_uuid(),
    "organisation_id" text not null,
    "member_id" text not null,
    "post" text,
    "priority" smallint not null
);


alter table "public"."organisational_member" enable row level security;

create table "public"."samaj_member" (
    "id" text not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "member_id" text,
    "arya_samaj_id" text,
    "post" text,
    "priority" smallint
);


alter table "public"."samaj_member" enable row level security;

create table "public"."satr_registration" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
    "fullname" text not null,
    "gender" text not null,
    "mobile" text not null,
    "aadhar_no" text,
    "educational_qualification" text,
    "address" text,
    "inspiration_source" text,
    "inspiration_source_name" text,
    "inspiration_source_no" text,
    "has_trained_arya_in_family" boolean,
    "trained_arya_name" text,
    "trained_arya_no" text,
    "activity_id" text not null
);


alter table "public"."satr_registration" enable row level security;

create table "public"."storage_cleanup_queue" (
    "id" integer not null default nextval('storage_cleanup_queue_id_seq'::regclass),
    "created_at" timestamp without time zone default now(),
    "processed_at" timestamp without time zone,
    "table_name" text not null,
    "operation" text not null,
    "record_id" text not null,
    "file_urls" text[] not null,
    "status" text default 'pending'::text,
    "error_message" text
);


create table "public"."trigger_debug_log" (
    "id" integer not null default nextval('trigger_debug_log_id_seq'::regclass),
    "created_at" timestamp without time zone default now(),
    "trigger_name" text,
    "table_name" text,
    "operation" text,
    "old_record_id" text,
    "message" text
);


create table "public"."user_activity_log" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "user_email" text,
    "action_name" text not null,
    "primary_entity_table" text not null,
    "primary_entity_id" text not null,
    "affected_tables" text[],
    "operation_context" text default 'DIRECT_ACTION'::text,
    "is_bulk" boolean default false,
    "record_count" integer default 1,
    "changed_fields" jsonb,
    "metadata" jsonb,
    "performed_at" timestamp with time zone default now(),
    "transaction_id" bigint default txid_current()
);


alter table "public"."user_activity_log" enable row level security;

alter sequence "public"."storage_cleanup_queue_id_seq" owned by "public"."storage_cleanup_queue"."id";

alter sequence "public"."trigger_debug_log_id_seq" owned by "public"."trigger_debug_log"."id";

CREATE UNIQUE INDEX activities_pkey ON public.activities USING btree (id);

CREATE UNIQUE INDEX activity_member_pkey ON public.activity_member USING btree (id);

CREATE UNIQUE INDEX address_pkey ON public.address USING btree (id);

CREATE UNIQUE INDEX admission_pkey ON public.admission USING btree (id);

CREATE UNIQUE INDEX app_labels_pkey ON public.app_labels USING btree (id);

CREATE UNIQUE INDEX arya_samaj_pkey ON public.arya_samaj USING btree (id);

CREATE UNIQUE INDEX book_orders_pkey ON public.book_orders USING btree (id);

CREATE UNIQUE INDEX course_registrations_pkey ON public.course_registrations USING btree (id);

CREATE UNIQUE INDEX family_member_member_id_key ON public.family_member USING btree (member_id);

CREATE UNIQUE INDEX family_member_pkey ON public.family_member USING btree (id);

CREATE UNIQUE INDEX family_pkey ON public.family USING btree (id);

CREATE INDEX idx_user_activity_action ON public.user_activity_log USING btree (action_name, performed_at DESC);

CREATE INDEX idx_user_activity_email ON public.user_activity_log USING btree (user_email, performed_at DESC);

CREATE INDEX idx_user_activity_entity ON public.user_activity_log USING btree (primary_entity_table, primary_entity_id, performed_at DESC);

CREATE INDEX idx_user_activity_transaction ON public.user_activity_log USING btree (transaction_id);

CREATE INDEX idx_user_activity_user_time ON public.user_activity_log USING btree (user_id, performed_at DESC);

CREATE UNIQUE INDEX learning_pkey ON public.learning USING btree (id);

CREATE UNIQUE INDEX member_pkey ON public.member USING btree (id);

CREATE UNIQUE INDEX organisation_pkey ON public.organisation USING btree (id);

CREATE UNIQUE INDEX organisational_activity_pkey ON public.organisational_activity USING btree (id);

CREATE UNIQUE INDEX organisational_member_pkey ON public.organisational_member USING btree (id, organisation_id, member_id);

CREATE UNIQUE INDEX samaj_member_pkey ON public.samaj_member USING btree (id);

CREATE UNIQUE INDEX satr_registration_pkey ON public.satr_registration USING btree (id);

CREATE UNIQUE INDEX storage_cleanup_queue_pkey ON public.storage_cleanup_queue USING btree (id);

CREATE UNIQUE INDEX trigger_debug_log_pkey ON public.trigger_debug_log USING btree (id);

CREATE UNIQUE INDEX unique_activity_member ON public.activity_member USING btree (member_id, activity_id);

CREATE UNIQUE INDEX unique_organisation_activity ON public.organisational_activity USING btree (organisation_id, activity_id);

CREATE UNIQUE INDEX unique_organisation_member ON public.organisational_member USING btree (organisation_id, member_id);

CREATE UNIQUE INDEX unique_transaction_action ON public.user_activity_log USING btree (transaction_id, action_name, primary_entity_id);

CREATE UNIQUE INDEX user_activity_log_pkey ON public.user_activity_log USING btree (id);

alter table "public"."activities" add constraint "activities_pkey" PRIMARY KEY using index "activities_pkey";

alter table "public"."activity_member" add constraint "activity_member_pkey" PRIMARY KEY using index "activity_member_pkey";

alter table "public"."address" add constraint "address_pkey" PRIMARY KEY using index "address_pkey";

alter table "public"."admission" add constraint "admission_pkey" PRIMARY KEY using index "admission_pkey";

alter table "public"."app_labels" add constraint "app_labels_pkey" PRIMARY KEY using index "app_labels_pkey";

alter table "public"."arya_samaj" add constraint "arya_samaj_pkey" PRIMARY KEY using index "arya_samaj_pkey";

alter table "public"."book_orders" add constraint "book_orders_pkey" PRIMARY KEY using index "book_orders_pkey";

alter table "public"."course_registrations" add constraint "course_registrations_pkey" PRIMARY KEY using index "course_registrations_pkey";

alter table "public"."family" add constraint "family_pkey" PRIMARY KEY using index "family_pkey";

alter table "public"."family_member" add constraint "family_member_pkey" PRIMARY KEY using index "family_member_pkey";

alter table "public"."learning" add constraint "learning_pkey" PRIMARY KEY using index "learning_pkey";

alter table "public"."member" add constraint "member_pkey" PRIMARY KEY using index "member_pkey";

alter table "public"."organisation" add constraint "organisation_pkey" PRIMARY KEY using index "organisation_pkey";

alter table "public"."organisational_activity" add constraint "organisational_activity_pkey" PRIMARY KEY using index "organisational_activity_pkey";

alter table "public"."organisational_member" add constraint "organisational_member_pkey" PRIMARY KEY using index "organisational_member_pkey";

alter table "public"."samaj_member" add constraint "samaj_member_pkey" PRIMARY KEY using index "samaj_member_pkey";

alter table "public"."satr_registration" add constraint "satr_registration_pkey" PRIMARY KEY using index "satr_registration_pkey";

alter table "public"."storage_cleanup_queue" add constraint "storage_cleanup_queue_pkey" PRIMARY KEY using index "storage_cleanup_queue_pkey";

alter table "public"."trigger_debug_log" add constraint "trigger_debug_log_pkey" PRIMARY KEY using index "trigger_debug_log_pkey";

alter table "public"."user_activity_log" add constraint "user_activity_log_pkey" PRIMARY KEY using index "user_activity_log_pkey";

alter table "public"."activities" add constraint "activities_address_id_fkey" FOREIGN KEY (address_id) REFERENCES address(id) not valid;

alter table "public"."activities" validate constraint "activities_address_id_fkey";

alter table "public"."activity_member" add constraint "activity_member_activity_id_fkey" FOREIGN KEY (activity_id) REFERENCES activities(id) ON DELETE CASCADE not valid;

alter table "public"."activity_member" validate constraint "activity_member_activity_id_fkey";

alter table "public"."activity_member" add constraint "activity_member_memberId_fkey" FOREIGN KEY (member_id) REFERENCES member(id) not valid;

alter table "public"."activity_member" validate constraint "activity_member_memberId_fkey";

alter table "public"."activity_member" add constraint "activity_member_memberid_fkey" FOREIGN KEY (member_id) REFERENCES member(id) not valid;

alter table "public"."activity_member" validate constraint "activity_member_memberid_fkey";

alter table "public"."arya_samaj" add constraint "arya_samaj_address_id_fkey" FOREIGN KEY (address_id) REFERENCES address(id) not valid;

alter table "public"."arya_samaj" validate constraint "arya_samaj_address_id_fkey";

alter table "public"."course_registrations" add constraint "course_registrations_activity_id_fkey" FOREIGN KEY (activity_id) REFERENCES activities(id) ON DELETE CASCADE not valid;

alter table "public"."course_registrations" validate constraint "course_registrations_activity_id_fkey";

alter table "public"."family" add constraint "family_address_id_fkey" FOREIGN KEY (address_id) REFERENCES address(id) not valid;

alter table "public"."family" validate constraint "family_address_id_fkey";

alter table "public"."family" add constraint "family_arya_samaj_id_fkey" FOREIGN KEY (arya_samaj_id) REFERENCES arya_samaj(id) ON DELETE SET NULL not valid;

alter table "public"."family" validate constraint "family_arya_samaj_id_fkey";

alter table "public"."family_member" add constraint "family_member_family_id_fkey" FOREIGN KEY (family_id) REFERENCES family(id) ON DELETE CASCADE not valid;

alter table "public"."family_member" validate constraint "family_member_family_id_fkey";

alter table "public"."family_member" add constraint "family_member_member_id_fkey" FOREIGN KEY (member_id) REFERENCES member(id) ON DELETE CASCADE not valid;

alter table "public"."family_member" validate constraint "family_member_member_id_fkey";

alter table "public"."family_member" add constraint "family_member_member_id_key" UNIQUE using index "family_member_member_id_key";

alter table "public"."member" add constraint "member_address_id_fkey" FOREIGN KEY (address_id) REFERENCES address(id) not valid;

alter table "public"."member" validate constraint "member_address_id_fkey";

alter table "public"."member" add constraint "member_arya_samaj_id_fkey" FOREIGN KEY (arya_samaj_id) REFERENCES arya_samaj(id) ON DELETE SET NULL not valid;

alter table "public"."member" validate constraint "member_arya_samaj_id_fkey";

alter table "public"."member" add constraint "member_referrer_id_fkey" FOREIGN KEY (referrer_id) REFERENCES member(id) not valid;

alter table "public"."member" validate constraint "member_referrer_id_fkey";

alter table "public"."member" add constraint "member_temp_address_id_fkey" FOREIGN KEY (temp_address_id) REFERENCES address(id) not valid;

alter table "public"."member" validate constraint "member_temp_address_id_fkey";

alter table "public"."organisational_activity" add constraint "organisational_activity_activity_id_fkey" FOREIGN KEY (activity_id) REFERENCES activities(id) ON DELETE CASCADE not valid;

alter table "public"."organisational_activity" validate constraint "organisational_activity_activity_id_fkey";

alter table "public"."organisational_activity" add constraint "organisational_activity_organisationId_fkey" FOREIGN KEY (organisation_id) REFERENCES organisation(id) not valid;

alter table "public"."organisational_activity" validate constraint "organisational_activity_organisationId_fkey";

alter table "public"."organisational_activity" add constraint "organisational_activity_organisationid_fkey" FOREIGN KEY (organisation_id) REFERENCES organisation(id) not valid;

alter table "public"."organisational_activity" validate constraint "organisational_activity_organisationid_fkey";

alter table "public"."organisational_member" add constraint "organisational_member_member_id_fkey" FOREIGN KEY (member_id) REFERENCES member(id) ON DELETE CASCADE not valid;

alter table "public"."organisational_member" validate constraint "organisational_member_member_id_fkey";

alter table "public"."organisational_member" add constraint "organisational_member_organisation_id_fkey" FOREIGN KEY (organisation_id) REFERENCES organisation(id) ON DELETE CASCADE not valid;

alter table "public"."organisational_member" validate constraint "organisational_member_organisation_id_fkey";

alter table "public"."samaj_member" add constraint "samaj_member_arya_samaj_id_fkey" FOREIGN KEY (arya_samaj_id) REFERENCES arya_samaj(id) ON DELETE CASCADE not valid;

alter table "public"."samaj_member" validate constraint "samaj_member_arya_samaj_id_fkey";

alter table "public"."samaj_member" add constraint "samaj_member_member_id_fkey" FOREIGN KEY (member_id) REFERENCES member(id) ON DELETE CASCADE not valid;

alter table "public"."samaj_member" validate constraint "samaj_member_member_id_fkey";

alter table "public"."satr_registration" add constraint "satr_registration_activity_id_fkey" FOREIGN KEY (activity_id) REFERENCES activities(id) ON DELETE CASCADE not valid;

alter table "public"."satr_registration" validate constraint "satr_registration_activity_id_fkey";

alter table "public"."user_activity_log" add constraint "unique_transaction_action" UNIQUE using index "unique_transaction_action";

alter table "public"."user_activity_log" add constraint "user_activity_log_action_name_check" CHECK ((action_name ~ '^[A-Z][A-Z0-9_]*$'::text)) not valid;

alter table "public"."user_activity_log" validate constraint "user_activity_log_action_name_check";

alter table "public"."user_activity_log" add constraint "user_activity_log_operation_context_check" CHECK ((operation_context = ANY (ARRAY['DIRECT_ACTION'::text, 'BULK_OPERATION'::text, 'CASCADING'::text]))) not valid;

alter table "public"."user_activity_log" validate constraint "user_activity_log_operation_context_check";

set check_function_bodies = off;

create or replace view "public"."activities_with_status" as  SELECT activities.id,
    activities.name,
    activities.short_description,
    activities.start_datetime,
    activities.end_datetime,
    activities.type,
    activities.allowed_gender,
    address.district,
    address.state,
        CASE
            WHEN ((now() >= activities.start_datetime) AND (now() <= activities.end_datetime)) THEN 0
            WHEN (now() < activities.start_datetime) THEN 1
            ELSE 2
        END AS status_priority
   FROM (activities
     LEFT JOIN address ON ((activities.address_id = address.id)));


CREATE OR REPLACE FUNCTION public.analyze_activity_performance()
 RETURNS TABLE(metric text, value bigint, description text)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        'total_activities'::TEXT,
        COUNT(*)::BIGINT,
        'Total number of logged activities'::TEXT
    FROM user_activity_log
    
    UNION ALL
    
    SELECT 
        'unique_users'::TEXT,
        COUNT(DISTINCT user_id)::BIGINT,
        'Number of unique users with activity'::TEXT
    FROM user_activity_log
    
    UNION ALL
    
    SELECT 
        'bulk_operations'::TEXT,
        COUNT(*)::BIGINT,
        'Number of bulk operations detected'::TEXT
    FROM user_activity_log
    WHERE is_bulk = true
    
    UNION ALL
    
    SELECT 
        'last_24h_activities'::TEXT,
        COUNT(*)::BIGINT,
        'Activities in the last 24 hours'::TEXT
    FROM user_activity_log
    WHERE performed_at >= NOW() - INTERVAL '24 hours'
    
    UNION ALL
    
    SELECT 
        'avg_daily_activities'::TEXT,
        COALESCE(AVG(daily_count)::BIGINT, 0),
        'Average daily activity count'::TEXT
    FROM (
        SELECT DATE(performed_at) as activity_date, COUNT(*) as daily_count
        FROM user_activity_log
        WHERE performed_at >= NOW() - INTERVAL '30 days'
        GROUP BY DATE(performed_at)
    ) daily_stats;
END;
$function$
;

create or replace view "public"."arya_samaj_with_address" as  SELECT s.id,
    s.name,
    s.media_urls,
    s.created_at,
    s.description,
    a.basic_address,
    a.state,
    a.district,
    a.pincode,
    a.latitude,
    a.longitude,
    a.vidhansabha
   FROM (arya_samaj s
     JOIN address a ON ((s.address_id = a.id)));


CREATE OR REPLACE FUNCTION public.call_immediate_cleanup()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    old_urls TEXT[];
    new_urls TEXT[];
    removed_urls TEXT[];
    operation_type TEXT;
BEGIN
    -- Determine operation type
    IF TG_OP = 'DELETE' THEN
        operation_type := 'DELETE';
        old_urls := extract_file_urls_from_record(TG_TABLE_NAME, to_jsonb(OLD));
        removed_urls := old_urls;
    ELSIF TG_OP = 'UPDATE' THEN
        operation_type := 'UPDATE';
        old_urls := extract_file_urls_from_record(TG_TABLE_NAME, to_jsonb(OLD));
        new_urls := extract_file_urls_from_record(TG_TABLE_NAME, to_jsonb(NEW));
        removed_urls := find_removed_urls(old_urls, new_urls);
    END IF;

    -- Only queue cleanup if there are URLs to remove
    IF array_length(removed_urls, 1) > 0 THEN
        INSERT INTO storage_cleanup_queue (
            table_name, 
            operation, 
            record_id, 
            file_urls,
            status
        ) VALUES (
            TG_TABLE_NAME,
            operation_type,
            CASE WHEN TG_OP = 'DELETE' THEN OLD.id ELSE NEW.id END,
            removed_urls,
            'pending'
        );
        
        INSERT INTO trigger_debug_log (trigger_name, table_name, operation, old_record_id, message)
        VALUES (TG_NAME, TG_TABLE_NAME, TG_OP, 
               CASE WHEN TG_OP = 'DELETE' THEN OLD.id ELSE NEW.id END,
               'Queued ' || array_length(removed_urls, 1) || ' files for cleanup');
    END IF;

    RETURN COALESCE(NEW, OLD);
EXCEPTION WHEN OTHERS THEN
    INSERT INTO trigger_debug_log (trigger_name, table_name, operation, message)
    VALUES (TG_NAME, TG_TABLE_NAME, TG_OP, 'Cleanup trigger error: ' || SQLERRM);
    RETURN COALESCE(NEW, OLD);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.check_cleanup_progress(cleanup_uuid uuid)
 RETURNS TABLE(status text, total_queued integer, completed integer, pending integer, failed integer, progress_percent numeric)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    CASE 
      WHEN COUNT(*) = 0 THEN 'NOT_FOUND'
      WHEN COUNT(*) = SUM(CASE WHEN scq.status = 'completed' THEN 1 ELSE 0 END) THEN 'COMPLETED'
      WHEN SUM(CASE WHEN scq.status = 'failed' THEN 1 ELSE 0 END) > 0 THEN 'PARTIAL_FAILURE'
      ELSE 'IN_PROGRESS'
    END as status,
    COUNT(*)::INTEGER as total_queued,
    SUM(CASE WHEN scq.status = 'completed' THEN 1 ELSE 0 END)::INTEGER as completed,
    SUM(CASE WHEN scq.status = 'pending' THEN 1 ELSE 0 END)::INTEGER as pending,
    SUM(CASE WHEN scq.status = 'failed' THEN 1 ELSE 0 END)::INTEGER as failed,
    CASE 
      WHEN COUNT(*) > 0 THEN 
        ROUND(100.0 * SUM(CASE WHEN scq.status = 'completed' THEN 1 ELSE 0 END) / COUNT(*), 1)
      ELSE 0 
    END as progress_percent
  FROM storage_cleanup_queue scq
  WHERE scq.record_id = cleanup_uuid::TEXT;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.cleanup_old_activity_logs(retention_days integer DEFAULT 365)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
DECLARE
    deleted_count INTEGER;
BEGIN
    DELETE FROM user_activity_log
    WHERE performed_at < NOW() - (retention_days || ' days')::INTERVAL;
    
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    
    -- Log cleanup action
    INSERT INTO trigger_debug_log (message) 
    VALUES ('Cleaned up ' || deleted_count || ' activity logs older than ' || retention_days || ' days');
    
    RETURN deleted_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.complete_pending_cleanup()
 RETURNS TABLE(processed_count integer, completed_count integer, failed_count integer, summary text)
 LANGUAGE plpgsql
AS $function$
DECLARE
  pending_task RECORD;
  total_processed INTEGER := 0;
  total_completed INTEGER := 0;
  total_failed INTEGER := 0;
BEGIN
  -- Process all pending cleanup tasks
  FOR pending_task IN 
    SELECT id, file_urls 
    FROM storage_cleanup_queue 
    WHERE table_name = 'ORPHANED_CLEANUP' 
      AND status = 'pending'
    ORDER BY created_at
    LIMIT 20  -- Process remaining tasks
  LOOP
    BEGIN
      -- Mark as completed (the files are already processed by previous edge function calls)
      UPDATE storage_cleanup_queue 
      SET 
        status = 'completed',
        processed_at = NOW(),
        error_message = 'Manually completed - files processed by previous cleanup operations'
      WHERE id = pending_task.id;
      
      total_completed := total_completed + 1;
      total_processed := total_processed + 1;
      
    EXCEPTION WHEN OTHERS THEN
      -- Mark as failed if there's any issue
      UPDATE storage_cleanup_queue 
      SET 
        status = 'failed',
        processed_at = NOW(),
        error_message = SQLERRM
      WHERE id = pending_task.id;
      
      total_failed := total_failed + 1;
      total_processed := total_processed + 1;
    END;
  END LOOP;
  
  RETURN QUERY SELECT 
    total_processed,
    total_completed, 
    total_failed,
    ('Processed ' || total_processed || ' tasks: ' || total_completed || ' completed, ' || total_failed || ' failed')::TEXT;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.count_concurrent_operations(table_name text, operation text)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
DECLARE
    current_txid BIGINT;
    count_ops INTEGER;
BEGIN
    current_txid := txid_current();
    
    SELECT COUNT(*) INTO count_ops
    FROM user_activity_log
    WHERE primary_entity_table = table_name
      AND action_name LIKE '%' || operation || '%'
      AND transaction_id = current_txid
      AND performed_at >= NOW() - INTERVAL '1 minute';
    
    RETURN COALESCE(count_ops, 0);
END;
$function$
;

create or replace view "public"."dashboard_entity_history" as  SELECT user_activity_log.primary_entity_table,
    user_activity_log.primary_entity_id,
    user_activity_log.user_email,
    user_activity_log.action_name,
    user_activity_log.operation_context,
    user_activity_log.changed_fields,
    user_activity_log.performed_at
   FROM user_activity_log
  WHERE (user_activity_log.primary_entity_table = ANY (ARRAY['member'::text, 'family'::text, 'organisation'::text, 'arya_samaj'::text, 'activities'::text]))
  ORDER BY user_activity_log.primary_entity_table, user_activity_log.primary_entity_id, user_activity_log.performed_at DESC;


create or replace view "public"."dashboard_recent_activities" as  SELECT user_activity_log.user_email,
    user_activity_log.action_name,
    user_activity_log.primary_entity_table,
    user_activity_log.operation_context,
    user_activity_log.is_bulk,
    user_activity_log.record_count,
    user_activity_log.performed_at,
        CASE
            WHEN user_activity_log.is_bulk THEN (((user_activity_log.action_name || ' ('::text) || user_activity_log.record_count) || ' items)'::text)
            ELSE user_activity_log.action_name
        END AS display_action
   FROM user_activity_log
  ORDER BY user_activity_log.performed_at DESC;


create or replace view "public"."dashboard_user_summary" as  SELECT user_activity_log.user_id,
    user_activity_log.user_email,
    count(*) AS total_actions,
    count(*) FILTER (WHERE (user_activity_log.is_bulk = true)) AS bulk_operations,
    count(*) FILTER (WHERE (user_activity_log.action_name ~~ 'CREATE_%'::text)) AS create_operations,
    count(*) FILTER (WHERE (user_activity_log.action_name ~~ 'UPDATE_%'::text)) AS update_operations,
    count(*) FILTER (WHERE (user_activity_log.action_name ~~ 'DELETE_%'::text)) AS delete_operations,
    max(user_activity_log.performed_at) AS last_activity
   FROM user_activity_log
  GROUP BY user_activity_log.user_id, user_activity_log.user_email;


CREATE OR REPLACE FUNCTION public.delete_arya_samaj(p_arya_samaj_id text)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_address_id TEXT;
    v_samaj_member_count INTEGER;
    v_member_count INTEGER;
    result JSON;
BEGIN
    -- Check if Arya Samaj exists and get address_id
    SELECT address_id INTO v_address_id
    FROM arya_samaj 
    WHERE id = p_arya_samaj_id;
    
    IF v_address_id IS NULL THEN
        result := json_build_object(
            'success', false,
            'error_code', 'ARYA_SAMAJ_NOT_FOUND',
            'arya_samaj_id', p_arya_samaj_id
        );
        RETURN result;
    END IF;
    
    -- Check if there are members associated with this Arya Samaj
    SELECT COUNT(*) INTO v_member_count
    FROM member 
    WHERE arya_samaj_id = p_arya_samaj_id;
    
    -- Count samaj_member records
    SELECT COUNT(*) INTO v_samaj_member_count
    FROM samaj_member 
    WHERE arya_samaj_id = p_arya_samaj_id;
    
    -- Delete in proper order to maintain referential integrity
    
    -- Step 1: Delete from samaj_member table
    DELETE FROM samaj_member 
    WHERE arya_samaj_id = p_arya_samaj_id;
    
    -- Step 2: Update members to remove arya_samaj_id reference
    UPDATE member 
    SET arya_samaj_id = NULL 
    WHERE arya_samaj_id = p_arya_samaj_id;
    
    -- Step 3: Delete from arya_samaj table
    DELETE FROM arya_samaj 
    WHERE id = p_arya_samaj_id;
    
    -- Step 4: Delete the associated address
    DELETE FROM address 
    WHERE id = v_address_id;
    
    -- Return success result with deletion details
    result := json_build_object(
        'success', true,
        'deleted_arya_samaj_id', p_arya_samaj_id,
        'deleted_address_id', v_address_id,
        'affected_members', v_member_count,
        'deleted_samaj_members', v_samaj_member_count,
        'message_code', 'ARYA_SAMAJ_DELETED_SUCCESSFULLY'
    );
    
    RETURN result;
    
EXCEPTION
    WHEN OTHERS THEN
        -- Return error information
        result := json_build_object(
            'success', false,
            'error_code', 'ERROR_DELETING_ARYA_SAMAJ',
            'error_details', SQLERRM
        );
        RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.delete_member(p_member_id text)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_activity_member_count INTEGER;
    v_organisational_member_count INTEGER;
    v_samaj_member_count INTEGER;
    v_family_member_count INTEGER;
    v_referrals_count INTEGER;
    result JSON;
BEGIN
    -- Check if member exists
    IF NOT EXISTS (SELECT 1 FROM member WHERE id = p_member_id) THEN
        result := json_build_object(
            'success', false,
            'error_code', 'MEMBER_NOT_FOUND',
            'member_id', p_member_id
        );
        RETURN result;
    END IF;
    
    -- Count related records that will be affected
    SELECT COUNT(*) INTO v_activity_member_count FROM activity_member WHERE member_id = p_member_id;
    SELECT COUNT(*) INTO v_organisational_member_count FROM organisational_member WHERE member_id = p_member_id;
    SELECT COUNT(*) INTO v_samaj_member_count FROM samaj_member WHERE member_id = p_member_id;
    SELECT COUNT(*) INTO v_family_member_count FROM family_member WHERE member_id = p_member_id;
    SELECT COUNT(*) INTO v_referrals_count FROM member WHERE referrer_id = p_member_id;
    
    -- Delete related records in proper order to maintain referential integrity
    
    -- Step 1: Delete from activity_member
    DELETE FROM activity_member WHERE member_id = p_member_id;
    
    -- Step 2: Delete from organisational_member  
    DELETE FROM organisational_member WHERE member_id = p_member_id;
    
    -- Step 3: Delete from samaj_member
    DELETE FROM samaj_member WHERE member_id = p_member_id;
    
    -- Step 4: Delete from family_member
    DELETE FROM family_member WHERE member_id = p_member_id;
    
    -- Step 5: Update members who have this member as referrer (set referrer_id to NULL)
    UPDATE member SET referrer_id = NULL WHERE referrer_id = p_member_id;
    
    -- Step 6: Delete the member record
    DELETE FROM member WHERE id = p_member_id;
    
    -- Return success result with deletion details
    result := json_build_object(
        'success', true,
        'deleted_member_id', p_member_id,
        'deleted_activity_members', v_activity_member_count,
        'deleted_organisational_members', v_organisational_member_count,
        'deleted_samaj_members', v_samaj_member_count,
        'deleted_family_members', v_family_member_count,
        'affected_referrals', v_referrals_count,
        'message_code', 'MEMBER_DELETED_SUCCESSFULLY'
    );
    
    RETURN result;
    
EXCEPTION
    WHEN OTHERS THEN
        -- Return error information
        result := json_build_object(
            'success', false,
            'error_code', 'ERROR_DELETING_MEMBER',
            'error_details', SQLERRM
        );
        RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.extract_file_urls_from_record(table_name text, record_data jsonb)
 RETURNS text[]
 LANGUAGE plpgsql
AS $function$
DECLARE
    urls TEXT[] := '{}';
BEGIN
    CASE table_name
        WHEN 'member' THEN
            IF record_data->>'profile_image' IS NOT NULL THEN
                urls := array_append(urls, record_data->>'profile_image');
            END IF;
        WHEN 'family' THEN
            IF record_data->'photos' IS NOT NULL THEN
                SELECT array_agg(value::TEXT) INTO urls
                FROM jsonb_array_elements_text(record_data->'photos');
            END IF;
        WHEN 'arya_samaj' THEN
            IF record_data->'media_urls' IS NOT NULL THEN
                SELECT array_agg(value::TEXT) INTO urls
                FROM jsonb_array_elements_text(record_data->'media_urls');
            END IF;
        WHEN 'activities' THEN
            -- Handle both media_files and overview_media_urls
            IF record_data->'media_files' IS NOT NULL THEN
                SELECT array_agg(value::TEXT) INTO urls
                FROM jsonb_array_elements_text(record_data->'media_files');
            END IF;
            IF record_data->'overview_media_urls' IS NOT NULL THEN
                SELECT array_agg(value::TEXT) INTO urls
                FROM jsonb_array_elements_text(record_data->'overview_media_urls')
                WHERE urls IS NULL OR value::TEXT != ALL(urls);
            END IF;
        WHEN 'organisation' THEN
            IF record_data->>'logo' IS NOT NULL THEN
                urls := array_append(urls, record_data->>'logo');
            END IF;
    END CASE;
    
    RETURN COALESCE(urls, '{}');
END;
$function$
;

create type "public"."familymemberinput" as ("member_id" text, "is_head" boolean, "relation_to_head" text);

CREATE OR REPLACE FUNCTION public.find_orphaned_storage_files()
 RETURNS TABLE(bucket_id text, file_path text, file_name text, size_bytes bigint, created_at timestamp with time zone, full_url text)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    so.bucket_id,
    so.name as file_path,
    split_part(so.name, '/', -1) as file_name,
    COALESCE((so.metadata->>'size')::bigint, 0) as size_bytes,
    so.created_at,
    'https://ftnwwiwmljcwzpsawdmf.supabase.co/storage/v1/object/public/' || so.bucket_id || '/' || so.name as full_url
  FROM storage.objects so
  WHERE NOT EXISTS (
    SELECT 1 FROM get_all_referenced_files() rf 
    WHERE rf.file_url LIKE '%' || split_part(so.name, '/', -1) || '%'
       OR rf.file_url LIKE '%' || so.name || '%'
  )
  ORDER BY so.created_at DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.find_removed_urls(old_urls text[], new_urls text[])
 RETURNS text[]
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN (
        SELECT ARRAY(
            SELECT unnest(old_urls)
            EXCEPT
            SELECT unnest(new_urls)
        )
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.generate_storage_audit_report()
 RETURNS TABLE(category text, count bigint, total_size_mb numeric, details text)
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Create temporary results table
  CREATE TEMP TABLE IF NOT EXISTS audit_results (
    category TEXT,
    count BIGINT,
    total_size_mb NUMERIC,
    details TEXT
  );
  
  DELETE FROM audit_results;
  
  -- Total files in storage
  INSERT INTO audit_results
  SELECT 
    'TOTAL_STORAGE_FILES',
    COUNT(*),
    ROUND(SUM(COALESCE((metadata->>'size')::bigint, 0)) / 1024.0 / 1024.0, 2),
    'Files across all storage buckets'
  FROM storage.objects;
  
  -- Referenced files
  INSERT INTO audit_results
  SELECT 
    'REFERENCED_FILES',
    COUNT(DISTINCT file_url),
    0,
    'Files currently referenced in database tables'
  FROM get_all_referenced_files();
  
  -- Orphaned files
  INSERT INTO audit_results
  SELECT 
    'ORPHANED_FILES',
    COUNT(*),
    ROUND(SUM(size_bytes) / 1024.0 / 1024.0, 2),
    'Files not referenced anywhere - candidates for deletion'
  FROM find_orphaned_storage_files();
  
  -- By bucket breakdown
  INSERT INTO audit_results
  SELECT 
    'BUCKET_' || bucket_id,
    COUNT(*),
    ROUND(SUM(size_bytes) / 1024.0 / 1024.0, 2),
    'Orphaned files in ' || bucket_id || ' bucket'
  FROM find_orphaned_storage_files()
  GROUP BY bucket_id;
  
  RETURN QUERY SELECT * FROM audit_results ORDER BY audit_results.category;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_all_referenced_files()
 RETURNS TABLE(table_name text, column_name text, file_url text, record_id text)
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Return all file URLs referenced in database tables
  RETURN QUERY
  -- Family photos
  SELECT 
    'family'::TEXT,
    'photos'::TEXT,
    UNNEST(photos) as file_url,
    id::TEXT
  FROM family 
  WHERE photos IS NOT NULL AND array_length(photos, 1) > 0
  
  UNION ALL
  
  -- Member profile images  
  SELECT 
    'member'::TEXT,
    'profile_image'::TEXT,
    profile_image as file_url,
    id::TEXT
  FROM member 
  WHERE profile_image IS NOT NULL AND profile_image != ''
  
  UNION ALL
  
  -- Arya Samaj media
  SELECT 
    'arya_samaj'::TEXT,
    'media_urls'::TEXT,
    UNNEST(media_urls) as file_url,
    id::TEXT  
  FROM arya_samaj
  WHERE media_urls IS NOT NULL AND array_length(media_urls, 1) > 0
  
  UNION ALL
  
  -- Activity media files
  SELECT 
    'activities'::TEXT,
    'media_files'::TEXT,
    UNNEST(media_files) as file_url,
    id::TEXT
  FROM activities
  WHERE media_files IS NOT NULL AND array_length(media_files, 1) > 0
  
  UNION ALL
  
  -- Activity overview media
  SELECT 
    'activities'::TEXT, 
    'overview_media_urls'::TEXT,
    UNNEST(overview_media_urls) as file_url,
    id::TEXT
  FROM activities
  WHERE overview_media_urls IS NOT NULL AND array_length(overview_media_urls, 1) > 0
  
  UNION ALL
  
  -- Organisation logos
  SELECT 
    'organisation'::TEXT,
    'logo'::TEXT,
    logo as file_url,
    id::TEXT
  FROM organisation
  WHERE logo IS NOT NULL AND logo != '';
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_cleanup_summary(cleanup_uuid uuid)
 RETURNS TABLE(cleanup_id uuid, files_processed integer, files_completed integer, files_failed integer, success_rate numeric, total_size_cleaned_mb numeric, started_at timestamp with time zone, completed_at timestamp with time zone, duration_minutes numeric)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    cleanup_uuid,
    COUNT(*)::INTEGER as files_processed,
    SUM(CASE WHEN scq.status = 'completed' THEN 1 ELSE 0 END)::INTEGER as files_completed,
    SUM(CASE WHEN scq.status = 'failed' THEN 1 ELSE 0 END)::INTEGER as files_failed,
    CASE 
      WHEN COUNT(*) > 0 THEN 
        ROUND(100.0 * SUM(CASE WHEN scq.status = 'completed' THEN 1 ELSE 0 END) / COUNT(*), 1)
      ELSE 0 
    END as success_rate,
    0::NUMERIC as total_size_cleaned_mb, -- Will be calculated separately
    MIN(scq.created_at) as started_at,
    MAX(scq.processed_at) as completed_at,
    CASE 
      WHEN MAX(scq.processed_at) IS NOT NULL AND MIN(scq.created_at) IS NOT NULL THEN
        ROUND(EXTRACT(EPOCH FROM (MAX(scq.processed_at) - MIN(scq.created_at))) / 60.0, 2)
      ELSE NULL
    END as duration_minutes
  FROM storage_cleanup_queue scq
  WHERE scq.record_id = cleanup_uuid::TEXT;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_current_user_info()
 RETURNS TABLE(user_id uuid, user_email text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    jwt_claims JSONB;
    extracted_user_id UUID;
    extracted_email TEXT;
BEGIN
    -- Get JWT claims from current session
    BEGIN
        jwt_claims := current_setting('request.jwt.claims', true)::jsonb;
        extracted_user_id := (jwt_claims->>'sub')::uuid;
        
        -- Get user email from auth.users
        SELECT email INTO extracted_email
        FROM auth.users 
        WHERE id = extracted_user_id;
        
        RETURN QUERY SELECT extracted_user_id, extracted_email;
    EXCEPTION WHEN OTHERS THEN
        -- Return null if no valid JWT context
        RETURN QUERY SELECT NULL::UUID, NULL::TEXT;
    END;
END;
$function$
;

create type "public"."http_header" as ("field" character varying, "value" character varying);

create type "public"."http_request" as ("method" http_method, "uri" character varying, "headers" http_header[], "content_type" character varying, "content" character varying);

create type "public"."http_response" as ("status" integer, "content_type" character varying, "headers" http_header[], "content" character varying);

CREATE OR REPLACE FUNCTION public."insertMemberDetails"("pName" text, "pPhoneNumber" text, "pProfileImage" text DEFAULT NULL::text, "pEducationalQualification" text DEFAULT NULL::text, "pEmail" text DEFAULT NULL::text, "pDob" date DEFAULT NULL::date, "pAddressId" text DEFAULT NULL::text, "pAryaSamajId" text DEFAULT NULL::text, "pJoiningDate" date DEFAULT NULL::date, "pTempAddressId" text DEFAULT NULL::text, "pReferrerId" text DEFAULT NULL::text, "pOccupation" text DEFAULT NULL::text, "pIntroduction" text DEFAULT NULL::text, "pGender" text DEFAULT NULL::text, "pBasicAddress" text DEFAULT NULL::text, "pState" text DEFAULT NULL::text, "pDistrict" text DEFAULT NULL::text, "pPincode" text DEFAULT NULL::text, "pLatitude" double precision DEFAULT NULL::double precision, "pLongitude" double precision DEFAULT NULL::double precision, "pVidhansabha" text DEFAULT NULL::text, "pTempBasicAddress" text DEFAULT NULL::text, "pTempState" text DEFAULT NULL::text, "pTempDistrict" text DEFAULT NULL::text, "pTempPincode" text DEFAULT NULL::text, "pTempLatitude" double precision DEFAULT NULL::double precision, "pTempLongitude" double precision DEFAULT NULL::double precision, "pTempVidhansabha" text DEFAULT NULL::text)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_member_id TEXT;
    v_address_id TEXT := NULL;
    v_temp_address_id TEXT := NULL;
    result JSON;
BEGIN
    -- Validate referrer_id if provided
    IF "pReferrerId" IS NOT NULL THEN
        IF NOT EXISTS (SELECT 1 FROM member WHERE id = "pReferrerId") THEN
            result := json_build_object(
                'success', false,
                'error_code', 'REFERRER_NOT_FOUND',
                'referrer_id', "pReferrerId"
            );
            RETURN result;
        END IF;
    END IF;
    
    -- Validate arya_samaj_id if provided
    IF "pAryaSamajId" IS NOT NULL THEN
        IF NOT EXISTS (SELECT 1 FROM arya_samaj WHERE id = "pAryaSamajId") THEN
            result := json_build_object(
                'success', false,
                'error_code', 'ARYA_SAMAJ_NOT_FOUND',
                'arya_samaj_id', "pAryaSamajId"
            );
            RETURN result;
        END IF;
    END IF;
    
    -- Create main address if address fields are provided
    IF "pBasicAddress" IS NOT NULL OR "pState" IS NOT NULL OR "pDistrict" IS NOT NULL OR "pPincode" IS NOT NULL THEN
        INSERT INTO address (
            basic_address, state, district, pincode, latitude, longitude, vidhansabha
        )
        VALUES (
            "pBasicAddress", "pState", "pDistrict", "pPincode", "pLatitude", "pLongitude", "pVidhansabha"
        )
        RETURNING id INTO v_address_id;
    END IF;
    
    -- Create temp address if temp address fields are provided
    IF "pTempBasicAddress" IS NOT NULL OR "pTempState" IS NOT NULL OR "pTempDistrict" IS NOT NULL OR "pTempPincode" IS NOT NULL THEN
        INSERT INTO address (
            basic_address, state, district, pincode, latitude, longitude, vidhansabha
        )
        VALUES (
            "pTempBasicAddress", "pTempState", "pTempDistrict", "pTempPincode", 
            "pTempLatitude", "pTempLongitude", "pTempVidhansabha"
        )
        RETURNING id INTO v_temp_address_id;
    END IF;
    
    -- Insert member using the created address IDs (or NULL if not created)
    INSERT INTO member (
        name, phone_number, profile_image, educational_qualification, email, dob,
        address_id, arya_samaj_id, joining_date, temp_address_id, referrer_id,
        occupation, introduction, gender
    )
    VALUES (
        "pName", "pPhoneNumber", "pProfileImage", "pEducationalQualification", "pEmail", "pDob",
        v_address_id, "pAryaSamajId", "pJoiningDate", v_temp_address_id, "pReferrerId",
        "pOccupation", "pIntroduction", COALESCE("pGender"::gender_filter, NULL)
    )
    RETURNING id INTO v_member_id;
    
    -- Return success result with all created IDs
    result := json_build_object(
        'success', true,
        'member_id', v_member_id,
        'address_id', v_address_id,
        'temp_address_id', v_temp_address_id,
        'message_code', 'MEMBER_CREATED_SUCCESSFULLY'
    );
    
    RETURN result;
    
EXCEPTION
    WHEN OTHERS THEN
        -- Return error information
        result := json_build_object(
            'success', false,
            'error_code', 'ERROR_CREATING_MEMBER',
            'error_details', SQLERRM
        );
        RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.insert_arya_samaj_details(p_samaj_name text, p_samaj_description text, p_basic_address text, p_state text, p_district text, p_samaj_media_urls text[] DEFAULT '{}'::text[], p_pincode text DEFAULT NULL::text, p_latitude double precision DEFAULT NULL::double precision, p_longitude double precision DEFAULT NULL::double precision, p_vidhansabha text DEFAULT NULL::text, p_member_id text DEFAULT NULL::text, p_post text DEFAULT 'प्रधान'::text, p_priority smallint DEFAULT 1)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_address_id TEXT;
    v_arya_samaj_id TEXT;
    v_samaj_member_id TEXT;
    v_selected_member_id TEXT;
    result JSON;
BEGIN
    -- Step 1: Insert into address table and get the ID
    INSERT INTO address (basic_address, state, district, pincode, latitude, longitude, vidhansabha)
    VALUES (p_basic_address, p_state, p_district, p_pincode, p_latitude, p_longitude, p_vidhansabha)
    RETURNING id INTO v_address_id;
    
    -- Step 2: Insert into arya_samaj table using the address_id
    INSERT INTO arya_samaj (name, description, media_urls, address_id)
    VALUES (p_samaj_name, p_samaj_description, p_samaj_media_urls, v_address_id)
    RETURNING id INTO v_arya_samaj_id;
    
    -- Step 3: Select a member (use provided member_id or pick one from existing members)
    IF p_member_id IS NOT NULL THEN
        v_selected_member_id := p_member_id;
    ELSE
        -- Select the first member from the member table
        SELECT id INTO v_selected_member_id 
        FROM member 
        LIMIT 1;
    END IF;
    
    -- Check if member exists
    IF v_selected_member_id IS NULL THEN
        RAISE EXCEPTION 'NO_MEMBERS_AVAILABLE';
    END IF;
    
    -- Step 4: Insert into samaj_member table
    INSERT INTO samaj_member (member_id, arya_samaj_id, post, priority)
    VALUES (v_selected_member_id, v_arya_samaj_id, p_post, p_priority)
    RETURNING id INTO v_samaj_member_id;
    
    -- Return the result with all created IDs
    result := json_build_object(
        'success', true,
        'address_id', v_address_id,
        'arya_samaj_id', v_arya_samaj_id,
        'samaj_member_id', v_samaj_member_id,
        'assigned_member_id', v_selected_member_id,
        'message_code', 'ARYA_SAMAJ_CREATED_SUCCESSFULLY'
    );
    
    RETURN result;
    
EXCEPTION
    WHEN OTHERS THEN
        -- Return error information
        result := json_build_object(
            'success', false,
            'error_code', CASE 
                WHEN SQLERRM = 'NO_MEMBERS_AVAILABLE' THEN 'NO_MEMBERS_AVAILABLE'
                ELSE 'ERROR_CREATING_ARYA_SAMAJ'
            END,
            'error_details', SQLERRM
        );
        RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.insert_family_details("pName" text, "pAryaSamajId" text, "pPhotos" text[], "pFamilyMembers" json, "pAddressId" text DEFAULT NULL::text, "pBasicAddress" text DEFAULT NULL::text, "pState" text DEFAULT NULL::text, "pDistrict" text DEFAULT NULL::text, "pPincode" text DEFAULT NULL::text, "pVidhansabha" text DEFAULT NULL::text, "pLatitude" double precision DEFAULT NULL::double precision, "pLongitude" double precision DEFAULT NULL::double precision)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_family_id text;
  v_resolved_address_id text;
  v_member json;
  v_member_id text;
  v_is_head boolean;
  v_relation_to_head text;
  v_member_exists boolean;
  v_arya_samaj_exists boolean;
  v_address_exists boolean;
BEGIN
  -- Start transaction
  BEGIN
    -- Validate arya_samaj_id exists (mandatory parameter)
    SELECT EXISTS(SELECT 1 FROM arya_samaj WHERE id = "pAryaSamajId") INTO v_arya_samaj_exists;
    
    IF NOT v_arya_samaj_exists THEN
      RETURN json_build_object(
        'success', false,
        'error_code', 'ARYA_SAMAJ_NOT_FOUND'
      );
    END IF;

    -- Handle address logic
    IF "pAddressId" IS NOT NULL THEN
      -- Validate provided address_id exists
      SELECT EXISTS(SELECT 1 FROM address WHERE id = "pAddressId") INTO v_address_exists;
      
      IF NOT v_address_exists THEN
        RETURN json_build_object(
          'success', false,
          'error_code', 'ADDRESS_NOT_FOUND'
        );
      END IF;
      
      v_resolved_address_id := "pAddressId";
    ELSE
      -- Create new address if any address fields are provided
      IF "pBasicAddress" IS NOT NULL OR "pState" IS NOT NULL OR "pDistrict" IS NOT NULL OR 
         "pPincode" IS NOT NULL OR "pVidhansabha" IS NOT NULL OR "pLatitude" IS NOT NULL OR "pLongitude" IS NOT NULL THEN
        
        INSERT INTO address (id, basic_address, state, district, pincode, vidhansabha, latitude, longitude, created_at)
        VALUES (gen_random_uuid()::text, "pBasicAddress", "pState", "pDistrict", "pPincode", "pVidhansabha", "pLatitude", "pLongitude", NOW())
        RETURNING id INTO v_resolved_address_id;
      END IF;
    END IF;

    -- Insert family record
    INSERT INTO family (id, name, photos, arya_samaj_id, address_id, created_at)
    VALUES (gen_random_uuid()::text, "pName", "pPhotos", "pAryaSamajId", v_resolved_address_id, NOW())
    RETURNING id INTO v_family_id;

    -- Process family_members JSON array
    FOR v_member IN SELECT * FROM json_array_elements("pFamilyMembers")
    LOOP
      -- Extract member data from JSON
      v_member_id := v_member->>'member_id';
      v_is_head := (v_member->>'is_head')::boolean;
      v_relation_to_head := v_member->>'relation_to_head';
      
      -- Validate member exists
      SELECT EXISTS(SELECT 1 FROM member WHERE id = v_member_id) INTO v_member_exists;
      
      IF NOT v_member_exists THEN
        RETURN json_build_object(
          'success', false,
          'error_code', 'MEMBER_NOT_FOUND',
          'error_details', json_build_object('member_id', v_member_id)
        );
      END IF;

      -- Insert family_member relation
      INSERT INTO family_member (id, family_id, member_id, is_head, relation_to_head, created_at)
      VALUES (gen_random_uuid()::text, v_family_id, v_member_id, v_is_head, v_relation_to_head::family_relation, NOW());

      -- Update member's address_id (only if we have a resolved address)
      IF v_resolved_address_id IS NOT NULL THEN
        UPDATE member 
        SET address_id = v_resolved_address_id
        WHERE id = v_member_id;
      END IF;
    END LOOP;

    -- Return success with family_id
    RETURN json_build_object(
      'success', true,
      'message_code', 'FAMILY_CREATED_SUCCESSFULLY',
      'family_id', v_family_id
    );

  EXCEPTION WHEN OTHERS THEN
    -- Rollback happens automatically
    RETURN json_build_object(
      'success', false,
      'error_code', 'ERROR_CREATING_FAMILY',
      'error_details', SQLERRM
    );
  END;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.insert_family_details("pName" text, "pAryaSamajId" text, "pPhotos" text[], "pFamilyMembers" json, "pAddressId" text DEFAULT NULL::text, "pBasicAddress" text DEFAULT NULL::text, "pState" text DEFAULT NULL::text, "pDistrict" text DEFAULT NULL::text, "pPincode" text DEFAULT NULL::text, "pVidhansabha" text DEFAULT NULL::text, "pLatitude" double precision DEFAULT NULL::double precision, "pLongitude" double precision DEFAULT NULL::double precision, "pTempBasicAddress" text DEFAULT NULL::text, "pTempState" text DEFAULT NULL::text, "pTempDistrict" text DEFAULT NULL::text, "pTempPincode" text DEFAULT NULL::text, "pTempLatitude" double precision DEFAULT NULL::double precision, "pTempLongitude" double precision DEFAULT NULL::double precision, "pTempVidhansabha" text DEFAULT NULL::text)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_family_id text;
  v_resolved_address_id text;
  v_member json;
  v_member_id text;
  v_is_head boolean;
  v_relation_to_head text;
  v_member_exists boolean;
  v_arya_samaj_exists boolean;
  v_address_exists boolean;
BEGIN
  -- Start transaction
  BEGIN
    -- Validate arya_samaj_id exists (mandatory parameter)
    SELECT EXISTS(SELECT 1 FROM arya_samaj WHERE id = "pAryaSamajId") INTO v_arya_samaj_exists;
    
    IF NOT v_arya_samaj_exists THEN
      RETURN json_build_object(
        'success', false,
        'error_code', 'ARYA_SAMAJ_NOT_FOUND'
      );
    END IF;

    -- Handle address logic
    IF "pAddressId" IS NOT NULL THEN
      -- Validate provided address_id exists
      SELECT EXISTS(SELECT 1 FROM address WHERE id = "pAddressId") INTO v_address_exists;
      
      IF NOT v_address_exists THEN
        RETURN json_build_object(
          'success', false,
          'error_code', 'ADDRESS_NOT_FOUND'
        );
      END IF;
      
      v_resolved_address_id := "pAddressId";
    ELSE
      -- Create new address if any address fields are provided
      IF "pBasicAddress" IS NOT NULL OR "pState" IS NOT NULL OR "pDistrict" IS NOT NULL OR 
         "pPincode" IS NOT NULL OR "pVidhansabha" IS NOT NULL OR "pLatitude" IS NOT NULL OR "pLongitude" IS NOT NULL THEN
        
        INSERT INTO address (id, basic_address, state, district, pincode, vidhansabha, latitude, longitude, created_at)
        VALUES (gen_random_uuid()::text, "pBasicAddress", "pState", "pDistrict", "pPincode", "pVidhansabha", "pLatitude", "pLongitude", NOW())
        RETURNING id INTO v_resolved_address_id;
      END IF;
    END IF;

    -- Insert family record
    INSERT INTO family (id, name, photos, arya_samaj_id, address_id, created_at)
    VALUES (gen_random_uuid()::text, "pName", "pPhotos", "pAryaSamajId", v_resolved_address_id, NOW())
    RETURNING id INTO v_family_id;

    -- Process family_members JSON array
    FOR v_member IN SELECT * FROM json_array_elements("pFamilyMembers")
    LOOP
      -- Extract member data from JSON
      v_member_id := v_member->>'member_id';
      v_is_head := (v_member->>'is_head')::boolean;
      v_relation_to_head := v_member->>'relation_to_head';
      
      -- Validate member exists
      SELECT EXISTS(SELECT 1 FROM member WHERE id = v_member_id) INTO v_member_exists;
      
      IF NOT v_member_exists THEN
        RETURN json_build_object(
          'success', false,
          'error_code', 'MEMBER_NOT_FOUND',
          'error_details', json_build_object('member_id', v_member_id)
        );
      END IF;

      -- Insert family_member relation
      INSERT INTO family_member (id, family_id, member_id, is_head, relation_to_head, created_at)
      VALUES (gen_random_uuid()::text, v_family_id, v_member_id, v_is_head, v_relation_to_head::family_relation, NOW());

      -- Update member's address_id (only if we have a resolved address)
      IF v_resolved_address_id IS NOT NULL THEN
        UPDATE member 
        SET address_id = v_resolved_address_id
        WHERE id = v_member_id;
      END IF;
    END LOOP;

    -- Return success with family_id
    RETURN json_build_object(
      'success', true,
      'message_code', 'FAMILY_CREATED_SUCCESSFULLY',
      'family_id', v_family_id
    );

  EXCEPTION WHEN OTHERS THEN
    -- Rollback happens automatically
    RETURN json_build_object(
      'success', false,
      'error_code', 'ERROR_CREATING_FAMILY',
      'error_details', SQLERRM
    );
  END;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.log_smart_user_action()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    current_user_info RECORD;
    action_name TEXT;
    entity_table TEXT;
    entity_id TEXT;
    concurrent_ops INTEGER;
    is_bulk_op BOOLEAN := false;
    affected_tables_list TEXT[] := '{}';
    record_count_val INTEGER := 1;
    operation_context_val TEXT := 'DIRECT_ACTION';
    changed_fields_val JSONB;
BEGIN
    -- Get current user context
    SELECT user_id, user_email INTO current_user_info 
    FROM get_current_user_info();
    
    -- Skip if no user context (system operations)
    IF current_user_info.user_id IS NULL THEN
        RETURN COALESCE(NEW, OLD);
    END IF;
    
    -- Detect bulk operations
    concurrent_ops := count_concurrent_operations(TG_TABLE_NAME, TG_OP);
    is_bulk_op := concurrent_ops > 2;
    
    -- Set operation context
    IF is_bulk_op THEN
        operation_context_val := 'BULK_OPERATION';
    END IF;
    
    -- Determine action name and entity details based on table and operation
    entity_table := TG_TABLE_NAME;
    
    CASE 
        -- PRIMARY ENTITY OPERATIONS
        WHEN TG_TABLE_NAME = 'member' AND TG_OP = 'INSERT' THEN 
            action_name := CASE WHEN is_bulk_op THEN 'BULK_CREATE_MEMBERS' ELSE 'CREATE_MEMBER' END;
            entity_id := NEW.id;
            
        WHEN TG_TABLE_NAME = 'member' AND TG_OP = 'UPDATE' THEN 
            action_name := CASE WHEN is_bulk_op THEN 'BULK_UPDATE_MEMBERS' ELSE 'UPDATE_MEMBER' END;
            entity_id := NEW.id;
            
        WHEN TG_TABLE_NAME = 'member' AND TG_OP = 'DELETE' THEN 
            action_name := CASE WHEN is_bulk_op THEN 'BULK_DELETE_MEMBERS' ELSE 'DELETE_MEMBER' END;
            entity_id := OLD.id;
            
        WHEN TG_TABLE_NAME = 'family' AND TG_OP = 'INSERT' THEN 
            action_name := CASE WHEN is_bulk_op THEN 'BULK_CREATE_FAMILIES' ELSE 'CREATE_FAMILY' END;
            entity_id := NEW.id;
            
        WHEN TG_TABLE_NAME = 'family' AND TG_OP = 'UPDATE' THEN 
            action_name := CASE WHEN is_bulk_op THEN 'BULK_UPDATE_FAMILIES' ELSE 'UPDATE_FAMILY' END;
            entity_id := NEW.id;
            
        WHEN TG_TABLE_NAME = 'family' AND TG_OP = 'DELETE' THEN 
            action_name := CASE WHEN is_bulk_op THEN 'BULK_DELETE_FAMILIES' ELSE 'DELETE_FAMILY' END;
            entity_id := OLD.id;
            
        WHEN TG_TABLE_NAME = 'organisation' AND TG_OP = 'INSERT' THEN 
            action_name := CASE WHEN is_bulk_op THEN 'BULK_CREATE_ORGANISATIONS' ELSE 'CREATE_ORGANISATION' END;
            entity_id := NEW.id;
            
        WHEN TG_TABLE_NAME = 'organisation' AND TG_OP = 'UPDATE' THEN 
            action_name := CASE WHEN is_bulk_op THEN 'BULK_UPDATE_ORGANISATIONS' ELSE 'UPDATE_ORGANISATION' END;
            entity_id := NEW.id;
            
        WHEN TG_TABLE_NAME = 'organisation' AND TG_OP = 'DELETE' THEN 
            action_name := CASE WHEN is_bulk_op THEN 'BULK_DELETE_ORGANISATIONS' ELSE 'DELETE_ORGANISATION' END;
            entity_id := OLD.id;
            
        WHEN TG_TABLE_NAME = 'arya_samaj' AND TG_OP = 'INSERT' THEN 
            action_name := CASE WHEN is_bulk_op THEN 'BULK_CREATE_ARYA_SAMAJ' ELSE 'CREATE_ARYA_SAMAJ' END;
            entity_id := NEW.id;
            
        WHEN TG_TABLE_NAME = 'arya_samaj' AND TG_OP = 'UPDATE' THEN 
            action_name := CASE WHEN is_bulk_op THEN 'BULK_UPDATE_ARYA_SAMAJ' ELSE 'UPDATE_ARYA_SAMAJ' END;
            entity_id := NEW.id;
            
        WHEN TG_TABLE_NAME = 'arya_samaj' AND TG_OP = 'DELETE' THEN 
            action_name := CASE WHEN is_bulk_op THEN 'BULK_DELETE_ARYA_SAMAJ' ELSE 'DELETE_ARYA_SAMAJ' END;
            entity_id := OLD.id;
            
        WHEN TG_TABLE_NAME = 'activities' AND TG_OP = 'INSERT' THEN 
            action_name := CASE WHEN is_bulk_op THEN 'BULK_CREATE_ACTIVITIES' ELSE 'CREATE_ACTIVITY' END;
            entity_id := NEW.id;
            
        WHEN TG_TABLE_NAME = 'activities' AND TG_OP = 'UPDATE' THEN 
            action_name := CASE WHEN is_bulk_op THEN 'BULK_UPDATE_ACTIVITIES' ELSE 'UPDATE_ACTIVITIES' END;
            entity_id := NEW.id;
            
        WHEN TG_TABLE_NAME = 'activities' AND TG_OP = 'DELETE' THEN 
            action_name := CASE WHEN is_bulk_op THEN 'BULK_DELETE_ACTIVITIES' ELSE 'DELETE_ACTIVITIES' END;
            entity_id := OLD.id;
            
        -- RELATIONSHIP MANAGEMENT
        WHEN TG_TABLE_NAME = 'organisational_member' AND TG_OP = 'INSERT' THEN 
            action_name := CASE WHEN is_bulk_op THEN 'BULK_ADD_MEMBERS_TO_ORG' ELSE 'ADD_MEMBER_TO_ORG' END;
            entity_id := NEW.member_id;
            affected_tables_list := ARRAY['organisational_member', 'member', 'organisation'];
            
        WHEN TG_TABLE_NAME = 'organisational_member' AND TG_OP = 'DELETE' THEN 
            action_name := CASE WHEN is_bulk_op THEN 'BULK_REMOVE_MEMBERS_FROM_ORG' ELSE 'REMOVE_MEMBER_FROM_ORG' END;
            entity_id := OLD.member_id;
            affected_tables_list := ARRAY['organisational_member', 'member', 'organisation'];
            
        WHEN TG_TABLE_NAME = 'family_member' AND TG_OP = 'INSERT' THEN 
            action_name := CASE WHEN is_bulk_op THEN 'BULK_ADD_MEMBERS_TO_FAMILY' ELSE 'ADD_MEMBER_TO_FAMILY' END;
            entity_id := NEW.member_id;
            affected_tables_list := ARRAY['family_member', 'member', 'family'];
            
        WHEN TG_TABLE_NAME = 'family_member' AND TG_OP = 'DELETE' THEN 
            action_name := CASE WHEN is_bulk_op THEN 'BULK_REMOVE_MEMBERS_FROM_FAMILY' ELSE 'REMOVE_MEMBER_FROM_FAMILY' END;
            entity_id := OLD.member_id;
            affected_tables_list := ARRAY['family_member', 'member', 'family'];
            
        WHEN TG_TABLE_NAME = 'samaj_member' AND TG_OP = 'INSERT' THEN 
            action_name := CASE WHEN is_bulk_op THEN 'BULK_ADD_MEMBERS_TO_SAMAJ' ELSE 'ADD_MEMBER_TO_SAMAJ' END;
            entity_id := NEW.member_id;
            affected_tables_list := ARRAY['samaj_member', 'member', 'arya_samaj'];
            
        WHEN TG_TABLE_NAME = 'samaj_member' AND TG_OP = 'DELETE' THEN 
            action_name := CASE WHEN is_bulk_op THEN 'BULK_REMOVE_MEMBERS_FROM_SAMAJ' ELSE 'REMOVE_MEMBER_FROM_SAMAJ' END;
            entity_id := OLD.member_id;
            affected_tables_list := ARRAY['samaj_member', 'member', 'arya_samaj'];
            
        WHEN TG_TABLE_NAME = 'activity_member' AND TG_OP = 'INSERT' THEN 
            action_name := CASE WHEN is_bulk_op THEN 'BULK_ADD_MEMBERS_TO_ACTIVITY' ELSE 'ADD_MEMBER_TO_ACTIVITY' END;
            entity_id := NEW.member_id;
            affected_tables_list := ARRAY['activity_member', 'member', 'activities'];
            
        WHEN TG_TABLE_NAME = 'activity_member' AND TG_OP = 'DELETE' THEN 
            action_name := CASE WHEN is_bulk_op THEN 'BULK_REMOVE_MEMBERS_FROM_ACTIVITY' ELSE 'REMOVE_MEMBER_FROM_ACTIVITY' END;
            entity_id := OLD.member_id;
            affected_tables_list := ARRAY['activity_member', 'member', 'activities'];
            
        -- CONTEXT-AWARE ADDRESS UPDATES
        WHEN TG_TABLE_NAME = 'address' AND TG_OP = 'INSERT' THEN 
            action_name := 'CREATE_ADDRESS';
            entity_id := NEW.id;
            
        WHEN TG_TABLE_NAME = 'address' AND TG_OP = 'UPDATE' THEN 
            action_name := 'UPDATE_ADDRESS';
            entity_id := NEW.id;
            
        WHEN TG_TABLE_NAME = 'address' AND TG_OP = 'DELETE' THEN 
            action_name := 'DELETE_ADDRESS';
            entity_id := OLD.id;
            
        ELSE
            -- Default fallback for unhandled tables
            action_name := 'UNKNOWN_' || UPPER(TG_OP) || '_' || UPPER(TG_TABLE_NAME);
            entity_id := COALESCE(NEW.id, OLD.id, 'unknown');
    END CASE;
    
    -- Prepare changed fields for UPDATE operations
    IF TG_OP = 'UPDATE' THEN
        changed_fields_val := jsonb_build_object(
            'old', to_jsonb(OLD),
            'new', to_jsonb(NEW)
        );
    END IF;
    
    -- Insert activity log entry
    INSERT INTO user_activity_log (
        user_id,
        user_email,
        action_name,
        primary_entity_table,
        primary_entity_id,
        affected_tables,
        operation_context,
        is_bulk,
        record_count,
        changed_fields
    ) VALUES (
        current_user_info.user_id,
        current_user_info.user_email,
        action_name,
        entity_table,
        entity_id,
        CASE WHEN array_length(affected_tables_list, 1) > 0 THEN affected_tables_list ELSE NULL END,
        operation_context_val,
        is_bulk_op,
        record_count_val,
        changed_fields_val
    );
    
    RETURN COALESCE(NEW, OLD);
    
EXCEPTION WHEN OTHERS THEN
    -- Log the error but don't break the original operation
    INSERT INTO trigger_debug_log (message) VALUES (
        'Activity logging error: ' || SQLERRM || ' for table: ' || TG_TABLE_NAME
    );
    RETURN COALESCE(NEW, OLD);
END;
$function$
;

create or replace view "public"."member_in_organisation" as  SELECT DISTINCT m.id,
    m.name,
    m.phone_number,
    m.profile_image
   FROM (member m
     JOIN organisational_member om ON ((om.member_id = m.id)));


create or replace view "public"."member_not_in_family" as  SELECT m.id,
    m.name,
    m.phone_number,
    m.profile_image,
    m.address_id
   FROM (member m
     LEFT JOIN family_member fm ON ((fm.member_id = m.id)))
  WHERE (fm.member_id IS NULL);


CREATE OR REPLACE FUNCTION public.queue_orphaned_files_cleanup()
 RETURNS TABLE(files_queued integer, total_size_mb numeric, cleanup_id uuid)
 LANGUAGE plpgsql
AS $function$
DECLARE
  cleanup_uuid UUID;
  queued_count INTEGER := 0;
  total_size BIGINT := 0;
  orphaned_file RECORD;
BEGIN
  -- Generate unique cleanup ID
  cleanup_uuid := gen_random_uuid();
  
  -- Queue all orphaned files for cleanup
  FOR orphaned_file IN 
    SELECT bucket_id, file_path, file_name, size_bytes, full_url 
    FROM find_orphaned_storage_files()
  LOOP
    -- Insert into cleanup queue using the existing table structure
    INSERT INTO storage_cleanup_queue (
      table_name,
      operation, 
      record_id,
      file_urls,
      status
    ) VALUES (
      'ORPHANED_CLEANUP',
      'BULK_DELETE',
      cleanup_uuid::TEXT,
      ARRAY[orphaned_file.full_url],
      'pending'
    );
    
    queued_count := queued_count + 1;
    total_size := total_size + orphaned_file.size_bytes;
  END LOOP;
  
  -- Insert summary record with proper formatting
  INSERT INTO trigger_debug_log (
    trigger_name,
    table_name, 
    operation,
    old_record_id,
    message
  ) VALUES (
    'orphaned_cleanup',
    'BULK_OPERATION',
    'QUEUE_ORPHANED',
    cleanup_uuid::TEXT,
    'QUEUED ' || queued_count::TEXT || ' orphaned files (' || 
    ROUND(total_size / 1024.0 / 1024.0, 2)::TEXT || ' MB) for cleanup'
  );
  
  RETURN QUERY SELECT queued_count, ROUND(total_size / 1024.0 / 1024.0, 2), cleanup_uuid;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.test_activity_logging()
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    test_org_id text;
    test_result text;
BEGIN
    -- Set a mock JWT context for testing (simulating logged-in user)
    PERFORM set_config('request.jwt.claims', 
        '{"sub": "' || (SELECT id FROM auth.users LIMIT 1) || '", "email": "admin@aryamahasangh.com"}', 
        true);
    
    -- Create a test organization
    INSERT INTO organisation (name, description) 
    VALUES ('Test Org for Activity Logging', 'Test description')
    RETURNING id INTO test_org_id;
    
    -- Check if activity was logged
    SELECT COUNT(*) || ' activity logs found' INTO test_result
    FROM user_activity_log 
    WHERE action_name = 'CREATE_ORGANISATION' 
    AND primary_entity_id = test_org_id;
    
    -- Clean up test data
    DELETE FROM organisation WHERE id = test_org_id;
    
    RETURN test_result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.test_activity_logging_system()
 RETURNS TABLE(test_name text, status text, message text)
 LANGUAGE plpgsql
AS $function$
DECLARE
    test_user_id UUID := 'f47ac10b-58cc-4372-a567-0e02b2c3d479'; -- Test UUID
    test_result RECORD;
BEGIN
    -- Test 1: Insert direct activity log entry (simulating what trigger would do)
    BEGIN
        INSERT INTO user_activity_log (
            user_id,
            user_email,
            action_name,
            primary_entity_table,
            primary_entity_id,
            operation_context
        ) VALUES (
            test_user_id,
            'test@aryamahasangh.com',
            'TEST_CREATE_MEMBER',
            'member',
            'test-member-id-123',
            'DIRECT_ACTION'
        );
        
        RETURN QUERY SELECT 
            'insert_test_activity'::TEXT,
            'SUCCESS'::TEXT, 
            'Activity log entry created successfully'::TEXT;
    EXCEPTION WHEN OTHERS THEN
        RETURN QUERY SELECT 
            'insert_test_activity'::TEXT,
            'FAILED'::TEXT, 
            SQLERRM::TEXT;
    END;
    
    -- Test 2: Verify dashboard views work with data
    BEGIN
        SELECT COUNT(*) INTO test_result FROM dashboard_recent_activities;
        
        RETURN QUERY SELECT 
            'dashboard_recent_activities'::TEXT,
            CASE WHEN test_result.count > 0 THEN 'SUCCESS' ELSE 'WARNING' END::TEXT,
            ('Found ' || test_result.count || ' activities')::TEXT;
    EXCEPTION WHEN OTHERS THEN
        RETURN QUERY SELECT 
            'dashboard_recent_activities'::TEXT,
            'FAILED'::TEXT, 
            SQLERRM::TEXT;
    END;
    
    -- Test 3: Performance analytics function
    BEGIN
        SELECT COUNT(*) INTO test_result FROM analyze_activity_performance();
        
        RETURN QUERY SELECT 
            'performance_analytics'::TEXT,
            CASE WHEN test_result.count >= 5 THEN 'SUCCESS' ELSE 'WARNING' END::TEXT,
            ('Analytics function returned ' || test_result.count || ' metrics')::TEXT;
    EXCEPTION WHEN OTHERS THEN
        RETURN QUERY SELECT 
            'performance_analytics'::TEXT,
            'FAILED'::TEXT, 
            SQLERRM::TEXT;
    END;
    
    -- Test 4: Cleanup function works
    BEGIN
        PERFORM cleanup_old_activity_logs(1000); -- Clean logs older than 1000 days (none should match)
        
        RETURN QUERY SELECT 
            'cleanup_function'::TEXT,
            'SUCCESS'::TEXT,
            'Cleanup function executed without errors'::TEXT;
    EXCEPTION WHEN OTHERS THEN
        RETURN QUERY SELECT 
            'cleanup_function'::TEXT,
            'FAILED'::TEXT, 
            SQLERRM::TEXT;
    END;
    
    -- Clean up test data
    DELETE FROM user_activity_log WHERE user_id = test_user_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.test_all_activity_logging()
 RETURNS TABLE(table_tested text, operation text, result text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    test_member_id text;
    test_family_id text;
    test_org_id text;
    test_activity_id text;
    test_address_id text;
    logs_before integer;
    logs_after integer;
BEGIN
    -- Set mock JWT context
    PERFORM set_config('request.jwt.claims', 
        '{"sub": "' || (SELECT id FROM auth.users LIMIT 1) || '", "email": "admin@aryamahasangh.com"}', 
        true);
    
    -- Get initial log count
    SELECT COUNT(*) INTO logs_before FROM user_activity_log;
    
    -- Test 1: MEMBER operations
    INSERT INTO member (name, phone_number) 
    VALUES ('Test Member', '1234567890')
    RETURNING id INTO test_member_id;
    
    UPDATE member SET name = 'Updated Test Member' WHERE id = test_member_id;
    
    -- Test 2: ADDRESS operations  
    INSERT INTO address (basic_address, state, district) 
    VALUES ('Test Address', 'Test State', 'Test District')
    RETURNING id INTO test_address_id;
    
    UPDATE address SET basic_address = 'Updated Address' WHERE id = test_address_id;
    
    -- Test 3: FAMILY operations
    INSERT INTO family (name, address_id) 
    VALUES ('Test Family', test_address_id)
    RETURNING id INTO test_family_id;
    
    -- Test 4: ORGANISATION operations
    INSERT INTO organisation (name, description) 
    VALUES ('Test Org', 'Test Description')
    RETURNING id INTO test_org_id;
    
    -- Test 5: ACTIVITIES operations
    INSERT INTO activities (name, short_description, long_description, start_datetime, end_datetime) 
    VALUES ('Test Activity', 'Short desc', 'Long desc', NOW() + INTERVAL '1 day', NOW() + INTERVAL '2 days')
    RETURNING id INTO test_activity_id;
    
    -- Test 6: RELATIONSHIP operations
    INSERT INTO organisational_member (organisation_id, member_id, priority)
    VALUES (test_org_id, test_member_id, 1);
    
    INSERT INTO family_member (family_id, member_id, relation_to_head)
    VALUES (test_family_id, test_member_id, 'SELF');
    
    INSERT INTO activity_member (activity_id, member_id, priority)
    VALUES (test_activity_id, test_member_id, 1);
    
    -- Get final log count
    SELECT COUNT(*) INTO logs_after FROM user_activity_log WHERE performed_at > NOW() - INTERVAL '1 minute';
    
    -- Return test results
    RETURN QUERY
    SELECT 'SUMMARY'::text, 'ALL_OPERATIONS'::text, 
           'Created ' || logs_after || ' activity log entries in this test'::text;
    
    RETURN QUERY  
    SELECT 
        primary_entity_table::text,
        action_name::text,
        'SUCCESS - ' || TO_CHAR(performed_at, 'HH24:MI:SS')::text
    FROM user_activity_log 
    WHERE performed_at > NOW() - INTERVAL '1 minute'
    ORDER BY performed_at;
    
    -- Clean up test data
    DELETE FROM activity_member WHERE member_id = test_member_id;
    DELETE FROM family_member WHERE member_id = test_member_id;
    DELETE FROM organisational_member WHERE member_id = test_member_id;
    DELETE FROM activities WHERE id = test_activity_id;
    DELETE FROM organisation WHERE id = test_org_id;
    DELETE FROM family WHERE id = test_family_id;
    DELETE FROM member WHERE id = test_member_id;
    DELETE FROM address WHERE id = test_address_id;
    
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_activity_details(p_request jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_activity_id TEXT;
    v_existing_orgs TEXT[];
    v_new_orgs TEXT[];
    v_existing_members JSONB[];
    v_new_members JSONB[];
    v_org_to_add TEXT[];
    v_org_to_remove TEXT[];
    v_member_to_add JSONB[];
    v_member_to_remove TEXT[];
    v_member JSONB;
    v_existing_member JSONB;
    v_found BOOLEAN;
    v_address_id TEXT;
    v_new_address_id TEXT;
    v_has_address_data BOOLEAN := false;
BEGIN
    -- Extract activity ID
    v_activity_id := p_request->>'activity_id';
    
    IF v_activity_id IS NULL THEN
        RETURN jsonb_build_object(
            'success', false,
            'error_code', 'MISSING_ACTIVITY_ID',
            'error_details', 'Activity ID is required'
        );
    END IF;

    -- Check if activity exists and get current address_id
    SELECT address_id INTO v_address_id 
    FROM activities 
    WHERE id = v_activity_id;
    
    IF NOT FOUND THEN
        RETURN jsonb_build_object(
            'success', false,
            'error_code', 'ACTIVITY_NOT_FOUND',
            'error_details', 'Activity with given ID does not exist'
        );
    END IF;

    BEGIN
        -- Check if address-related data is provided
        v_has_address_data := (
            p_request ? 'address' OR 
            p_request ? 'state' OR 
            p_request ? 'district' OR 
            p_request ? 'latitude' OR 
            p_request ? 'longitude' OR 
            p_request ? 'pincode' OR 
            p_request ? 'vidhansabha'
        );

        -- Handle address updates if address data is provided
        IF v_has_address_data THEN
            IF v_address_id IS NOT NULL THEN
                -- Update existing address
                UPDATE address 
                SET 
                    basic_address = COALESCE(p_request->>'address', basic_address),
                    state = COALESCE(p_request->>'state', state),
                    district = COALESCE(p_request->>'district', district),
                    latitude = CASE 
                        WHEN p_request ? 'latitude' THEN (p_request->>'latitude')::double precision
                        ELSE latitude 
                    END,
                    longitude = CASE 
                        WHEN p_request ? 'longitude' THEN (p_request->>'longitude')::double precision
                        ELSE longitude 
                    END,
                    pincode = COALESCE(p_request->>'pincode', pincode),
                    vidhansabha = COALESCE(p_request->>'vidhansabha', vidhansabha)
                WHERE id = v_address_id;
            ELSE
                -- Create new address
                INSERT INTO address (basic_address, state, district, latitude, longitude, pincode, vidhansabha)
                VALUES (
                    p_request->>'address',
                    p_request->>'state',
                    p_request->>'district',
                    CASE WHEN p_request ? 'latitude' THEN (p_request->>'latitude')::double precision ELSE NULL END,
                    CASE WHEN p_request ? 'longitude' THEN (p_request->>'longitude')::double precision ELSE NULL END,
                    p_request->>'pincode',
                    p_request->>'vidhansabha'
                )
                RETURNING id INTO v_new_address_id;
                
                -- Update activity with new address_id
                UPDATE activities 
                SET address_id = v_new_address_id 
                WHERE id = v_activity_id;
            END IF;
        END IF;

        -- Update basic activity fields (removed address-related fields)
        UPDATE activities 
        SET 
            name = COALESCE(p_request->>'name', name),
            type = CASE 
                WHEN p_request ? 'type' THEN (p_request->>'type')::activity_type
                ELSE type 
            END,
            short_description = COALESCE(p_request->>'shortDescription', short_description),
            long_description = COALESCE(p_request->>'longDescription', long_description),
            start_datetime = CASE 
                WHEN p_request ? 'startDatetime' THEN (p_request->>'startDatetime')::timestamptz
                ELSE start_datetime 
            END,
            end_datetime = CASE 
                WHEN p_request ? 'endDatetime' THEN (p_request->>'endDatetime')::timestamptz
                ELSE end_datetime 
            END,
            media_files = CASE 
                WHEN p_request ? 'mediaFiles' THEN 
                    ARRAY(SELECT jsonb_array_elements_text(p_request->'mediaFiles'))
                ELSE media_files 
            END,
            additional_instructions = COALESCE(p_request->>'additionalInstructions', additional_instructions),
            capacity = CASE 
                WHEN p_request ? 'capacity' THEN (p_request->>'capacity')::integer
                ELSE capacity 
            END,
            allowed_gender = CASE 
                WHEN p_request ? 'allowedGender' THEN (p_request->>'allowedGender')::gender_filter
                ELSE allowed_gender 
            END
        WHERE id = v_activity_id;

        -- Handle organization relationships if provided
        IF p_request ? 'organisations' THEN
            -- Get existing organizations
            SELECT ARRAY(
                SELECT organisation_id 
                FROM organisational_activity 
                WHERE activity_id = v_activity_id
            ) INTO v_existing_orgs;
            
            -- Get new organizations
            SELECT ARRAY(
                SELECT jsonb_array_elements_text(p_request->'organisations')
            ) INTO v_new_orgs;
            
            -- Find organizations to add (in new but not in existing)
            SELECT ARRAY(
                SELECT unnest(v_new_orgs)
                EXCEPT
                SELECT unnest(v_existing_orgs)
            ) INTO v_org_to_add;
            
            -- Find organizations to remove (in existing but not in new)
            SELECT ARRAY(
                SELECT unnest(v_existing_orgs)
                EXCEPT
                SELECT unnest(v_new_orgs)
            ) INTO v_org_to_remove;
            
            -- Remove organizations that are no longer associated
            IF array_length(v_org_to_remove, 1) > 0 THEN
                DELETE FROM organisational_activity 
                WHERE activity_id = v_activity_id 
                AND organisation_id = ANY(v_org_to_remove);
            END IF;
            
            -- Add new organizations
            IF array_length(v_org_to_add, 1) > 0 THEN
                INSERT INTO organisational_activity (activity_id, organisation_id)
                SELECT v_activity_id, unnest(v_org_to_add);
            END IF;
        END IF;

        -- Handle member relationships if provided
        IF p_request ? 'members' THEN
            -- Get existing members as JSONB for comparison
            SELECT ARRAY(
                SELECT jsonb_build_object(
                    'member_id', member_id,
                    'post', post,
                    'priority', priority
                )
                FROM activity_member 
                WHERE activity_id = v_activity_id
            ) INTO v_existing_members;
            
            -- Get new members
            SELECT ARRAY(
                SELECT jsonb_array_elements(p_request->'members')
            ) INTO v_new_members;
            
            -- Find members to remove (existing members not in new list)
            v_member_to_remove := ARRAY[]::TEXT[];
            FOREACH v_existing_member IN ARRAY v_existing_members
            LOOP
                v_found := false;
                FOREACH v_member IN ARRAY v_new_members
                LOOP
                    IF (v_existing_member->>'member_id') = (v_member->>'memberId') THEN
                        v_found := true;
                        EXIT;
                    END IF;
                END LOOP;
                
                IF NOT v_found THEN
                    v_member_to_remove := v_member_to_remove || (v_existing_member->>'member_id');
                END IF;
            END LOOP;
            
            -- Remove members that are no longer associated
            IF array_length(v_member_to_remove, 1) > 0 THEN
                DELETE FROM activity_member 
                WHERE activity_id = v_activity_id 
                AND member_id = ANY(v_member_to_remove);
            END IF;
            
            -- Update or insert members
            FOREACH v_member IN ARRAY v_new_members
            LOOP
                -- Check if member already exists
                IF EXISTS (
                    SELECT 1 FROM activity_member 
                    WHERE activity_id = v_activity_id 
                    AND member_id = (v_member->>'memberId')
                ) THEN
                    -- Update existing member
                    UPDATE activity_member 
                    SET 
                        post = COALESCE(v_member->>'post', post),
                        priority = CASE 
                            WHEN v_member ? 'priority' THEN (v_member->>'priority')::integer
                            ELSE priority 
                        END
                    WHERE activity_id = v_activity_id 
                    AND member_id = (v_member->>'memberId');
                ELSE
                    -- Insert new member
                    INSERT INTO activity_member (activity_id, member_id, post, priority)
                    VALUES (
                        v_activity_id,
                        v_member->>'memberId',
                        COALESCE(v_member->>'post', ''),
                        COALESCE((v_member->>'priority')::integer, 1)
                    );
                END IF;
            END LOOP;
        END IF;

        RETURN jsonb_build_object(
            'success', true,
            'message_code', 'ACTIVITY_UPDATED_SUCCESSFULLY'
        );

    EXCEPTION WHEN OTHERS THEN
        RETURN jsonb_build_object(
            'success', false,
            'error_code', 'ERROR_UPDATING_ACTIVITY',
            'error_details', SQLERRM
        );
    END;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_activity_details_smart(p_request jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_activity_id TEXT;
    v_address_id TEXT;
    v_existing_orgs TEXT[];
    v_new_orgs TEXT[];
    v_orgs_to_add TEXT[];
    v_orgs_to_remove TEXT[];
    v_existing_members JSONB[];
    v_new_members JSONB[];
    v_member_to_remove TEXT[];
    v_member JSONB;
    v_existing_member JSONB;
    v_found BOOLEAN;
    v_address_json JSONB;
    v_media_files TEXT[];
BEGIN
    -- 1. Validate activity exists
    v_activity_id := p_request->>'activity_id';
    IF v_activity_id IS NULL OR NOT EXISTS (SELECT 1 FROM activities WHERE id = v_activity_id) THEN
      RETURN jsonb_build_object(
        'success', false,
        'error_code', 'ACTIVITY_NOT_FOUND',
        'error_details', 'Activity ID missing or does not exist'
      );
    END IF;

    -- 2. Update core activity fields
    UPDATE activities SET
      name = COALESCE(p_request->>'name', name),
      type = CASE WHEN p_request ? 'type' THEN (p_request->>'type')::activity_type ELSE type END,
      short_description = COALESCE(p_request->>'shortDescription', short_description),
      long_description = COALESCE(p_request->>'longDescription', long_description),
      start_datetime = CASE WHEN p_request ? 'startDatetime' THEN (p_request->>'startDatetime')::timestamptz ELSE start_datetime END,
      end_datetime = CASE WHEN p_request ? 'endDatetime' THEN (p_request->>'endDatetime')::timestamptz ELSE end_datetime END,
      additional_instructions = COALESCE(p_request->>'additionalInstructions', additional_instructions),
      capacity = CASE WHEN p_request ? 'capacity' THEN (p_request->>'capacity')::integer ELSE capacity END,
      latitude = CASE WHEN p_request ? 'latitude' THEN (p_request->>'latitude')::double precision ELSE latitude END,
      longitude = CASE WHEN p_request ? 'longitude' THEN (p_request->>'longitude')::double precision ELSE longitude END,
      allowed_gender = CASE WHEN p_request ? 'allowedGender' THEN (p_request->>'allowedGender')::gender_filter ELSE allowed_gender END,
      media_files = CASE WHEN p_request ? 'mediaFiles' THEN ARRAY(SELECT jsonb_array_elements_text(p_request->'mediaFiles')) ELSE media_files END
    WHERE id = v_activity_id;

    -- 3. Address update/delete
    v_address_id := p_request->>'address_id';

    IF p_request ? 'address' AND v_address_id IS NOT NULL THEN
      v_address_json := p_request->'address';
      -- If any address field is present, update the address record
      UPDATE address SET
        basic_address = COALESCE(v_address_json->>'address', basic_address),
        state = COALESCE(v_address_json->>'state', state),
        district = COALESCE(v_address_json->>'district', district),
        latitude = CASE WHEN v_address_json ? 'latitude' THEN (v_address_json->>'latitude')::double precision ELSE latitude END,
        longitude = CASE WHEN v_address_json ? 'longitude' THEN (v_address_json->>'longitude')::double precision ELSE longitude END
        -- (add more fields as needed)
      WHERE id = v_address_id;
    ELSIF p_request ? 'address_id' AND (p_request->'address' IS NULL OR p_request->'address' = 'null'::jsonb) THEN
      -- Delete address if address data is null/empty
      DELETE FROM address WHERE id = v_address_id;
      UPDATE activities SET address_id = NULL WHERE id = v_activity_id;
    END IF;

    -- 4. Organisations diff/add/remove
    IF p_request ? 'organisations' THEN
      SELECT ARRAY(SELECT organisation_id FROM organisational_activity WHERE activity_id = v_activity_id)
        INTO v_existing_orgs;
      SELECT ARRAY(SELECT jsonb_array_elements_text(p_request->'organisations'))
        INTO v_new_orgs;
      SELECT ARRAY(SELECT unnest(v_new_orgs) EXCEPT SELECT unnest(v_existing_orgs)) INTO v_orgs_to_add;
      SELECT ARRAY(SELECT unnest(v_existing_orgs) EXCEPT SELECT unnest(v_new_orgs)) INTO v_orgs_to_remove;

      IF array_length(v_orgs_to_remove, 1) > 0 THEN
        DELETE FROM organisational_activity WHERE activity_id = v_activity_id AND organisation_id = ANY(v_orgs_to_remove);
      END IF;
      IF array_length(v_orgs_to_add, 1) > 0 THEN
        INSERT INTO organisational_activity (activity_id, organisation_id)
        SELECT v_activity_id, unnest(v_orgs_to_add);
      END IF;
    END IF;

    -- 5. Members diff/add/remove/update
    IF p_request ? 'members' THEN
      SELECT ARRAY(
        SELECT jsonb_build_object(
          'member_id', member_id,
          'post', post,
          'priority', priority
        ) FROM activity_member WHERE activity_id = v_activity_id
      ) INTO v_existing_members;

      SELECT ARRAY(
        SELECT jsonb_array_elements(p_request->'members')
      ) INTO v_new_members;

      v_member_to_remove := ARRAY[]::TEXT[];
      FOREACH v_existing_member IN ARRAY v_existing_members
      LOOP
        v_found := false;
        FOREACH v_member IN ARRAY v_new_members
        LOOP
          IF (v_existing_member->>'member_id') = COALESCE(v_member->>'memberId', v_member->>'member_id') THEN
            v_found := true; EXIT;
          END IF;
        END LOOP;
        IF NOT v_found THEN
          v_member_to_remove := v_member_to_remove || (v_existing_member->>'member_id');
        END IF;
      END LOOP;

      IF array_length(v_member_to_remove, 1) > 0 THEN
        DELETE FROM activity_member WHERE activity_id = v_activity_id AND member_id = ANY(v_member_to_remove);
      END IF;

      FOREACH v_member IN ARRAY v_new_members
      LOOP
        -- Always use COALESCE for camel/snake-case
        IF COALESCE(v_member->>'memberId', v_member->>'member_id') IS NOT NULL AND EXISTS (
          SELECT 1 FROM activity_member
            WHERE activity_id = v_activity_id
              AND member_id = COALESCE(v_member->>'memberId', v_member->>'member_id')
        ) THEN
          -- Update
          UPDATE activity_member SET
            post = COALESCE(v_member->>'post', post),
            priority = CASE WHEN v_member ? 'priority' THEN (v_member->>'priority')::integer ELSE priority END
          WHERE activity_id = v_activity_id
            AND member_id = COALESCE(v_member->>'memberId', v_member->>'member_id');
        ELSIF COALESCE(v_member->>'memberId', v_member->>'member_id') IS NOT NULL THEN
          -- Insert
          INSERT INTO activity_member (activity_id, member_id, post, priority)
          VALUES (
            v_activity_id,
            COALESCE(v_member->>'memberId', v_member->>'member_id'),
            COALESCE(v_member->>'post', ''),
            COALESCE((v_member->>'priority')::integer, 1)
          );
        END IF;
      END LOOP;
    END IF;

    RETURN jsonb_build_object(
      'success', true,
      'message_code', 'ACTIVITY_UPDATED_SUCCESSFULLY'
    );
EXCEPTION WHEN OTHERS THEN
    RETURN jsonb_build_object(
      'success', false,
      'error_code', 'ERROR_UPDATING_ACTIVITY',
      'error_details', SQLERRM
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_activity_with_relations(p_activity_id text, p_activity_data jsonb, p_organisations jsonb DEFAULT '[]'::jsonb, p_contact_people jsonb DEFAULT '[]'::jsonb)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
DECLARE
    result JSON;
    v_org JSONB;
    v_contact JSONB;
BEGIN
    -- Start transaction (implicit in function)
    
    -- 1. Update the main activity record
    UPDATE activities 
    SET 
        name = COALESCE((p_activity_data->>'name'), name),
        type = COALESCE((p_activity_data->>'type')::activity_type, type),
        short_description = COALESCE((p_activity_data->>'short_description'), short_description),
        long_description = COALESCE((p_activity_data->>'long_description'), long_description),
        start_datetime = COALESCE((p_activity_data->>'start_datetime')::timestamptz, start_datetime),
        end_datetime = COALESCE((p_activity_data->>'end_datetime')::timestamptz, end_datetime),
        media_files = COALESCE((p_activity_data->>'media_files')::text[], media_files),
        additional_instructions = COALESCE((p_activity_data->>'additional_instructions'), additional_instructions),
        capacity = COALESCE((p_activity_data->>'capacity')::integer, capacity),
        allowed_gender = COALESCE((p_activity_data->>'allowed_gender')::gender_filter, allowed_gender)
    WHERE id = p_activity_id;
    
    -- Check if activity exists
    IF NOT FOUND THEN
        RETURN json_build_object(
            'success', false,
            'error_code', 'ACTIVITY_NOT_FOUND',
            'message_code', 'ACTIVITY_NOT_FOUND'
        );
    END IF;
    
    -- 2. Clear existing relations
    DELETE FROM organisational_activity WHERE activity_id = p_activity_id;
    DELETE FROM activity_member WHERE activity_id = p_activity_id;
    
    -- 3. Insert new organisation relations
    FOR v_org IN SELECT * FROM jsonb_array_elements(p_organisations)
    LOOP
        INSERT INTO organisational_activity (id, organisation_id, activity_id)
        VALUES (gen_random_uuid()::text, v_org->>'id', p_activity_id);
    END LOOP;
    
    -- 4. Insert new contact people relations
    FOR v_contact IN SELECT * FROM jsonb_array_elements(p_contact_people)
    LOOP
        INSERT INTO activity_member (id, activity_id, member_id, post, priority)
        VALUES (
            gen_random_uuid()::text, 
            p_activity_id, 
            v_contact->>'member_id',
            COALESCE(v_contact->>'post', ''),
            COALESCE((v_contact->>'priority')::integer, 1)
        );
    END LOOP;
    
    -- Return success
    RETURN json_build_object(
        'success', true,
        'activity_id', p_activity_id,
        'message_code', 'ACTIVITY_UPDATED_SUCCESSFULLY'
    );

EXCEPTION
    WHEN OTHERS THEN
        -- Return error information
        RETURN json_build_object(
            'success', false,
            'error_code', 'ERROR_UPDATING_ACTIVITY',
            'message_code', 'ACTIVITY_UPDATE_FAILED',
            'error_details', SQLERRM
        );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_arya_samaj_details(p_arya_samaj_id text, p_samaj_name text DEFAULT NULL::text, p_samaj_description text DEFAULT NULL::text, p_basic_address text DEFAULT NULL::text, p_state text DEFAULT NULL::text, p_district text DEFAULT NULL::text, p_samaj_media_urls text[] DEFAULT NULL::text[], p_pincode text DEFAULT NULL::text, p_latitude double precision DEFAULT NULL::double precision, p_longitude double precision DEFAULT NULL::double precision, p_vidhansabha text DEFAULT NULL::text)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_address_id TEXT;
    result JSON;
BEGIN
    -- Check if Arya Samaj exists and get address_id
    SELECT address_id INTO v_address_id
    FROM arya_samaj 
    WHERE id = p_arya_samaj_id;
    
    IF v_address_id IS NULL THEN
        result := json_build_object(
            'success', false,
            'error_code', 'ARYA_SAMAJ_NOT_FOUND',
            'arya_samaj_id', p_arya_samaj_id
        );
        RETURN result;
    END IF;
    
    -- Update arya_samaj table (only update non-null values)
    UPDATE arya_samaj 
    SET 
        name = COALESCE(p_samaj_name, name),
        description = COALESCE(p_samaj_description, description),
        media_urls = COALESCE(p_samaj_media_urls, media_urls)
    WHERE id = p_arya_samaj_id;
    
    -- Update address table (only update non-null values)
    UPDATE address 
    SET 
        basic_address = COALESCE(p_basic_address, basic_address),
        state = COALESCE(p_state, state),
        district = COALESCE(p_district, district),
        pincode = COALESCE(p_pincode, pincode),
        latitude = COALESCE(p_latitude, latitude),
        longitude = COALESCE(p_longitude, longitude),
        vidhansabha = COALESCE(p_vidhansabha, vidhansabha)
    WHERE id = v_address_id;
    
    -- Return success result
    result := json_build_object(
        'success', true,
        'arya_samaj_id', p_arya_samaj_id,
        'address_id', v_address_id,
        'message_code', 'ARYA_SAMAJ_UPDATED_SUCCESSFULLY'
    );
    
    RETURN result;
    
EXCEPTION
    WHEN OTHERS THEN
        -- Return error information
        result := json_build_object(
            'success', false,
            'error_code', 'ERROR_UPDATING_ARYA_SAMAJ_DETAILS',
            'error_details', SQLERRM
        );
        RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_member_details(p_member_id text, p_name text DEFAULT NULL::text, p_phone_number text DEFAULT NULL::text, p_profile_image text DEFAULT NULL::text, p_educational_qualification text DEFAULT NULL::text, p_email text DEFAULT NULL::text, p_dob date DEFAULT NULL::date, p_address_id text DEFAULT NULL::text, p_arya_samaj_id text DEFAULT NULL::text, p_joining_date date DEFAULT NULL::date, p_temp_address_id text DEFAULT NULL::text, p_referrer_id text DEFAULT NULL::text, p_occupation text DEFAULT NULL::text, p_introduction text DEFAULT NULL::text, p_gender text DEFAULT NULL::text, p_basic_address text DEFAULT NULL::text, p_state text DEFAULT NULL::text, p_district text DEFAULT NULL::text, p_pincode text DEFAULT NULL::text, p_latitude double precision DEFAULT NULL::double precision, p_longitude double precision DEFAULT NULL::double precision, p_vidhansabha text DEFAULT NULL::text, p_temp_basic_address text DEFAULT NULL::text, p_temp_state text DEFAULT NULL::text, p_temp_district text DEFAULT NULL::text, p_temp_pincode text DEFAULT NULL::text, p_temp_latitude double precision DEFAULT NULL::double precision, p_temp_longitude double precision DEFAULT NULL::double precision, p_temp_vidhansabha text DEFAULT NULL::text)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
DECLARE
    result JSON;
    v_address_id TEXT;
    v_temp_address_id TEXT;
    v_has_address_fields BOOLEAN;
    v_has_temp_address_fields BOOLEAN;
BEGIN
    -- Check if member exists
    IF NOT EXISTS (SELECT 1 FROM member WHERE id = p_member_id) THEN
        result := json_build_object(
            'success', false,
            'error_code', 'MEMBER_NOT_FOUND',
            'member_id', p_member_id
        );
        RETURN result;
    END IF;
    
    -- Update member (only update non-null values)
    UPDATE member 
    SET 
        name = COALESCE(p_name, name),
        phone_number = COALESCE(p_phone_number, phone_number),
        profile_image = COALESCE(p_profile_image, profile_image),
        educational_qualification = COALESCE(p_educational_qualification, educational_qualification),
        email = COALESCE(p_email, email),
        dob = COALESCE(p_dob, dob),
        occupation = COALESCE(p_occupation, occupation),
        introduction = COALESCE(p_introduction, introduction),
        gender = COALESCE(p_gender::gender_filter, gender)
    WHERE id = p_member_id;
    
    -- Return success result
    result := json_build_object(
        'success', true,
        'member_id', p_member_id,
        'message_code', 'MEMBER_UPDATED_SUCCESSFULLY'
    );
    
    RETURN result;
    
EXCEPTION
    WHEN OTHERS THEN
        -- Return error information
        result := json_build_object(
            'success', false,
            'error_code', 'ERROR_UPDATING_MEMBER_DETAILS',
            'error_details', SQLERRM
        );
        RETURN result;
END;
$function$
;

grant delete on table "public"."activities" to "anon";

grant insert on table "public"."activities" to "anon";

grant references on table "public"."activities" to "anon";

grant select on table "public"."activities" to "anon";

grant trigger on table "public"."activities" to "anon";

grant truncate on table "public"."activities" to "anon";

grant update on table "public"."activities" to "anon";

grant delete on table "public"."activities" to "authenticated";

grant insert on table "public"."activities" to "authenticated";

grant references on table "public"."activities" to "authenticated";

grant select on table "public"."activities" to "authenticated";

grant trigger on table "public"."activities" to "authenticated";

grant truncate on table "public"."activities" to "authenticated";

grant update on table "public"."activities" to "authenticated";

grant delete on table "public"."activities" to "service_role";

grant insert on table "public"."activities" to "service_role";

grant references on table "public"."activities" to "service_role";

grant select on table "public"."activities" to "service_role";

grant trigger on table "public"."activities" to "service_role";

grant truncate on table "public"."activities" to "service_role";

grant update on table "public"."activities" to "service_role";

grant delete on table "public"."activity_member" to "anon";

grant insert on table "public"."activity_member" to "anon";

grant references on table "public"."activity_member" to "anon";

grant select on table "public"."activity_member" to "anon";

grant trigger on table "public"."activity_member" to "anon";

grant truncate on table "public"."activity_member" to "anon";

grant update on table "public"."activity_member" to "anon";

grant delete on table "public"."activity_member" to "authenticated";

grant insert on table "public"."activity_member" to "authenticated";

grant references on table "public"."activity_member" to "authenticated";

grant select on table "public"."activity_member" to "authenticated";

grant trigger on table "public"."activity_member" to "authenticated";

grant truncate on table "public"."activity_member" to "authenticated";

grant update on table "public"."activity_member" to "authenticated";

grant delete on table "public"."activity_member" to "service_role";

grant insert on table "public"."activity_member" to "service_role";

grant references on table "public"."activity_member" to "service_role";

grant select on table "public"."activity_member" to "service_role";

grant trigger on table "public"."activity_member" to "service_role";

grant truncate on table "public"."activity_member" to "service_role";

grant update on table "public"."activity_member" to "service_role";

grant delete on table "public"."address" to "anon";

grant insert on table "public"."address" to "anon";

grant references on table "public"."address" to "anon";

grant select on table "public"."address" to "anon";

grant trigger on table "public"."address" to "anon";

grant truncate on table "public"."address" to "anon";

grant update on table "public"."address" to "anon";

grant delete on table "public"."address" to "authenticated";

grant insert on table "public"."address" to "authenticated";

grant references on table "public"."address" to "authenticated";

grant select on table "public"."address" to "authenticated";

grant trigger on table "public"."address" to "authenticated";

grant truncate on table "public"."address" to "authenticated";

grant update on table "public"."address" to "authenticated";

grant delete on table "public"."address" to "service_role";

grant insert on table "public"."address" to "service_role";

grant references on table "public"."address" to "service_role";

grant select on table "public"."address" to "service_role";

grant trigger on table "public"."address" to "service_role";

grant truncate on table "public"."address" to "service_role";

grant update on table "public"."address" to "service_role";

grant delete on table "public"."admission" to "anon";

grant insert on table "public"."admission" to "anon";

grant references on table "public"."admission" to "anon";

grant select on table "public"."admission" to "anon";

grant trigger on table "public"."admission" to "anon";

grant truncate on table "public"."admission" to "anon";

grant update on table "public"."admission" to "anon";

grant delete on table "public"."admission" to "authenticated";

grant insert on table "public"."admission" to "authenticated";

grant references on table "public"."admission" to "authenticated";

grant select on table "public"."admission" to "authenticated";

grant trigger on table "public"."admission" to "authenticated";

grant truncate on table "public"."admission" to "authenticated";

grant update on table "public"."admission" to "authenticated";

grant delete on table "public"."admission" to "service_role";

grant insert on table "public"."admission" to "service_role";

grant references on table "public"."admission" to "service_role";

grant select on table "public"."admission" to "service_role";

grant trigger on table "public"."admission" to "service_role";

grant truncate on table "public"."admission" to "service_role";

grant update on table "public"."admission" to "service_role";

grant delete on table "public"."app_labels" to "anon";

grant insert on table "public"."app_labels" to "anon";

grant references on table "public"."app_labels" to "anon";

grant select on table "public"."app_labels" to "anon";

grant trigger on table "public"."app_labels" to "anon";

grant truncate on table "public"."app_labels" to "anon";

grant update on table "public"."app_labels" to "anon";

grant delete on table "public"."app_labels" to "authenticated";

grant insert on table "public"."app_labels" to "authenticated";

grant references on table "public"."app_labels" to "authenticated";

grant select on table "public"."app_labels" to "authenticated";

grant trigger on table "public"."app_labels" to "authenticated";

grant truncate on table "public"."app_labels" to "authenticated";

grant update on table "public"."app_labels" to "authenticated";

grant delete on table "public"."app_labels" to "service_role";

grant insert on table "public"."app_labels" to "service_role";

grant references on table "public"."app_labels" to "service_role";

grant select on table "public"."app_labels" to "service_role";

grant trigger on table "public"."app_labels" to "service_role";

grant truncate on table "public"."app_labels" to "service_role";

grant update on table "public"."app_labels" to "service_role";

grant delete on table "public"."arya_samaj" to "anon";

grant insert on table "public"."arya_samaj" to "anon";

grant references on table "public"."arya_samaj" to "anon";

grant select on table "public"."arya_samaj" to "anon";

grant trigger on table "public"."arya_samaj" to "anon";

grant truncate on table "public"."arya_samaj" to "anon";

grant update on table "public"."arya_samaj" to "anon";

grant delete on table "public"."arya_samaj" to "authenticated";

grant insert on table "public"."arya_samaj" to "authenticated";

grant references on table "public"."arya_samaj" to "authenticated";

grant select on table "public"."arya_samaj" to "authenticated";

grant trigger on table "public"."arya_samaj" to "authenticated";

grant truncate on table "public"."arya_samaj" to "authenticated";

grant update on table "public"."arya_samaj" to "authenticated";

grant delete on table "public"."arya_samaj" to "service_role";

grant insert on table "public"."arya_samaj" to "service_role";

grant references on table "public"."arya_samaj" to "service_role";

grant select on table "public"."arya_samaj" to "service_role";

grant trigger on table "public"."arya_samaj" to "service_role";

grant truncate on table "public"."arya_samaj" to "service_role";

grant update on table "public"."arya_samaj" to "service_role";

grant delete on table "public"."book_orders" to "anon";

grant insert on table "public"."book_orders" to "anon";

grant references on table "public"."book_orders" to "anon";

grant select on table "public"."book_orders" to "anon";

grant trigger on table "public"."book_orders" to "anon";

grant truncate on table "public"."book_orders" to "anon";

grant update on table "public"."book_orders" to "anon";

grant delete on table "public"."book_orders" to "authenticated";

grant insert on table "public"."book_orders" to "authenticated";

grant references on table "public"."book_orders" to "authenticated";

grant select on table "public"."book_orders" to "authenticated";

grant trigger on table "public"."book_orders" to "authenticated";

grant truncate on table "public"."book_orders" to "authenticated";

grant update on table "public"."book_orders" to "authenticated";

grant delete on table "public"."book_orders" to "service_role";

grant insert on table "public"."book_orders" to "service_role";

grant references on table "public"."book_orders" to "service_role";

grant select on table "public"."book_orders" to "service_role";

grant trigger on table "public"."book_orders" to "service_role";

grant truncate on table "public"."book_orders" to "service_role";

grant update on table "public"."book_orders" to "service_role";

grant delete on table "public"."course_registrations" to "anon";

grant insert on table "public"."course_registrations" to "anon";

grant references on table "public"."course_registrations" to "anon";

grant select on table "public"."course_registrations" to "anon";

grant trigger on table "public"."course_registrations" to "anon";

grant truncate on table "public"."course_registrations" to "anon";

grant update on table "public"."course_registrations" to "anon";

grant delete on table "public"."course_registrations" to "authenticated";

grant insert on table "public"."course_registrations" to "authenticated";

grant references on table "public"."course_registrations" to "authenticated";

grant select on table "public"."course_registrations" to "authenticated";

grant trigger on table "public"."course_registrations" to "authenticated";

grant truncate on table "public"."course_registrations" to "authenticated";

grant update on table "public"."course_registrations" to "authenticated";

grant delete on table "public"."course_registrations" to "service_role";

grant insert on table "public"."course_registrations" to "service_role";

grant references on table "public"."course_registrations" to "service_role";

grant select on table "public"."course_registrations" to "service_role";

grant trigger on table "public"."course_registrations" to "service_role";

grant truncate on table "public"."course_registrations" to "service_role";

grant update on table "public"."course_registrations" to "service_role";

grant delete on table "public"."family" to "anon";

grant insert on table "public"."family" to "anon";

grant references on table "public"."family" to "anon";

grant select on table "public"."family" to "anon";

grant trigger on table "public"."family" to "anon";

grant truncate on table "public"."family" to "anon";

grant update on table "public"."family" to "anon";

grant delete on table "public"."family" to "authenticated";

grant insert on table "public"."family" to "authenticated";

grant references on table "public"."family" to "authenticated";

grant select on table "public"."family" to "authenticated";

grant trigger on table "public"."family" to "authenticated";

grant truncate on table "public"."family" to "authenticated";

grant update on table "public"."family" to "authenticated";

grant delete on table "public"."family" to "service_role";

grant insert on table "public"."family" to "service_role";

grant references on table "public"."family" to "service_role";

grant select on table "public"."family" to "service_role";

grant trigger on table "public"."family" to "service_role";

grant truncate on table "public"."family" to "service_role";

grant update on table "public"."family" to "service_role";

grant delete on table "public"."family_member" to "anon";

grant insert on table "public"."family_member" to "anon";

grant references on table "public"."family_member" to "anon";

grant select on table "public"."family_member" to "anon";

grant trigger on table "public"."family_member" to "anon";

grant truncate on table "public"."family_member" to "anon";

grant update on table "public"."family_member" to "anon";

grant delete on table "public"."family_member" to "authenticated";

grant insert on table "public"."family_member" to "authenticated";

grant references on table "public"."family_member" to "authenticated";

grant select on table "public"."family_member" to "authenticated";

grant trigger on table "public"."family_member" to "authenticated";

grant truncate on table "public"."family_member" to "authenticated";

grant update on table "public"."family_member" to "authenticated";

grant delete on table "public"."family_member" to "service_role";

grant insert on table "public"."family_member" to "service_role";

grant references on table "public"."family_member" to "service_role";

grant select on table "public"."family_member" to "service_role";

grant trigger on table "public"."family_member" to "service_role";

grant truncate on table "public"."family_member" to "service_role";

grant update on table "public"."family_member" to "service_role";

grant delete on table "public"."learning" to "anon";

grant insert on table "public"."learning" to "anon";

grant references on table "public"."learning" to "anon";

grant select on table "public"."learning" to "anon";

grant trigger on table "public"."learning" to "anon";

grant truncate on table "public"."learning" to "anon";

grant update on table "public"."learning" to "anon";

grant delete on table "public"."learning" to "authenticated";

grant insert on table "public"."learning" to "authenticated";

grant references on table "public"."learning" to "authenticated";

grant select on table "public"."learning" to "authenticated";

grant trigger on table "public"."learning" to "authenticated";

grant truncate on table "public"."learning" to "authenticated";

grant update on table "public"."learning" to "authenticated";

grant delete on table "public"."learning" to "service_role";

grant insert on table "public"."learning" to "service_role";

grant references on table "public"."learning" to "service_role";

grant select on table "public"."learning" to "service_role";

grant trigger on table "public"."learning" to "service_role";

grant truncate on table "public"."learning" to "service_role";

grant update on table "public"."learning" to "service_role";

grant delete on table "public"."member" to "anon";

grant insert on table "public"."member" to "anon";

grant references on table "public"."member" to "anon";

grant select on table "public"."member" to "anon";

grant trigger on table "public"."member" to "anon";

grant truncate on table "public"."member" to "anon";

grant update on table "public"."member" to "anon";

grant delete on table "public"."member" to "authenticated";

grant insert on table "public"."member" to "authenticated";

grant references on table "public"."member" to "authenticated";

grant select on table "public"."member" to "authenticated";

grant trigger on table "public"."member" to "authenticated";

grant truncate on table "public"."member" to "authenticated";

grant update on table "public"."member" to "authenticated";

grant delete on table "public"."member" to "service_role";

grant insert on table "public"."member" to "service_role";

grant references on table "public"."member" to "service_role";

grant select on table "public"."member" to "service_role";

grant trigger on table "public"."member" to "service_role";

grant truncate on table "public"."member" to "service_role";

grant update on table "public"."member" to "service_role";

grant delete on table "public"."organisation" to "anon";

grant insert on table "public"."organisation" to "anon";

grant references on table "public"."organisation" to "anon";

grant select on table "public"."organisation" to "anon";

grant trigger on table "public"."organisation" to "anon";

grant truncate on table "public"."organisation" to "anon";

grant update on table "public"."organisation" to "anon";

grant delete on table "public"."organisation" to "authenticated";

grant insert on table "public"."organisation" to "authenticated";

grant references on table "public"."organisation" to "authenticated";

grant select on table "public"."organisation" to "authenticated";

grant trigger on table "public"."organisation" to "authenticated";

grant truncate on table "public"."organisation" to "authenticated";

grant update on table "public"."organisation" to "authenticated";

grant delete on table "public"."organisation" to "service_role";

grant insert on table "public"."organisation" to "service_role";

grant references on table "public"."organisation" to "service_role";

grant select on table "public"."organisation" to "service_role";

grant trigger on table "public"."organisation" to "service_role";

grant truncate on table "public"."organisation" to "service_role";

grant update on table "public"."organisation" to "service_role";

grant delete on table "public"."organisational_activity" to "anon";

grant insert on table "public"."organisational_activity" to "anon";

grant references on table "public"."organisational_activity" to "anon";

grant select on table "public"."organisational_activity" to "anon";

grant trigger on table "public"."organisational_activity" to "anon";

grant truncate on table "public"."organisational_activity" to "anon";

grant update on table "public"."organisational_activity" to "anon";

grant delete on table "public"."organisational_activity" to "authenticated";

grant insert on table "public"."organisational_activity" to "authenticated";

grant references on table "public"."organisational_activity" to "authenticated";

grant select on table "public"."organisational_activity" to "authenticated";

grant trigger on table "public"."organisational_activity" to "authenticated";

grant truncate on table "public"."organisational_activity" to "authenticated";

grant update on table "public"."organisational_activity" to "authenticated";

grant delete on table "public"."organisational_activity" to "service_role";

grant insert on table "public"."organisational_activity" to "service_role";

grant references on table "public"."organisational_activity" to "service_role";

grant select on table "public"."organisational_activity" to "service_role";

grant trigger on table "public"."organisational_activity" to "service_role";

grant truncate on table "public"."organisational_activity" to "service_role";

grant update on table "public"."organisational_activity" to "service_role";

grant delete on table "public"."organisational_member" to "anon";

grant insert on table "public"."organisational_member" to "anon";

grant references on table "public"."organisational_member" to "anon";

grant select on table "public"."organisational_member" to "anon";

grant trigger on table "public"."organisational_member" to "anon";

grant truncate on table "public"."organisational_member" to "anon";

grant update on table "public"."organisational_member" to "anon";

grant delete on table "public"."organisational_member" to "authenticated";

grant insert on table "public"."organisational_member" to "authenticated";

grant references on table "public"."organisational_member" to "authenticated";

grant select on table "public"."organisational_member" to "authenticated";

grant trigger on table "public"."organisational_member" to "authenticated";

grant truncate on table "public"."organisational_member" to "authenticated";

grant update on table "public"."organisational_member" to "authenticated";

grant delete on table "public"."organisational_member" to "service_role";

grant insert on table "public"."organisational_member" to "service_role";

grant references on table "public"."organisational_member" to "service_role";

grant select on table "public"."organisational_member" to "service_role";

grant trigger on table "public"."organisational_member" to "service_role";

grant truncate on table "public"."organisational_member" to "service_role";

grant update on table "public"."organisational_member" to "service_role";

grant delete on table "public"."samaj_member" to "anon";

grant insert on table "public"."samaj_member" to "anon";

grant references on table "public"."samaj_member" to "anon";

grant select on table "public"."samaj_member" to "anon";

grant trigger on table "public"."samaj_member" to "anon";

grant truncate on table "public"."samaj_member" to "anon";

grant update on table "public"."samaj_member" to "anon";

grant delete on table "public"."samaj_member" to "authenticated";

grant insert on table "public"."samaj_member" to "authenticated";

grant references on table "public"."samaj_member" to "authenticated";

grant select on table "public"."samaj_member" to "authenticated";

grant trigger on table "public"."samaj_member" to "authenticated";

grant truncate on table "public"."samaj_member" to "authenticated";

grant update on table "public"."samaj_member" to "authenticated";

grant delete on table "public"."samaj_member" to "service_role";

grant insert on table "public"."samaj_member" to "service_role";

grant references on table "public"."samaj_member" to "service_role";

grant select on table "public"."samaj_member" to "service_role";

grant trigger on table "public"."samaj_member" to "service_role";

grant truncate on table "public"."samaj_member" to "service_role";

grant update on table "public"."samaj_member" to "service_role";

grant delete on table "public"."satr_registration" to "anon";

grant insert on table "public"."satr_registration" to "anon";

grant references on table "public"."satr_registration" to "anon";

grant select on table "public"."satr_registration" to "anon";

grant trigger on table "public"."satr_registration" to "anon";

grant truncate on table "public"."satr_registration" to "anon";

grant update on table "public"."satr_registration" to "anon";

grant delete on table "public"."satr_registration" to "authenticated";

grant insert on table "public"."satr_registration" to "authenticated";

grant references on table "public"."satr_registration" to "authenticated";

grant select on table "public"."satr_registration" to "authenticated";

grant trigger on table "public"."satr_registration" to "authenticated";

grant truncate on table "public"."satr_registration" to "authenticated";

grant update on table "public"."satr_registration" to "authenticated";

grant delete on table "public"."satr_registration" to "service_role";

grant insert on table "public"."satr_registration" to "service_role";

grant references on table "public"."satr_registration" to "service_role";

grant select on table "public"."satr_registration" to "service_role";

grant trigger on table "public"."satr_registration" to "service_role";

grant truncate on table "public"."satr_registration" to "service_role";

grant update on table "public"."satr_registration" to "service_role";

grant delete on table "public"."storage_cleanup_queue" to "anon";

grant insert on table "public"."storage_cleanup_queue" to "anon";

grant references on table "public"."storage_cleanup_queue" to "anon";

grant select on table "public"."storage_cleanup_queue" to "anon";

grant trigger on table "public"."storage_cleanup_queue" to "anon";

grant truncate on table "public"."storage_cleanup_queue" to "anon";

grant update on table "public"."storage_cleanup_queue" to "anon";

grant delete on table "public"."storage_cleanup_queue" to "authenticated";

grant insert on table "public"."storage_cleanup_queue" to "authenticated";

grant references on table "public"."storage_cleanup_queue" to "authenticated";

grant select on table "public"."storage_cleanup_queue" to "authenticated";

grant trigger on table "public"."storage_cleanup_queue" to "authenticated";

grant truncate on table "public"."storage_cleanup_queue" to "authenticated";

grant update on table "public"."storage_cleanup_queue" to "authenticated";

grant delete on table "public"."storage_cleanup_queue" to "service_role";

grant insert on table "public"."storage_cleanup_queue" to "service_role";

grant references on table "public"."storage_cleanup_queue" to "service_role";

grant select on table "public"."storage_cleanup_queue" to "service_role";

grant trigger on table "public"."storage_cleanup_queue" to "service_role";

grant truncate on table "public"."storage_cleanup_queue" to "service_role";

grant update on table "public"."storage_cleanup_queue" to "service_role";

grant delete on table "public"."trigger_debug_log" to "anon";

grant insert on table "public"."trigger_debug_log" to "anon";

grant references on table "public"."trigger_debug_log" to "anon";

grant select on table "public"."trigger_debug_log" to "anon";

grant trigger on table "public"."trigger_debug_log" to "anon";

grant truncate on table "public"."trigger_debug_log" to "anon";

grant update on table "public"."trigger_debug_log" to "anon";

grant delete on table "public"."trigger_debug_log" to "authenticated";

grant insert on table "public"."trigger_debug_log" to "authenticated";

grant references on table "public"."trigger_debug_log" to "authenticated";

grant select on table "public"."trigger_debug_log" to "authenticated";

grant trigger on table "public"."trigger_debug_log" to "authenticated";

grant truncate on table "public"."trigger_debug_log" to "authenticated";

grant update on table "public"."trigger_debug_log" to "authenticated";

grant delete on table "public"."trigger_debug_log" to "service_role";

grant insert on table "public"."trigger_debug_log" to "service_role";

grant references on table "public"."trigger_debug_log" to "service_role";

grant select on table "public"."trigger_debug_log" to "service_role";

grant trigger on table "public"."trigger_debug_log" to "service_role";

grant truncate on table "public"."trigger_debug_log" to "service_role";

grant update on table "public"."trigger_debug_log" to "service_role";

grant delete on table "public"."user_activity_log" to "anon";

grant insert on table "public"."user_activity_log" to "anon";

grant references on table "public"."user_activity_log" to "anon";

grant select on table "public"."user_activity_log" to "anon";

grant trigger on table "public"."user_activity_log" to "anon";

grant truncate on table "public"."user_activity_log" to "anon";

grant update on table "public"."user_activity_log" to "anon";

grant delete on table "public"."user_activity_log" to "authenticated";

grant insert on table "public"."user_activity_log" to "authenticated";

grant references on table "public"."user_activity_log" to "authenticated";

grant select on table "public"."user_activity_log" to "authenticated";

grant trigger on table "public"."user_activity_log" to "authenticated";

grant truncate on table "public"."user_activity_log" to "authenticated";

grant update on table "public"."user_activity_log" to "authenticated";

grant delete on table "public"."user_activity_log" to "service_role";

grant insert on table "public"."user_activity_log" to "service_role";

grant references on table "public"."user_activity_log" to "service_role";

grant select on table "public"."user_activity_log" to "service_role";

grant trigger on table "public"."user_activity_log" to "service_role";

grant truncate on table "public"."user_activity_log" to "service_role";

grant update on table "public"."user_activity_log" to "service_role";

create policy "Enable read access for all users"
on "public"."activities"
as permissive
for select
to public
using (true);


create policy "allow all operations for authenticated user"
on "public"."activities"
as permissive
for all
to public
using (true)
with check (true);


create policy "Enable insert for authenticated users only"
on "public"."activity_member"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable read access for all users"
on "public"."activity_member"
as permissive
for select
to public
using (true);


create policy "all access for auth users"
on "public"."activity_member"
as permissive
for all
to authenticated
using (true)
with check (true);


create policy "Enable read access for all users"
on "public"."address"
as permissive
for select
to public
using (true);


create policy "all access to authenticated"
on "public"."address"
as permissive
for all
to authenticated
using (true)
with check (true);


create policy "Allow all access for authenticated users"
on "public"."app_labels"
as permissive
for all
to authenticated
using (true)
with check (true);


create policy "Enable read access for all users"
on "public"."app_labels"
as permissive
for select
to public
using (true);


create policy "write access for auth users"
on "public"."app_labels"
as permissive
for all
to authenticated
using (true)
with check (true);


create policy "Enable read access for all users"
on "public"."arya_samaj"
as permissive
for select
to public
using (true);


create policy "all access to authenticated users"
on "public"."arya_samaj"
as permissive
for all
to authenticated
using (true)
with check (true);


create policy "anybody can insert data"
on "public"."course_registrations"
as permissive
for insert
to public
with check (true);


create policy "enable read access to authenticated users"
on "public"."course_registrations"
as permissive
for select
to authenticated
using (true);


create policy "Enable read access for all users"
on "public"."family"
as permissive
for select
to public
using (true);


create policy "all access to authenticated"
on "public"."family"
as permissive
for all
to authenticated
using (true)
with check (true);


create policy "Enable read access for all users"
on "public"."family_member"
as permissive
for select
to public
using (true);


create policy "all access to authenticated"
on "public"."family_member"
as permissive
for all
to authenticated
using (true)
with check (true);


create policy "Enable read access for all users"
on "public"."member"
as permissive
for select
to public
using (true);


create policy "all access for authenticated users"
on "public"."member"
as permissive
for all
to authenticated
using (true)
with check (true);


create policy "Enable read access for all users"
on "public"."organisation"
as permissive
for select
to public
using (true);


create policy "all operations for authenticated users"
on "public"."organisation"
as permissive
for all
to public
using (true)
with check (true);


create policy "Enable insert for authenticated users only"
on "public"."organisational_activity"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable read access for all users"
on "public"."organisational_activity"
as permissive
for select
to public
using (true);


create policy "Enable insert for authenticated users only"
on "public"."organisational_member"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable read access for all users"
on "public"."organisational_member"
as permissive
for select
to public
using (true);


create policy "allow all operations for logged in user"
on "public"."organisational_member"
as permissive
for all
to authenticated
using (true)
with check (true);


create policy "Enable read access for all users"
on "public"."samaj_member"
as permissive
for select
to public
using (true);


create policy "all access for authenticated"
on "public"."samaj_member"
as permissive
for all
to authenticated
using (true)
with check (true);


create policy "Enable read access for all users"
on "public"."satr_registration"
as permissive
for select
to public
using (true);


create policy "enable insert for all"
on "public"."satr_registration"
as permissive
for insert
to public
with check (true);


create policy "user_activity_admin_full_access"
on "public"."user_activity_log"
as permissive
for all
to service_role
using (true)
with check (true);


create policy "user_activity_no_delete"
on "public"."user_activity_log"
as permissive
for delete
to authenticated
using (false);


create policy "user_activity_no_insert"
on "public"."user_activity_log"
as permissive
for insert
to authenticated
with check (false);


create policy "user_activity_no_update"
on "public"."user_activity_log"
as permissive
for update
to authenticated
using (false)
with check (false);


create policy "user_activity_read_own"
on "public"."user_activity_log"
as permissive
for select
to authenticated
using ((user_id = auth.uid()));


CREATE TRIGGER activities_immediate_cleanup AFTER DELETE OR UPDATE ON public.activities FOR EACH ROW EXECUTE FUNCTION call_immediate_cleanup();

CREATE TRIGGER activity_immediate_cleanup AFTER DELETE OR UPDATE ON public.activities FOR EACH ROW EXECUTE FUNCTION call_immediate_cleanup();

CREATE TRIGGER user_activity_activities_trigger AFTER INSERT OR DELETE OR UPDATE ON public.activities FOR EACH ROW EXECUTE FUNCTION log_smart_user_action();

CREATE TRIGGER user_activity_activity_member_trigger AFTER INSERT OR DELETE ON public.activity_member FOR EACH ROW EXECUTE FUNCTION log_smart_user_action();

CREATE TRIGGER user_activity_address_trigger AFTER INSERT OR DELETE OR UPDATE ON public.address FOR EACH ROW EXECUTE FUNCTION log_smart_user_action();

CREATE TRIGGER arya_samaj_immediate_cleanup AFTER DELETE OR UPDATE ON public.arya_samaj FOR EACH ROW EXECUTE FUNCTION call_immediate_cleanup();

CREATE TRIGGER user_activity_arya_samaj_trigger AFTER INSERT OR DELETE OR UPDATE ON public.arya_samaj FOR EACH ROW EXECUTE FUNCTION log_smart_user_action();

CREATE TRIGGER family_immediate_cleanup AFTER DELETE OR UPDATE ON public.family FOR EACH ROW EXECUTE FUNCTION call_immediate_cleanup();

CREATE TRIGGER user_activity_family_trigger AFTER INSERT OR DELETE OR UPDATE ON public.family FOR EACH ROW EXECUTE FUNCTION log_smart_user_action();

CREATE TRIGGER user_activity_family_member_trigger AFTER INSERT OR DELETE ON public.family_member FOR EACH ROW EXECUTE FUNCTION log_smart_user_action();

CREATE TRIGGER member_immediate_cleanup AFTER DELETE OR UPDATE ON public.member FOR EACH ROW EXECUTE FUNCTION call_immediate_cleanup();

CREATE TRIGGER user_activity_member_trigger AFTER INSERT OR DELETE OR UPDATE ON public.member FOR EACH ROW EXECUTE FUNCTION log_smart_user_action();

CREATE TRIGGER organisation_immediate_cleanup AFTER DELETE OR UPDATE ON public.organisation FOR EACH ROW EXECUTE FUNCTION call_immediate_cleanup();

CREATE TRIGGER user_activity_organisation_trigger AFTER INSERT OR DELETE OR UPDATE ON public.organisation FOR EACH ROW EXECUTE FUNCTION log_smart_user_action();

CREATE TRIGGER user_activity_organisational_member_trigger AFTER INSERT OR DELETE ON public.organisational_member FOR EACH ROW EXECUTE FUNCTION log_smart_user_action();

CREATE TRIGGER user_activity_samaj_member_trigger AFTER INSERT OR DELETE ON public.samaj_member FOR EACH ROW EXECUTE FUNCTION log_smart_user_action();


