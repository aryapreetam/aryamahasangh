name: CI (Push & Pull Request)

on:
  push:
    branches:
      - '**'
    tags-ignore:
      - 'v*'
#    paths:
#      - 'composeApp/**'
#      - 'gradle/**'
#      - 'gradle.properties'
#      - 'settings.gradle.kts'
#      - 'build.gradle.kts'
#      - '.github/workflows/**'
#      - 'maestro-tests/**'
#      - 'supabase/**'  # Trigger on database changes
#      - 'scripts/**'
  pull_request:
    paths:
      - 'composeApp/**'
      - 'gradle/**'
      - 'gradle.properties'
      - 'settings.gradle.kts'
      - 'build.gradle.kts'
      - '.github/workflows/**'
      - 'maestro-tests/**'
      - 'supabase/**'  # Trigger on database changes

permissions:
  contents: read

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # Parse version from gradle.properties (source of truth)
  parse-version:
    name: ðŸ“‹ Parse Version from gradle.properties
    runs-on: ubuntu-latest
    outputs:
      base_version: ${{ steps.version.outputs.base_version }}
      version_dev: ${{ steps.version.outputs.version_dev }}
      version_staging: ${{ steps.version.outputs.version_staging }}
      version_code: ${{ steps.version.outputs.version_code }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Parse version from gradle.properties
        id: version
        run: |
          # Read version from gradle.properties
          MAJOR=$(grep '^version.major=' gradle.properties | cut -d'=' -f2)
          MINOR=$(grep '^version.minor=' gradle.properties | cut -d'=' -f2)
          PATCH=$(grep '^version.patch=' gradle.properties | cut -d'=' -f2)
          
          BASE_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          SHORT_SHA=$(git rev-parse --short HEAD)
          
          # Calculate version code (same logic as AppConfig.calculateVersionCode)
          VERSION_CODE=$((MAJOR * 10000 + MINOR * 100 + PATCH))
          
          # Generate environment-specific versions
          VERSION_DEV="${BASE_VERSION}-dev-${SHORT_SHA}"
          VERSION_STAGING="${BASE_VERSION}-staging"
          
          echo "base_version=${BASE_VERSION}" >> $GITHUB_OUTPUT
          echo "version_dev=${VERSION_DEV}" >> $GITHUB_OUTPUT
          echo "version_staging=${VERSION_STAGING}" >> $GITHUB_OUTPUT
          echo "version_code=${VERSION_CODE}" >> $GITHUB_OUTPUT
          
          echo "ðŸ“¦ Generated versions:"
          echo "  Base: ${BASE_VERSION}"
          echo "  Dev: ${VERSION_DEV}"
          echo "  Staging: ${VERSION_STAGING}"
          echo "  Version Code: ${VERSION_CODE}"

  # Run tests and checks on all branches (COMMENTED OUT FOR TESTING)
#  ci:
#    name: âœ… Run All Tests & Builds
#    uses: ./.github/workflows/ci-reusable.yml

  # Get dev credentials (runs in dev environment)
  get-dev-credentials:
    name: ðŸ“‹ Get Dev Credentials
    runs-on: ubuntu-latest
    needs: [parse-version]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/test-main'
    environment: dev
    outputs:
      project_ref: ${{ steps.export.outputs.project_ref }}
      supabase_url: ${{ steps.export.outputs.supabase_url }}
    steps:
      - name: Export dev credentials (non-sensitive only)
        id: export
        run: |
          # Only export non-sensitive data as outputs
          echo "project_ref=${{ vars.SUPABASE_PROJECT_REF }}" >> $GITHUB_OUTPUT
          echo "supabase_url=${{ secrets.SUPABASE_URL }}" >> $GITHUB_OUTPUT

  # Get staging credentials (runs in staging environment for stagingâ†’prod migration)
  get-staging-credentials:
    name: ðŸ“‹ Get Staging Credentials
    runs-on: ubuntu-latest
    needs: [parse-version, build-deploy-staging]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/test-main'
    environment: staging
    outputs:
      project_ref: ${{ steps.export.outputs.project_ref }}
      supabase_url: ${{ steps.export.outputs.supabase_url }}
    steps:
      - name: Export staging credentials (non-sensitive only)
        id: export
        run: |
          # Only export non-sensitive data as outputs
          echo "project_ref=${{ vars.SUPABASE_PROJECT_REF }}" >> $GITHUB_OUTPUT
          echo "supabase_url=${{ secrets.SUPABASE_URL }}" >> $GITHUB_OUTPUT

  # Database migration for staging (always runs on main or test-main)
  migrate-to-staging:
    name: ðŸ—„ï¸ Migrate Dev â†’ Staging
    runs-on: ubuntu-latest
    needs: [parse-version, get-dev-credentials]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/test-main'
    environment: staging  # Access staging secrets as TARGET
    outputs:
      migration_status: ${{ steps.run-migration.outputs.status }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install PostgreSQL client
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client

      - name: Create local.properties with both dev and staging secrets
        run: |
          cat > local.properties << EOF
          # Dev (Source) - from dev environment (non-sensitive data from job outputs)
          dev_project_ref=${{ needs.get-dev-credentials.outputs.project_ref }}
          dev_supabase_url=${{ needs.get-dev-credentials.outputs.supabase_url }}
          
          # Staging (Target) - from staging environment secrets
          staging_project_ref=${{ vars.SUPABASE_PROJECT_REF }}
          staging_db_password=${{ secrets.SUPABASE_DB_PASSWORD }}
          staging_supabase_url=${{ secrets.SUPABASE_URL }}
          EOF
          
          echo "âœ… local.properties created with credentials"
          # Don't print the file to avoid exposing passwords in logs

      - name: Make migration script executable
        run: chmod +x migrate-direct.sh check-migration-needed.sh

      - name: Check if migration is needed
        id: check-migration
        run: |
          echo "ðŸ” Checking if migration is needed..."
          
          if ./check-migration-needed.sh dev-to-staging 2>&1 | tee /tmp/migration-check.log; then
            # Extract migration_needed from output
            if grep -q "migration_needed=true" /tmp/migration-check.log; then
              echo "âš ï¸  Migration needed - schemas differ"
              echo "needed=true" >> $GITHUB_OUTPUT
            else
              echo "âœ… No migration needed - schemas are identical"
              echo "needed=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "âŒ Migration check failed"
            exit 1
          fi

      - name: Run migration (non-interactive)
        id: run-migration
        if: steps.check-migration.outputs.needed == 'true'
        run: |
          echo "ðŸš€ Running migration dev â†’ staging (non-interactive mode)..."
          
          if ./migrate-direct.sh dev-to-staging --non-interactive; then
            echo "âœ… Migration completed successfully"
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "âŒ Migration failed"
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Skip migration
        if: steps.check-migration.outputs.needed == 'false'
        run: |
          echo "â„¹ï¸  Skipping migration - schemas are already in sync"
          echo "status=skipped" >> $GITHUB_OUTPUT

      - name: Upload migration artifacts
        if: steps.check-migration.outputs.needed == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: migration-dev-to-staging-${{ needs.parse-version.outputs.version_staging }}
          path: supabase/migrations/migration_dev_to_staging_*/
          retention-days: 90
          if-no-files-found: warn

  # Build and Deploy to Staging (after migration)
  build-deploy-staging:
    name: ðŸš€ Build & Deploy Staging
    runs-on: ubuntu-latest
    needs: [parse-version, migrate-to-staging]
    if: |
      (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/test-main') &&
      (needs.migrate-to-staging.outputs.migration_status == 'success' || needs.migrate-to-staging.outputs.migration_status == 'skipped')
    environment: staging
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v3

      - name: Decode and setup keystore
        run: |
          echo "${{ secrets.KEYSTORE_BASE64 }}" | base64 -d > keystore.jks
          echo "KEYSTORE_FILE=keystore.jks" >> $GITHUB_ENV
        env:
          KEYSTORE_BASE64: ${{ secrets.KEYSTORE_BASE64 }}

      - name: Create local.properties for Staging
        run: |
          cat > local.properties << EOF
          sdk.dir=$ANDROID_HOME
          app_version=${{ needs.parse-version.outputs.base_version }}
          environment=staging
          
          # Staging
          staging_supabase_url=${{ secrets.SUPABASE_URL }}
          staging_supabase_key=${{ secrets.SUPABASE_KEY }}
          staging_server_url=https://staging-api.aryamahasangh.org
          
          # Placeholders for other environments
          dev_supabase_url=https://placeholder.supabase.co
          dev_supabase_key=placeholder-key
          dev_server_url=https://placeholder.com
          prod_supabase_url=https://placeholder.supabase.co
          prod_supabase_key=placeholder-key
          prod_server_url=https://placeholder.com
          EOF

      - name: Build Web (WasmJS) for Staging
        run: ./gradlew :composeApp:wasmJsBrowserDistribution

      - name: Deploy to Netlify Staging
        uses: nwtgck/actions-netlify@v2.0
        with:
          publish-dir: './composeApp/build/dist/wasmJs/productionExecutable'
          production-deploy: true
          github-token: ${{ secrets.GITHUB_TOKEN }}
          deploy-message: 'ðŸš€ Staging ${{ needs.parse-version.outputs.version_staging }} - ${{ github.sha }}'
          enable-pull-request-comment: false
          enable-commit-comment: true
          enable-commit-status: true
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}

      - name: Build Android APK (Release) for Staging
        run: ./gradlew :composeApp:assembleRelease
        env:
          KEYSTORE_FILE: keystore.jks
          KEYSTORE_PASSWORD: ${{ secrets.KEYSTORE_PASSWORD }}
          KEY_ALIAS: ${{ secrets.KEY_ALIAS }}
          KEY_PASSWORD: ${{ secrets.KEY_PASSWORD }}

      - name: Build Android App Bundle (AAB) for Staging
        run: ./gradlew :composeApp:bundleRelease
        env:
          KEYSTORE_FILE: keystore.jks
          KEYSTORE_PASSWORD: ${{ secrets.KEYSTORE_PASSWORD }}
          KEY_ALIAS: ${{ secrets.KEY_ALIAS }}
          KEY_PASSWORD: ${{ secrets.KEY_PASSWORD }}

      - name: Rename artifacts with version
        run: |
          mkdir -p artifacts
          
          # Copy APK
          APK_SRC=$(find composeApp/build/outputs/apk/release -type f -name '*-release.apk' | head -n1)
          if [ -n "$APK_SRC" ]; then
            cp "$APK_SRC" "artifacts/aryamahasangh-app-android-${{ needs.parse-version.outputs.version_staging }}.apk"
          fi
          
          # Copy AAB
          AAB_SRC=$(find composeApp/build/outputs/bundle/release -type f -name '*-release.aab' | head -n1)
          if [ -n "$AAB_SRC" ]; then
            cp "$ABB_SRC" "artifacts/aryamahasangh-app-android-${{ needs.parse-version.outputs.version_staging }}.aab"
          fi

      - name: Upload Staging Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: aryamahasangh-app-staging-${{ needs.parse-version.outputs.version_staging }}
          path: artifacts/
          retention-days: 30

      - name: Clean up keystore
        if: always()
        run: rm -f keystore.jks

  # Migrate Staging to Production (requires manual approval)
  migrate-to-production:
    name: ðŸ—„ï¸ Migrate Staging â†’ Production
    runs-on: ubuntu-latest
    needs: [parse-version, build-deploy-staging, get-staging-credentials]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/test-main'
    environment: production  # Requires manual approval + access to prod secrets
    outputs:
      migration_status: ${{ steps.run-migration.outputs.status }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install PostgreSQL client
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client

      - name: Create local.properties with staging and prod secrets
        run: |
          cat > local.properties << EOF
          # Staging (Source) - from staging environment (non-sensitive data from job outputs)
          staging_project_ref=${{ needs.get-staging-credentials.outputs.project_ref }}
          staging_supabase_url=${{ needs.get-staging-credentials.outputs.supabase_url }}
          
          # Production (Target) - from production environment secrets
          prod_project_ref=${{ vars.SUPABASE_PROJECT_REF }}
          prod_db_password=${{ secrets.SUPABASE_DB_PASSWORD }}
          prod_supabase_url=${{ secrets.SUPABASE_URL }}
          EOF
          
          echo "âœ… local.properties created with credentials"
          # Don't print the file to avoid exposing passwords in logs

      - name: Make migration script executable
        run: chmod +x migrate-direct.sh check-migration-needed.sh

      - name: Check if migration is needed
        id: check-migration
        run: |
          echo "ðŸ” Checking if migration is needed..."
          
          if ./check-migration-needed.sh staging-to-prod 2>&1 | tee /tmp/migration-check.log; then
            # Extract migration_needed from output
            if grep -q "migration_needed=true" /tmp/migration-check.log; then
              echo "âš ï¸  Migration needed - schemas differ"
              echo "needed=true" >> $GITHUB_OUTPUT
            else
              echo "âœ… No migration needed - schemas are identical"
              echo "needed=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "âŒ Migration check failed"
            exit 1
          fi

      - name: Run migration to production (non-interactive)
        id: run-migration
        if: steps.check-migration.outputs.needed == 'true'
        run: |
          echo "ðŸš€ Running migration staging â†’ production (non-interactive mode)..."
          
          if ./migrate-direct.sh staging-to-prod --non-interactive; then
            echo "âœ… Migration completed successfully"
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "âŒ Migration failed"
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Skip migration
        if: steps.check-migration.outputs.needed == 'false'
        run: |
          echo "â„¹ï¸  Skipping migration - schemas are already in sync"
          echo "status=skipped" >> $GITHUB_OUTPUT

      - name: Upload migration artifacts
        if: steps.check-migration.outputs.needed == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: migration-staging-to-prod-${{ needs.parse-version.outputs.version_staging }}
          path: supabase/migrations/migration_staging_to_prod_*/
          retention-days: 90
          if-no-files-found: warn

  # Build and Deploy to Production (requires manual approval)
  build-deploy-production:
    name: ðŸš€ Build & Deploy Production
    runs-on: ubuntu-latest
    needs: [parse-version, migrate-to-production]
    if: |
      (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/test-main') &&
      (needs.migrate-to-production.outputs.migration_status == 'success' || needs.migrate-to-production.outputs.migration_status == 'skipped')
    environment: production  # Requires manual approval
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v3

      - name: Decode and setup keystore
        run: |
          echo "${{ secrets.KEYSTORE_BASE64 }}" | base64 -d > keystore.jks
          echo "KEYSTORE_FILE=keystore.jks" >> $GITHUB_ENV
        env:
          KEYSTORE_BASE64: ${{ secrets.KEYSTORE_BASE64 }}

      - name: Create local.properties for Production
        run: |
          cat > local.properties << EOF
          sdk.dir=$ANDROID_HOME
          app_version=${{ needs.parse-version.outputs.base_version }}
          environment=prod
          
          # Production
          prod_supabase_url=${{ secrets.SUPABASE_URL }}
          prod_supabase_key=${{ secrets.SUPABASE_KEY }}
          prod_server_url=https://api.aryamahasangh.org
          
          # Placeholders for other environments
          dev_supabase_url=https://placeholder.supabase.co
          dev_supabase_key=placeholder-key
          dev_server_url=https://placeholder.com
          staging_supabase_url=https://placeholder.supabase.co
          staging_supabase_key=placeholder-key
          staging_server_url=https://placeholder.com
          EOF

      - name: Build Web (WasmJS) for Production
        run: ./gradlew :composeApp:wasmJsBrowserDistribution

      - name: Deploy to Netlify Production
        uses: nwtgck/actions-netlify@v2.0
        with:
          publish-dir: './composeApp/build/dist/wasmJs/productionExecutable'
          production-deploy: true
          github-token: ${{ secrets.GITHUB_TOKEN }}
          deploy-message: 'ðŸš€ Production ${{ needs.parse-version.outputs.base_version }} - ${{ github.sha }}'
          enable-pull-request-comment: false
          enable-commit-comment: true
          enable-commit-status: true
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}

      - name: Build Android APK (Release) for Production
        run: ./gradlew :composeApp:assembleRelease
        env:
          KEYSTORE_FILE: keystore.jks
          KEYSTORE_PASSWORD: ${{ secrets.KEYSTORE_PASSWORD }}
          KEY_ALIAS: ${{ secrets.KEY_ALIAS }}
          KEY_PASSWORD: ${{ secrets.KEY_PASSWORD }}

      - name: Build Android App Bundle (AAB) for Production
        run: ./gradlew :composeApp:bundleRelease
        env:
          KEYSTORE_FILE: keystore.jks
          KEYSTORE_PASSWORD: ${{ secrets.KEYSTORE_PASSWORD }}
          KEY_ALIAS: ${{ secrets.KEY_ALIAS }}
          KEY_PASSWORD: ${{ secrets.KEY_PASSWORD }}

      - name: Rename artifacts with version
        run: |
          mkdir -p artifacts
          
          # Copy APK
          APK_SRC=$(find composeApp/build/outputs/apk/release -type f -name '*-release.apk' | head -n1)
          if [ -n "$APK_SRC" ]; then
            cp "$APK_SRC" "artifacts/aryamahasangh-app-android-${{ needs.parse-version.outputs.base_version }}.apk"
          fi
          
          # Copy AAB
          AAB_SRC=$(find composeApp/build/outputs/bundle/release -type f -name '*-release.aab' | head -n1)
          if [ -n "$AAB_SRC" ]; then
            cp "$AAB_SRC" "artifacts/aryamahasangh-app-android-${{ needs.parse-version.outputs.base_version }}.aab"
          fi

      - name: Upload Production Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: aryamahasangh-app-production-${{ needs.parse-version.outputs.base_version }}
          path: artifacts/
          retention-days: 90

      - name: Clean up keystore
        if: always()
        run: rm -f keystore.jks
